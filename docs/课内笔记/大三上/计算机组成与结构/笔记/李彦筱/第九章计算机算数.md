# 第九章 计算机算数

## KEY POINTS

1. 算术逻辑单元的结构与功能

2. 整数的表示，包括无符号数的表示以及有符号数的原码、反码、补码和真值的关系与转换

3. 整数运算，整数的扩展，整数的取反方式，原码整数的加减运算，补码数的加减运算，溢出的概念与判别方式

4. 浮点数的表示与运算，浮点数的规格化表示，浮点数的精度和范围的关系，<mark>计算搞懂PPT就行</mark>

> 2022 年没有考整数乘除法运算。

> 易俊泉学长的原始笔记链接如下：
>
> [chapter09 计算机算数](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter09计算机算数.md)

## 算术逻辑单元（ALU）

计算机算数需要同时对整数和浮点数做处理。这两种数字的表示方式和运算方式迥然不同。ALU 负责完成这两种数的算术运算和逻辑运算。

算术逻辑单元 ALU 是计算机实际算术/逻辑运算的部件

数据由寄存器提交给 ALU，运算结果也存放于 ALU，控制器提供控制 ALU 操作和数据传入送出 ALU 的信号；ALU 根据运算结果会设置一些标志

![image-20211029114453258](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704214.png)

>
>
>ALU 输入寄存器存放需要计算的内容
>
>ALU 的控制线连接到 CU，用于指明运算的操作。
>
>ALU 的输出同样放到某个寄存器中。一般 ALU 只和寄存器进行输入/输出，不能直接连接主存。需要通过其他指令和主存读/写。
>
>Flag 是 ALU 输出的对部分标志位的更新。

ALU 可以执行整数运算或者浮点运算。浮点数和整数的表示规则和运算规则完全不同，因此在程序中声明数据类型时需要声明数字是整数还是浮点数。

ALU 的输入输出都面向寄存器而非直连主存。这是因为 ALU 是组合逻辑电路，输入后立刻产生输出，和带时序逻辑的总线/内存难以相容。

## 整数的表示

计算机中只用 0 和 1 代表一切，因此一切数字都以二进制存储。

n位二进制数字 $a_{n-1}a_{n-2}....a_1a_0$表示无符号整数A![image-20211226115848169](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704215.png)（位值原理）

正整数可以自然的由十进制转为二进制，从而直接表示；但是负整数和浮点数该如何表示呢？

我们先看整数如何表示：

### 符号-幅值表示法|Sign-Magnitude Representation（原码）

最左边的位是符号位，用于表示整数的正负。

> 0意味着正数、1意味着负数

+18 = 0 0010010	-18 = 1 0010010

**问题**

在算术中需要同时考虑符号和大小，电路上实现太过复杂

数字 0 存在两种不同表示(+0和-0)

因为上述问题，这种表示方法很少使用

### 补码表示法|Two’s Complement Representation

正数补码=原码

负数的补码=按位取反原码（除了符号位）再+1

![image-20211226120558442](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704191.png)

![image-20211226120749843](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704193.png)

优点：

1. 只有一种 0 的表示方式

2. 减法可以直接当做加法进行
3. 补码取反较为简单（按位取反，再+1即可）

因此，这种表示方式是最常使用的。

![image-20211226122201094](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704194.png)

正确的例子：-0 = 0；错误的例子：-（-128）=-128（这是因为补码只能表示 -128~127，而现在想要的出的结果是 128，这个结果自然不可能用补码正确的表示）

> 如果把 -128 表示为 1 1000 0000（增加一位用于表示），那么其取反结果（0 1000 0000）就是正确的了

#### 8/16 位补码取值范围

8 位二进制码的范围：-128～+127

> $+127 = 01111111 = 2^7 -1$
>
> $-128 = 10000000= -2^7$

16 位二进制码的范围：-32768～+32767

> $+32767 = 011111111 11111111 = 2^{15} - 1$
>
> $-32768 = 100000000 00000000 = -2^{15}$

> 由于 0 的存在，补码的正负两端是不对称的。一般来说，补码的负端绝对值可以比正端大 1。

#### 补码位长的扩充

扩充是指在运算时发现操作数精度不够时，把前面加上几位保证精度。即将一个 n 位二进制整数用 m 位表示，且 m>n：

正数：左侧空余位用 0 填充（01011000 -> 00000000 01011000）

负数：左侧空余位用 1 填充（10001000 -> 11111111 10001000）

这样扩充后的数字和扩充前表示的是相同的数字。

扩展规则：把符号位移到最左边，中间空出的位置用符号位填充（正数：0 负数：1）



上述两种表示方法都是**定点表示法**，即假设小数点定于某个位置。在表示整数时，小数点隐含在整数最右侧位的右边。这种方法适合表示整数，但不适合浮点数的运算。

## 整数运算

以下介绍一些整数常见的运算。除非特别说明，否则下方的运算都是针对整数补码表示的。

### 取反

原码表示 ：符号位取反

> 由于原码存在 +0 和 -0 两种 0 的表示，因此其表示的所有数字全都是对称的，不用担心哪个数字取反后溢出。
>
> 补码只有一种 0 表示法，因此正数和负数的范围肯定不一致，取反时有点可能溢出。

补码表示：对该数补码的所有位（包括符号位）取反，然后 +1

比如，补码 3 = 00000011

> 取反+1=11111100+1=11111101=-3

-3=11111101

> 取反+1=00000010+1=00000011=3

需要注意的是n位二进制补码数A的范围是 $[-2^{n-1}，2^{n-1}-1]$，，是不对称的，所以对数值为 $-2^{n-1}$ 的数取负时要先扩展至少 1 位才能按规则取负，直接取反会导致溢出。

### 加减法

加法规则：普通二进制加法

注意计算结果是否溢出：仅当两个同符号数相加时，可能发生溢出。

溢出规则：**若两个正数或两个负数相加，当且仅当结果的符号位变反时，发生溢出**。比如，两个符号位=1（负数）加出了正数（符号位=0），那么一定是溢出了。

> 通俗：看符号位是否变号

**正数和负数相加时，永远不会发生溢出。**

溢出仅在运算结果无法用这么多位的补码表示时出现。（比如 4 位补码范围为 -8～7，计算 5+4 得到结果为 9，溢出了，实际得到了 -1（1001）

减法规则：对减数取负(求补)，并把它加到被减数上。

> a - b = a + (-b)
>
> 减法可用加法器实现
>
> 溢出规则同加法，只需要检查 a 和 -b 是否同号，且运算后符号位变反

因此，*计算机中没有减法器，只需要加法器和求补器*。

下方是一些整数加减法的计算过程实例：

![image-20211226123644927](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704195.png)

比如，5 + 4  运算结果为 1001，其结果符号位从 0 变为 1，且两个运算数都是正数，因此发生了溢出。

**溢出并不取决于是否产生了被舍弃的高位，而是取决于符号位是否变化**。比如 -4+4=0 计算中，最高位的 1 发生了溢出，但由于两个运算数一正一负，我们认为这是正常的，没有溢出。

![image-20211226123926286](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704197.png)

上图描述了整数加减法需要的元件。SW 是一个选择器，选择做加法还是减法；如果做加法，就直接取 B 寄存器的值；如果做减法，就取 B 寄存器经过求反器（Complementer）后的值。计算结果可以放到操作数 A 寄存器中。

加法器还需要输出一个溢出标志（OF）。

### 乘法【了解】

#### 无符号数

![image-20211226124034121](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704198.png)

以上图片为人计算乘法时的算法，和十进制乘法的计算方法几乎相同。

**这种算法的困难**

- 将多个部分积一次全部相加，机器难以实现

- 需要存储每一个部分积，而且最后乘积位数增加了一倍，这就会造成器件的浪费和运算时间的增加

![image-20211226124646281](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704199.png)

上图描述了计算机中实际的计算方法：

对于乘数为 0 时，部分积为 0，因此不用乘法，直接把之前存储的结果右移一位即可。

乘数为 1 时，先计算部分积（其实就是另一个乘数），然后和之前存储的和相加，再右移一位。

移位后，右侧溢出的位需要被存储起来（参见图片里的红字）。最后，把右移出的所有位加在结果右侧，形成具体结果。

硬件实现方式：

![image-20211226124917277](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704200.png)

#### 补码乘法计算

![image-20211226125106673](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704201.png)

使用纸笔按照十进制方法计算，也无法得到正确的结果，需要开发新的算法。

一种方法是把两数转换成正数再相乘，如果符号不同，最后结果变号。但是，这实在是很麻烦，对电路设计要求也高。另一种方法是采用布斯算法。

![image-20211226125148003](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704202.png)

注意：布斯算法采用的是算术右移，A 最左侧的位置一直都是符号位；正数乘法的右移是直接右移，左侧总是用 0 填充。

A，Q，$Q_{-1}$ 在物理意义上是连续排列的。也就是说，对 Q 做右移，其最低位就会右移到 $Q_{-1}$中；A 的最低位会右移到 Q 最左侧。

### 除法【了解】

除法比乘法运算复杂的多，不过它是基于纸笔演算法的

> 不像上面提到的乘法中，没有一种实现真的用了纸笔算法。

![image-20211226125437443](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704203.png)

负整数转换为无符号数计算即可，最后处理符号位（检查是否需要更改符号位），就像没有布斯算法的乘法（

## 浮点数表示法

我们已经学习了如何表示整数，以及整数之间如何运算。那么如何表示小数呢？

引入：定点表示法

整数表示本质上是表示了一个小数点定在最后位置的数。如果我们规定小数点在中间的某个位置，比如必须在 8 个数的中间，那么我们就可以表示有限位数的小数了：

- 1001.1010 = $2^4+2^0+2^{-1}+2^{-3}$=9.625

但是，这种方法只能表示范围非常有限的小数（因为整数位被小数位侵占了 4 位），而且在处理乘除法时，小数点位置的确定非常麻烦。

因此，我们借鉴科学计数法表达小数：

### 表示原理

$$
±S×B^{±E}
$$

符号位：0 正，1 负

B：指数的基。是隐含的，等于 2 ，因此不需要存储

S：有效数，小数点位置为最高位有效位的右边，即小数点左边有 1 位有效数，剩余空间都在小数点右边。对于二进制数，有效数的小数点前只能是 1，（如果是 0，可以通过不断右移小数点让小数点前的一成为 1）因此在存储时并不存储小数点前的这位，从小数点后才开始存储。

E：指数或者阶，表示小数点实际上该在的位置

$$
±S×B^{E^{'}}
$$
存储的指数值E’为移码，是无符号数，存储的指数值 = 真正的指数 + 偏移量(目的：把指数转化为正数方便比较)

通常，偏移量等于 $2^{k-1}-1$，其中 k 为：二进制指数的位数。

比如，如果指数位有 8 位，其范围就是 [-127, 128]（注意不是 [-128,+127]）；其偏移量为 $2^{8-1}-1$=127，因此其在小数表示中的范围是 [0, 255]，实际存储值成为了非负数。

> 注意：指数位的范围和一般的补码不同，正数的绝对值大于负数的绝对值 1。
>
> 而且，注意增加偏移量之后实际存储的数字最小为 0。不过，实际表示的数字还是原先的样子。

![image-20211226143852829](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704205.png)

比如：

- $1.1010001 \times 2^{10100} = 0\ 10010011\ 10100010000000000000000$

  第一个位置是符号位，第二个位置是加了偏置（+127）的指数（10100 + 0111 1111 = 1001 0011），第三个值是小数点后侧的位（前面的 1 不存储）
  
- 存储的内容都是按照二进制原码存储的。因此，计算加减时需要按照原码规则计算。

### 小数的表示范围

注意：**32 位浮点数和 32 位整数表示的数个数是相同的**，即使表示范围不同。

> 由于在一个有限范围内的浮点数是无限的，因此 32 位浮点数不可能表示其范围内的任何一个浮点数，一定会出现精度丢失
>
> 由于在一个有限范围内的整数数是有限的，整数就没有精度丢失的问题

![image-20211226144102932](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704206.png)



> 比$-(2-2^{-23})\times 2^{128}$还小的负数，叫做**负上溢（negative overflow）**（负值太大了）
> 比$-2^{-127}$还大的负数，叫做**负下溢(negative underflow)**。
> 零。
> 比$2^{-127}$还小的正数，叫做**正下溢（positive underflow**）。
> 比$(2-2^{-23})\times 2^{128}$还大的正数，叫做**正上溢**
>
> 上溢一般比下溢严重：上溢会导致数据无法表示，但是下溢大不了就表示成 0

为什么最大值是 $(2-2^{23})\times 2^{128}$ 呢？这是因为：有效值最大值就是 23 个数字都为 1 的情况，这种情况下，有效值为：

1.111 1111 1111 1111 1111 （小数部分为 23 个 1）

我们用位值原理把这个数字转换成十进制的，可以计算为：
$$
1+2^{-1}+2^{-2}+...+2^{-23}=1+2^{-1}+2^{-2}+...+2^{-23}+2^{-23}-2^{-23}=2-2^{-23}
$$
因此会出现 $2-2^{-23}$ 这种诡异的形式



对于一个 32 位数，8 位用于指数，23 位用于有效数（剩下一位是符号位）

表示范围：$+/- 2^{128} ≈ 3.4 \times 10^{38}$，远大于 32 位整数的空间

精确度：$2^{-23} ≈ 1.2 \times10^{-7}$，大约 6 位小数空间

> 当增加指数位数时，可以扩大所表示数的范围，但会导致精度降低（因为基数可表示的数减少了），反之亦然
>
> 需要在表示范围和精度之间进行权衡

一般来说，越接近 0 的浮点数精度越高，越远离 0 的浮点数精度越低。可表示的浮点数并不是均匀的分布在数轴上的。

> 注：如果你看过 IEEE 754 标准的话，应该知道浮点数实际分为「规约的」和「非规约的」两种，其各位指代的含义不同。不过，本课程中仅涉及规约的浮点数。

### 算术运算

对于加法和减法运算，必须要保证两个操作数有着相同的指数, 而乘法和除法就相对简单很多（直接乘指数位即可）。

![image-20211226145339805](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704208.png)

浮点数运算可能会存在的一些特殊情况

> **指数上溢Exponent overflow**：（常见于乘法）数值太大，超过可表示的范围，问题严重需要报告
>
> **指数下溢Exponent underflow**：数值太小超过可表示范围，一般设为0
>
> **有效数下溢Significant underflow**：有效数对齐时，有数字从右边移出丢失，需要舍入
>
> **有效数上溢Significant overflow**：同符号数相加时导致有效位的进位，使得小数点前有两位有效数，需要通过增加指数，右移有效数来重新进行规格化

**下溢的问题比较小（实在不行就设置为 0），上溢问题大**

#### 加减法

**浮点运算加法和减法运算过程**

:one: 检查0

:two: 对齐指数

指数小的数对齐指数大的数，此时小数点会左移，指数右侧可能丢失数据（造成下溢）；

如果采用指数大的数对齐指数小的数，就可能发生上溢，造成严重问题。

:three: 重复右移较小操作数，直到指数相同：一旦溢出发生，造成的影响较小

:four: 加或减有效值

:five: 规格化结果

![image-20211226150242283](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704209.png)

#### 乘除法

![image-20211226150150265](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704211.png)

由于两个存储的指数都加上了偏置，在进行乘除法运算（指数加/减）后，得到的指数会加上两个偏置/没有偏置。因此，需要额外减去一个偏置（乘法）或者加上一个偏置（除法）才能得到正确的指数。

![image-20211226150300180](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704212.png)
