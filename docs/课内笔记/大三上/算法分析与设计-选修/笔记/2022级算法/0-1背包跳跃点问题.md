# 跳跃点 0-1 背包问题

> 此问题在 2024 年考试中考过，因此着重写一下

![image-20241225173341115](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AANzZ6RkE-S-ngkaCtzug4I2_qv6nwEAAs4UAAIHrilVU3kz76QPLeA2BA.png)

也就是说，在 i 固定的情况下，随着 j 的增大，当前最大价值是不减的（很显然，空间多了就可以放更多东西，价值就更高了）

如果使用 p[i] 存储全部的跳跃点（即随着 j 增大，最大价值变化到的所有值），那么可以通过 p[i-1] 递归的计算这些跳跃点。

假设 p[i] 存储的每个内容都是一种选择，其包含两项：选择的所有物品的总重量， 选择的所有物品的总价值，比如：假设四个物品为：(Wi,Vi)|(2,3),(3,6),(4,9),(2,7)

那么 p[2] =[(0,0),(2, 3),(3, 6),(5, 9)]

![image-20241225174256489](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAN0Z6RkFkoAAZOq6BY86-v2CgcNEa0aAALPFAACB64pVbm5UMpAHqHqNgQ.png)

接下来介绍递推方法：

定义数组 q[i] 存储即仅仅考虑前 i+1 个物品的情况下，且必然选择第 i+1 个物品时，所有可能的结果情况。比如：q[1] 定义为：

所有 i=2 时，且一定选择第二个物品时，所有可能的结果，包含：

- 选择 (3, 6)（必选） 但不选择（2,3）（因此结果为（3，6））
- 选择（3，6）（必选）和（2，3）（因此结果为（5，9））

然后，我们可以通过 p[i-1] 和 q[i-1] 递推得到 p[i]，这是因为 q[i-1] 中包含了「含有第 i 个物品」的所有情况。但是，如果直接合并这两个数组的话，其中会有些从找最大值角度看，没有意义的元素：

比如，对于上图的 p[2] 和 q[2]，直接合并可以得到：

p[3] = [(0,0),(2,3),(3,6),(4,9),(5,9)]

但是仔细检查一下：我们有两种情况都能让最后的价值达到 9，但是有一种需要占 5 空间，有一种只占 4，那占用为 5 的方案就没有任何意义了，因此可以去除，得到和 ppt 相同的结果。

准确来说，对于 p 或者 q 数组的任何两个点 (a,b), (c,d) 都有：

- 如果 c>=a 且 d<b，那么(c,d) 这个点就是没有意义的，因为 （a,b）做到价值比 (c,d) 高的同时，占用空间还更小，那 (c,d) 存在的意义是什么？
- 如果 c>a 且 d<=b，那么（c,d) 同样是没有意义的

这样的点 (c,d) 被称为受控跳跃点，是可以直接删除的。

综上，我们可以这样从 p[i-1] 和 q[i-1] 得到 p[i]：

- 从 p[i-1] 得到 q[i-1]：q[i-1] 相当于对每个 p[i-1] 的结果再加上必选第 i 个物品得到的结果。比如：

  p[1] = [(0,0), (2,3)]，而第二个元素为 (3,6)，最大重量为 5，因此 p[1] 的两个元素都能加上（3，6），得到：

  q[1] = [(3,6),(5,9)]

  这和 ppt 的内容相符。

  再比如，p[2] = [(0,0),(2,3),(3,6),(5,9)]，而第三个元素为 (4,9)，最大重量为 5，因此除了 (0,0) 之外，任何一个 p[2] 中的元素都无法加 (4,9)（加上就超重了），因此只有：

  q[2] = [(4,9)] 

  这和 ppt 的内容相符。

- 合并 p[i-1] 和 q[i-1] 得到 p[i]，然后清除受控的跳跃点：

  比如，合并 p[3] 和 q[3] 后，可以得到一个很乱的数组：

  [(0,0),(2,3),(3,6),(4,9),(2,7),(4,10),(5,13)]

  其中包含了三个可删除的受控跳跃点：

  1. (2,3) 和 (2,7)：2=2 但 3<7，删除（2,3)
  2. (3,6) 和 (2,7)：3>2 但是 6<7，删除(3,6)
  3. (4,9) 和 (4,10)：4=4 但是 9<10，删除 (4,9)

  最后得到：p[4] = [(0,0),(2,7),(4,10),(5,13)]。

通过 p[4] 当中价值最大的点对，就可以得到问题的结果。

 时间复杂度分析：

存在 n 个跳跃点集合，对于 p[i]，包含不多于 $2^i$ 个点（把每个选/不选视为 0-1 操作，共 i 个点排列组合）。

因此，总共需要计算  $\Sigma_{i=1}^{n}2^i$ 种点，复杂度在 O($2^n$) 内。

如果重量为整数，那么每个集合最多可能出现 c+1 个点（c 为背包重量），这是因为不能出现可用重量重复的情况，一旦出现，说明其中一定存在受控跳跃点/重复跳跃点，应当删除。这种情况下，时间复杂度又在 O(nc) 内（n 为 p 数组数量，c 为背包重量）

因此，时间复杂度在 O(min{$2^n, nc$}) 内，快于原先版本。

