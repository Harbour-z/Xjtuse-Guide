# CPU 调度

> 易俊泉学长的原始笔记链接如下：
>
> [第六章-CPU调度](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第六章-CPU调度.md)

## 6.1 回顾：OS 的三级调度

**长(Long-term)调度——作业调度**

> 决定把外存输入井上处于作业后备队列上的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后再将新创建的进程排在就绪队列上，准备执行。
>
> 是进程从作业队列->就绪队列的方法

**短(Short-term)调度——进程调度**

> 决定就绪队列中哪个进程将获得 CPU 时间片

**中级(Medium-term)调度——对换**

> 进程在是否挂起之间的交换

![image-20211012163118655](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211012163118655.png)

## 6.2 Basic Concepts  (基本概念）

通过多道程序设计**得到 CPU 的最高利用率**。进程可能由于访问 I/O 设备而阻塞，此时的最佳方式就是把这个进程暂时移开，执行其他可以执行的进程。

CPU 脉冲的分布,在系统中,存在许多短 CPU 脉冲,只有少量的长 CPU 脉冲

> 比如：I/O型作业具有许多短 CPU 脉冲,而 CPU 型作业则会有几个长 CPU 脉冲,这个分布规律对CPU 调度算法的选择是非常重要的

**CPU 调度**：当 CPU 空闲时(当进程离开 running 状态时)，OS 就选择**内存中**的某个就绪进程，并给其分配 CPU

> 即只要就绪队列中存在进程，CPU 就会一直执行程序，不会停下。

进程从阻塞转变为就绪状态时，也可能需要 CPU 调度。

> 对于抢占式调度，当一个进程从阻塞转变为就绪状态时，操作系统需要检查其优先级，以决定是否用它抢占当前正在运行的进程。

![image-20211012163742438](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211012163742438.png)

CPU **调度的时机**：

:one: 从运行到等待	:two: 从运行到就绪	:three: 从等待到就绪	:four: 终止运行

1、4 时机触发的调度属于非抢占方式调度，2、3 时机触发的调度属于抢占式调度

> 从等待到就绪为何是抢占式调度：如果一个优先级比当前运行进程优先级更高的进程从等待状态变为就绪状态，那么，这个进程会直接抢占 CPU，把正在运行的进程踢出去，不需要等待当前占用 CPU 的进程的时间片结束。
>
> 几种抢占式调度算法（比如 SJB，优先级调度）会出现上述情况。

### 抢占式与非抢占式调度[重点]

**非抢占方式**（nonpreemptive）

把处理机分配给某进程后，便让其一直执行，直到该进程完成或发生某事件而被阻塞时，才把处理机分配给其它进程，不允许其他进程抢占已经分配出去的处理机。

即其他进程无法打断当前运行中的进程。

> 优点:实现简单、系统开销小，适用于大多数批处理系统环境
>缺点:难以满足紧急任务的要求，不适用于实时、分时系统要求

**抢占方式**（Preemptive mode）

允许调度程序根据某个原则，去停止某个正在执行的进程，将处理机重新分配给另一个进程。

**抢占原则**

时间片原则:各进程按时间片运行，当一个时间片用完后，便仃止该进程的执行而重新进行调度。这个原则适用于**分时系统。**

> 短调度一般就依据时间原则调度多个程序

优先权原则：通常对一些重要的和紧急的进程赋予较高的优先权。当优先权高的进程进入就绪队列时，如果其优先权比正在执行的进程优先权高，便打断正在执行的进程，自己开始执行

短作业优先原则：当新到达的作业比正在执行的作业明显短时，将暂停当前长作业的执行，将处理机分配给新到的短作业。

> 短作业优先其实是一种特殊的优先权原则：消耗时间短的作业优先调度。

### Dispatcher 分派程序

分派程序负责将对CPU的控制权转交给短调度选择的进程，包括**切换上下文、切换到用户态与跳转到用户程序的适当位置并重新运行之**

**分派延迟** – 分派程序终止一个进程的运行并启动另一个进程运行所花的时间

## 6.3 Scheduling Criteria（调度准则） 

调度要达成的目标有哪些？调度程序应该按照什么原则执行调度？

重点：**CPU利用率高**

**吞吐量要大**——单位时间内运行完的进程数；吞吐量大说明 CPU 完成的作业多。，

**周转时间要短**——进程从**提交到运行**结束的全部时间

**等待时间要短**——进程在**就绪队列中等待调度**的时间片总和 

**响应时间要短**——从**进程提出请求到首次被响应**的时间段（在分时系统环境下不是输出完结果的时间]）

**带权周转时间**——**作业周转时间与作业时间的比**

平均周转时间：**进程从进入作业队列到结束的平均时间**（不是进入内存开始算）

调度算法只影响进程的等待时间，不会影响进程占用 CPU 的时间或者进程 I/O 消耗的时间

## 6.4 Scheduling Algorithms（调度算法）[重点]

<font color="red">调度算法影响的是等待时间，而不能影响进程真正使用CPU的时间和I/O时间</font>

### FCFS 先来先服务

先来先服务（First-Come-First-Served）:

> 最简单的调度算法，就像排队叫号一样
>
> 可用于作业或进程调度
>
> 算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序来选择作业（或进程） 

FCFS算法属于**非抢占方式**：一旦一个进程占有处理机，它就一直运行下去，直到该进程完成或者因等待某事件而不能继续运行时才释放处理机。

FCFS算法易于实现，表面上很公平，实际上**有利于长作业，不利于短作业；有利于 CPU 繁忙型，不利于 I/O 繁忙型**。

> 因为FCFS 不会打断正在执行的进程（时间片到也不会），因此长作业可以占用很长时间的 CPU，短作业只能在就绪队列里干等着。
>
> FCFS 具有「护航效应」：大型或资源密集型进程占用系统资源，并导致等待使用这些相同资源的其他进程积压。在 FCFS 调度下，进程按照其到达系统的顺序执行，无论其资源需求或紧急程度如何。这意味着，如果一个大进程较早到达队列，它将首先执行，即使有较小、优先级较高的进程在其后面等待。由于大型进程长时间消耗资源，因此在其后面等待的其他较小进程被迫在队列中等待，从而导致等待这些相同资源的进程堆积。
>
> 在实际中，I/O 进程只占用很少的 CPU 时间，但必须等待 CPU 繁忙型进程完成 CPU 使用时，I/O 进程才能使用 CPU。I/O 进程使用完后，CPU 将会空闲。

![image-20211221192641664](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211221192641664.png)

从上面左图中可以看出，由于 FCFS 不区分作业长度，后面两个短作业因为前面有长作业而等待了很久，平均等待了 17 的时间；

右图中可以看出，同样长度的三个作业，当短进程先到达时，平均等待时间只有 3。因此，FCFS 这一策略很不稳定，等待时间很大程度上取决于长进程和短进程哪个先到。

### Shortest-Job-First (SJF) 短作业优先

**选择执行时间最短的作业优先去调度**

短作业调度有**两种方式**

> **非抢占式调度** nonpreemptive – 一旦进程拥有 CPU，它就会一直占用，直到自己让出
>
> **抢占式调度** Preemptive – 比当前进程剩余时间片更短的进程到达时，打断当前进程，让新进程提前运行。也称为最短剩余时间优先调度

SJF是最优的 – **对一组指定的进程而言，它给出了最短的平均等待时间和最短的平均周转时间**

将短作业移到长作业前面，则短作业等待时间的减少大于长作业等待时间的增加。

<font color="red">**举例运算**</font>

![image-20211012172102109](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211012172102109.png)

抢占式短作业优先调度：

- 每当一个进程前来时，比较当前进程剩余时间片和新进程所需时间片哪个少；如果新来的少，就优先执行新的进程。
- 每当一个进程执行结束时，调度就绪队列中剩余执行时间最短的进程

采用 SJF **有利于系统减少平均周转时间,提高系统吞吐量。**

一般情况下 SJF 调度算法比 FCFS 调度算法的效率要高一些, 但实现相对要困难些。

> 因为 SJF 的调度顺序取决于进程占用 CPU 的时间，但是实际中无法得知精确的占用时间，只能估计，因此可能出现调度顺序问题。

可以利用如下公式估计进程占用 CPU 的时间：（不是很重要）
$$
\tau_{n+1}=\alpha t_n+(1-\alpha)\tau_n
$$
$\tau_{n+1}$：预测下一次进程占用 CPU 的时间

$t_n$：进程之前实际占用 CPU 的平均时间

$\tau_n$：上次预测的进程占用 CPU 的时间

$\alpha$：自己选的系数

如果作业的到来顺序及运行时间不合适，会出现**饥饿现象**，例如，系统中有一个运行时间很长的作业 JN，和几个运行时间小的作业，然后，不断地有运行时间小于 JN 的作业的到来，这样，作业 JN 就因得不到调度而饿死。另外，作业运行的估计时间可能不精确

> 解决方式：老化，在优先级调度中有提到

### 优先级调度

每个进程都有自己的优先级（整数），CPU 分配给最高优先级的进程（假定最小的整数拥有最高的优先级）

和 SJF 一样，优先级调度可以是抢占的、也可以是非抢占的。

> SJF 可以看作优先级调度的一个特例：SJF 相当于「优先级完全由运行时间决定」的优先级调度。

确定进程优先权的依据有：

:one: :star2:**静态优先权**在进程创建时确定，且在整个生命期中保持不变。:star2:

> **进程类型**，通常系统进程的优先权高于一般用户进程的优先权，前台进程高于后台进程。在用户进程中，I/O 繁忙的进程应优先于 CPU 繁忙的进程，以保证 CPU 和 I/O 设备之间的并行操作。
>
> **进程对资源的需求**，如进程执行时间及内存需要少的进程应赋予较高的优先权；
>
> **根据用户要求**，由用户的紧迫程度及用户所付费用的多少来确定进程的优先权。
>
> 在分时系统中，**前台进程应优先于后台进程**

问题：**饥饿 – 低优先级的可能永远得不到运行**（可能因为高优先级进程不断插队而无法运行）

解决饥饿现象——老化：**视进程等待时间的延长提高其优先数**（即使用动态优先级）

:two: **动态优先权**是指进程的优先权可以随进程的推进而改变，以便获得更好的调度性能

改变优先权的可能因素：

- 进程的等待时间（等待时间越长，优先级越高）

- 已使用处理机的时间（使用时间太长，降低优先级）

- 资源使用情况

Unix 的做法：

- 降低 CPU 类进程的优先级
- 当一个进程从阻塞状态变为就绪状态时，提高其优先级

Windows 的做法：

- 当进程完成 I/O 时，提高其优先级
- 给予饥饿的进程一个额外的时间片

### 时间片轮转算法（Round Robin，RR）

该算法主要用于分时系统中。

每个进程将得到小单位的 CPU 时间[时间片]，通常为 10-100 毫秒。时间片用完后，该进程将被抢占并插入就绪队列末尾。

调度方法：按照进程在就绪队列中的顺序，轮流调度（和 FCFS 的调度顺序一样）

> 可以认为，时间片轮转调度就是抢占式的 FCFS 调度

![image-20211012172922857](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211012172922857.png)

一般来说，RR 的平均周转时间比 SJF 长（毕竟抢占式 SJF 的平均周转时间是最短的），但**响应时间要短一些**（因为时间片时长是固定的）

时间片长短的影响：

- 时间片太长的话，大部分进程在一个时间片内执行完，就成了 FCFS 了；

- 时间片太短的话，进程上下文切换次数太多，系统的开销较大。

**一组进程的平均周转时间并不一定随着时间片的增大而降低。一般来说，如果大多数（80%）进程能在一个时间片内完成，就会改善平均周转时间**

### 多级队列 Multilevel Queue Scheduling

把所有进程按其属性来分类，如进程的类型、优先权、占用内存的多少，每类进程组成一个就绪队列，每个进程固定地处于某一个队列，如

> 就绪队列分为:（前台）[交互式]、（后台） [批处理]
>
> **每个队列有自己的调度算法**： 比如前台 – RR、  后台 – FCFS

因此，多级队列调度的唯一问题就是：应该调度哪个队列里的进程？有两种方式：

固定优先级调度，即前台运行完后再运行后台。有可能产生饥饿（后台进程被无限插队，一直无法执行）

给定时间片调度，即每个队列得到一定比例的 CPU 时间。如，80% 的时间执行前台的 RR 调度，20% 的时间执行后台的 FCFS 调度

这种调度方法有一个问题：由于进程被固定分到一个队列里，它的优先级永远不变，不能基于其消耗时间/等待时间动态调整优先级。为了解决这个问题，人们引入了多级反馈队列算法。

### 多级反馈队列 Multilevel Feedback Queue

<font color="blue">**多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展**</font>

> 优先级算法的体现：优先调度优先级高的队列中的进程
>
> RR 算法的体现：每个队列中都使用时间片轮转的方法调度，不过时间片大小不同
>
> 由于进程所属的队列可以动态改变，即使一直调度优先级最高的队列，由于进程自身能换队列，也不容易导致饥饿。

此算法是抢占式的：当优先级更高的队列出现进程后，立刻剥夺当前来自更低优先级队列的进程的 CPU，转而分配给优先级高的队列中的进程。

- 存在多个就绪队列，具有不同的优先级，各自**按时间片轮转法调度**

  由于 FCFS 其实相当于时间片大小无限的时间片轮转法，因此等级最低的就绪队列也可以采用 FCFS。

- 允许进程在队列之间**移动**

- 各个就绪队列中时间片的大小各不相同，**优先级越高的队列时间片越小**。

- 如果一个进程执行一个完整的时间片后仍未结束，其优先级会降低一级，并进入下级就绪队列。这种降级过程会继续进行，直至进程的优先级降至基本优先级。相反，当一个进程从阻塞态转变为就绪态时，其优先级会提高一级，该过程也可以多次进行。

- 最后会将 I/O 型和交互式进程留在较高优先级队列（因为执行时间短，阻塞-就绪次数多）

![image-20211012173708040](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211012173708040.png)

###  高响应比优先 (作业)调度算法

Highest Response Ratio Next (HRRN)

是一种**动态调整进程优先级**的方法，因此也是一种基于优先级的调度算法。

在每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比 RP, 然后选择其**值最大**的作业投入运行。

RP 值定义为：

>   RP＝（已等待时间＋要求运行时间）／要求运行时间＝1＋已等待时间／要求运行时间

此算法实际上是 SJF 和 FCFS 的折中。

**优点**：

等待时间相同，则 RP 值仅和要求运行时间有关，要求运行时间越短，RP 值越大，即相当于 SJF；

要求的服务时间相同，则 RP 值仅和已等待时间有关，等待时间越长，RP 值越大，即相当于 FCFS；

长作业的优先级随着等待时间的增加而提高，不会出现得不到响应的情况。

**缺点**:

作业调度程序要统计作业的等待时间，**作浮点运算（这是系统程序最忌讳的）浪费大量的计算时间。**

![image-20211221194238534](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211221194238534.png)

![image-20211221195129316](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211221195129316.png)

## 6.5 Multiple-Processor Scheduling （多处理器调度）

多个CPU可用时，CPU调度将更为复杂

**对称多处理器** – 每个处理器决定自己的调度方案。每个CPU自己到**公共就绪队列**去取进程来执行。这需保证多个CPU对公共就绪队列的**互斥访问**）

**非对称多处理器** – 仅一个处理器能处理系统数据结构（并分配给其他处理器执行），这就减轻了对数据的共享需求

当进程从一个 CPU 迁移到另外一个 CPU 时,其 CACHE 的内容也必须随之更新--代价很高

多数 SMP 系统不支持进程在不同 CPU 间迁移,而是试图使进程一直在同一个 CPU 上运行，这称为 Processor affinity(处理器亲和)

软亲和：尽量让进程在同一个 CPU 上运行

硬亲和：进程只能在同一 CPU 上运行，根本没法迁移

## 6.6 Real-Time Scheduling （实时调度）

实时调度是为了完成实时处理任务而分配计算机处理器的调度方法。通常是**基于优先级且是抢占式的**

> 因为需要实时处理发生的事件，实时进程的优先级必须最高，且能打断当前的进程

实时处理任务要求计算机在用户允许的时限范围内给出响应信号。

实时处理任务可分为：硬实时任务（hard real-time task）与软实时任务（soft real-time task）

**实现**：对 OS 的调度程序及其他相关方面提出了要求.**首先,系统要实现基于优先级的调度,实时进程须具有最高优先级,且不能随着时间的推移降低优先级; 其次,调度延迟必须很小.**

### 分派延迟 Dispatch Latency

为降低分派延迟，需要允许系统调用**被抢占**（否则实时任务来的时候遇到系统调用就只能等了）

> 一种方法是在长系统调用中比较安全的位置插入抢占点
>
> 另一种方法是使得整个内核可被抢占,但所有内核数据结构必须通过各种同步机制加以保护

如果较高优先级进程需读或修改正在被另一个低优先级进程所访问的内核数据，高优先级进程需要等待低优先级进程的完成。这种现象称为**优先级倒置**

> 如果低优先级进程由于优先级不够还经常被抢占 CPU，等待它的高优先级进程就要等好久好久。怎么办呢？引入「优先级进程」

**优先级继承**：(正在访问高优先级进程所需资源的)低优先级进程的优先级提升为高优先级进程相同优先级，直到相关资源处理完毕，它们的优先级再返回原来的值。

## 6.7 操作系统例子

绝大部分操作系统采用的调度算法都是基于优先级的抢占式调度

### Solaris 调度

采用优先级的进程调度，按调度的优先级定义了4类：实时、系统、分时、交互，对每一类有不同的优先级和调度算法

**默认的调度类是分时**。分时调度动态地改变线程的优先级，赋予不同的时间片长度（**多级反馈队列**）

分时和交互采用相同的调度策略,但**交互式线程有较高的优先级**

系统类的优先级是不会改变的,其调度策略是不分时的

实时类具有**最高**的优先级

四种类型各有一个优先级队列，调度程序需先将每个队列中的进程转换成全局优先级，然后选择全局优先级最高的线程运行。

### Windows XP 调度

- 基于优先级的，可抢占的调度算法
- 线程按时间片来使用 CPU（时间片分配给线程而非进程）
- 使用 32 个优先级来确定线程的执行顺序
- 优先级相同的线程按时间片轮转调度
- 非实时优先级是动态调整的
- 当线程从等待操作被唤醒时,提高其优先级（如I/O结束）
- 延长时间片:给前台任务更长的时间片,以提高响应速度
- **实时类进程（优先级 > 15）的优先级是固定不变的**

### Linux Schduling

Linux 也提供两种类型的进程调度算法：

- 分时类：基于优先级的抢占式调度
- 实时类：基于优先级的非抢占调度

优先级 0-99 是实时类进程，100 - 140 是分时类进程

Linux支持 SMP ,**每个CPU有自己的就绪队列,并各自独立进行调度.**

每个就绪队列包含两个子队列：

> Active（运行状态进程+就绪队列）:  contains all tasks with time remaining in their time slices 
>
> Expired（运行状态进程耗尽了时间片后进入此队列）: contains all expired tasks
>
> 两个队列的进程按照其优先级链接成一个链表，如下图左侧所示。

调度程序从 Active array 中选取优先级最高的进程使用CPU,当所有进程都用尽了自己的时间片,交换 Active array与expired array

![image-20211014144400258](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211014144400258.png)

## 6.8 Algorithm Evaluation （算法评估）

CPU 调度算法很多,如何选择适当的算法?

> 首先定义一个标准 (根据要实现的系统所追求的目标,如CPU利用率\系统吞吐量\平均周转时间\响应时间等)
>
> 然后根据标准来选择适当的算法
>
> 采用相应的模型来评价算法

**确定模型法、排队模型、仿真、实际运行**

