# 第十四章 指令级并行性和超标量处理

## KEY POINTS

1. 超标量的概念、特征，与超级流水线的区别

2. 超标量的并行性受到什么因素限制：五大相关性
3. 超标量的三种指令发射方式：按序发射按序完成；按序发射乱序完成；乱序发射乱序完成。
4. 超标量中用来提高性能的三种硬件技术：资源复制、乱序发射、寄存器重命名。

> 易俊泉学长的原始笔记链接如下：
>
> [chapter14 超标量](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter14超标量.md)

## 概述

超标量 superscalar 的方法本质为，**在不同的流水线中并行执行指令的能力，即允许指令能以不同于原来程序顺序的次序来执行**。属于指令集的并行。

> 之前提到过，分支预测的一种方法（多流水线）是取来转移目标和下一条指令一起执行，这是超标量吗？不是，因为这两条流水线并不具有完整、同时运行两条指令的能力。

> 超标量就是对标量指令处理的一种加速

超标量和流水线的区别：

- 流水线是对 CPU 组件的分时复用；CPU 只有一套运行流水线，但是每个时刻让每个元件都工作就可以加快速度。
- 超标量是空间上的复用：建立多条流水线，真正并行的运行多条指令。

![image-20211119114631200](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704532.png)

超标量计算机包含多条整数功能单元和浮点数功能单元，所有整数/浮点数单元都连接到一个整数/浮点数寄存器文件上。多个功能单元可以同时使用，加速了指令的执行步骤。

### 超标量的特征

:one: 多个指令在不同的流水线上并行执行

每一个流水线都有若干功能单元，都可以进行指令流水，完全意义上的并行。比如，每条流水线都必须有取指、译码组件，才能确保指令可以完全并行执行。

> 流水线中，各个部分的元件其实只有一份，通过让指令分时使用各个元件，把不用的元件分给其他指令使用，进行加速；
>
> 超标量需要每个部分的元件存在至少两个（比如两个取指部件、两个译码组件），才能保证多条流水线可以完全并行，互不干扰。

:two: 允许指令以不同于原程序顺序的次序来执行

### 超标量 superscalar 与超级流水线 super pipelining

多数流水阶段所完成的任务只需要比时钟周期一半还少的时间，于是把内部时钟速率加倍就可以**在一个外部时钟周期内完成两个任务。**这就是超级流水线的思想

> 超级流水线不是把每段流水线速度提升一倍，只是把流水线划分的更细致（每个拍短一半），利用流水线段数越多速度越快的特点进一步加速。
>
> 相当于把流水线的取指部分划分成「取指1」，「取指2」，让并行的粒度更细

**超级流水线**：把流水段划分的更细致些，每个段的执行时间只有半个时钟周期或者更少，它的一个段同步于外部一个的更快的时钟

**区别**

> 超标量是完全意义上的并行，物理上存在多条流水线，多条指令可同步执行
>
> 超级流水线是并发执行，物理上只有一条流水线，只是这条流水线性能更好，各个指令在处理时是部分交叠无法做到真正的同步
>
> 一般来说，超标量比超级流水线更好，更稳定。

![image-20211119115456639](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704536.png)

**度**：单个时钟周期内，流水线可以完成多少条指令。

上图对比了普通流水线，超级流水线和超标量技术执行指令的时间。可以看出，普通流水线的度为 1，超级流水线和超标量的度都为 2（一个周期内平均有两条指令完成）

现代处理器往往采用超级流水线+超标量技术，二者一起使用，可以让流水线速度提升到原先的 4 倍。

> 一般来讲，段数大于 10 的流水线自身的时钟周期都会快于外部时钟周期，常常是超级流水线

### 限制

如果我添加 1000 条流水线，流水线的度会到达原先的 1000 倍吗？

从理论上来讲，使用多少条流水线，速度就会变为多少倍；但是，这仅限于**指令之间完全不相关**的情况。现实中，不可能存在一串互不相关的指令，因此流水线的加速总是有上限的。

超标量方法依赖于并行执行多条指令的能力，指令级并行性（instruction level parallelism）指的是程序指令能并行执行的程度。

但并不是超标量中的流水线数目越多性能一定就越好，需要结合编译器优化和硬件技术

**受限因素**如下：

- 真实数据相关性

- 过程相关性

- 资源冲突

- 输出相关性

- 反相关性

> 部分受限因素在第十二章的流水线冲突部分就出现过

#### 1、真实数据相关性|True Data Dependency（写后读）

```C
ADD r1, r2 (r1 := r1+r2;)
MOVE r3,r1 (r3 := r1;)
```

第二条指令能取指并译码，但是在第一条指令执行完成之前不能被执行，因为第二条指令依赖于第一条指令产生的数据。

也称为「先写后读相关」和流相关性（在第十二章「数据冲突」部分提到过）

#### 2、过程相关性|Procedural Dependency

类似于十二章中的「控制冲突」

:one: 多条流水线中出现了转移

> 对普通流水线有影响
>
> 对于超标量来说由转移带来的损失甚至更大
>
> 因为为了防止页故障，不能提前取转移目标处的指令。

:two: 使用变长指令引起的相关

> 因为 CISC 机允许变长指令，任一个指令的具体长度不是事先已知的，需要部分译码后才能确定需要几次取指，这妨碍了超标量的同时取指
>
> 由于 RISC 的指令格式和长度相对固定，执行时间长短也差不多，**超标量更适合 RISC**

#### 3、资源冲突|Resource Conflict

两个或多个指令同时竞争同一资源

> 存储器\总线\功能单元，如：ALU中的加法器\Cache\寄存器

可通过增加多份一样的资源来克服，比如增加更多的 ALU 单元。

> 注意：资源冲突只会发生在独占设备上；多个指令访问存储器不会出现资源冲突，只可能因为访问相同的数据导致数据冲突（比如先写后读相关，先读后写相关和写写相关）

#### 4、输出相关性|Output dependency（写后写）

```c
I1: Add R6, R3 (R6 := R6 + R3;)
......
I4: Mov R6, R7 (R6 := R7;)
```

两条指令可以并行取指和译码

I1完成写回之前不能执行I4指令的写回步骤，否则结果会错误的变为 I1 的结果。

也称为写写相关

#### 5、反相关性|Antidependency（读后写）

```c
I1: ADD R3, R4 (R3 := R3 + R4;)

I2: MOV R4, R5 (R4 := R5;)
```

两条指令可以并行取指和译码

I1完成取操作数前之前不能执行I2指令的写回部分，否则 I1 会错误的读取到 I2 写入的数据。

也成为先读后写相关



- 过程相关性对应十二章中的控制冲突

- 真实数据相关性、输出相关性、反相关性对应十二章的数据冲突
- 资源冲突对应十二章中的资源冲突

过程相关性（转移）对流水线的伤害是最大的，因为为了防止页错误，流水线不能在得到是否转移前提前取转移目标的指令并执行。

> 在流水线中，先读后写和写写相关不太常见（主要是因为指令的写回在读操作数后），先写后读相关比较常见。
>
> 在超标量中，由于多个指令彻底乱序了，三种数据相关性都可能频繁出现。

## 设计考虑

### 指令级并行和机器级并行

指令级并行：指令序列中的指令是不相关的，可以同时执行

> 所有能使用流水线的机器都是指令级并行的

机器级并行：物理上存在多条流水线，可以同时取指、译码、执行……

如果一台机器是机器级并行的，它一定是指令级并行的；反之不一定。

### 指令发出策略

**instruction issue 指令发出**，是指启动指令去处理器功能单元执行的过程。

> 指令发出就是把要处理的指令塞给 CPU。这一点都不难，难点在于，在并行时，应该让 CPU 执行哪条指令才能让流水线最快？

实际上，指令发出就是处理器试图在当前执行点之前查找能进入流水线并执行的指令。

以下三种类型的排序是重要的：

> 取指令顺序
> 指令执行顺序
> 指令改变寄存器和存储器位置内容的顺序（写入操作数结果的顺序）

超标量指令发出策略有如下三种：按序发出、按序完成；按序发出、乱序完成；乱序发出、乱序完成。

> 乱序发出、按序完成实在实现不了，所以只有三种。

#### 1、按序发出，按序完成

严格的按顺序执行顺序发出指令，并以同样的顺序写结果

举例

> 图 14-4a 给出这种策略的一个例子。假定超标量流水线一次能取并译码两条指令，有三个分立的功能单元（如整数算术、浮点算术等)，有两个流水写回段的部件。例子是一个6条指令的代码片段，并假定有如下限制:
>
> > I1 执行要求两个执行周期。
> > I3 和 I4 为使用同一功能单元 c 而发生资源冲突。
> > I5 依赖于 I4 产生的值（先写后读相关）（因此 I4 必须在 I5 执行前完成写回）
> > I2、I5 和 I6 为使用同一功能单元 b 而发生资源冲突。
> >
> > ![image-20211227102157808](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704534.png)

![image-20211124103830314](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704535.png)

特点：指令是一次取两条并传送到译码单元，且两条指令必须一起写回。因为指令是成对取，所以下两条指令必须等待，直到译码流水段已完成上两条所取指令的译码。为保证按序完成，当有功能单元冲突或功能单元产生结果需要不止一个周期时，指令发射必须停止。

如果两条指令中任何一条因为冲突而停滞，那么另一条指令也需要等待（为了一起写回）。

在这个例子中，由译码第一条指令到写回最后结果总共花费的时间是8个时钟周期。

#### 2、按序发出，乱序完成

目的是要执行和输出尽可能快，指令发出因资源冲突、数据依赖关系或过程依赖关系而停止，需要更复杂的指令发出逻辑和中断控制

举例指令还是上面的几条。

![image-20211124110637411](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704537.png)

为了按序发出，第三拍时必须等待 I3、I4 全部发出才能译码 I5，不能让 I5 在第三拍就进入，这还是拖慢了一些速度。允许乱序发出指令就可以优化这部分时间。

#### 3、乱序发出，乱序完成

对于顺序发出，如果满足依赖关系，流水线将暂停，直到冲突解决。 **为实现乱序发射，将译码流水线与执行流水线解耦**，为此，需要一个缓冲区，称为**指令窗口**，可以存储所有已经译码的指令。窗口中任何指令都是已经解码的，可以直接发射。

在指令窗口没满时，可以不断的取指和译码，不需要担心流水线能不能容纳这么多指令执行。

当执行阶段中的功能单元变成可用时，需要此功能单元的指令就会由指令窗口发射到执行段。只要:one:**指令所需的具体功能单元是可用的,以及:two:其他指令和此指令没有冲突**,那任何指令都可以被发射。

![image-20211124105246408](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704538.png)

指令窗口并不是一个真实的流水段，由寄存器组成（而不是 cache），以满足速度要求。

实际上这是一种用一定的时间延迟（使用指令窗口导致的）来换取不相关指令被提前译码的方式

**作用**

- 通过这种方式可以减少流水线停滞的时间，一定程度上解决了真实数据相关（写后读）、资源冲突以及过程相关带来的问题，减少了流水段停滞发生的概率

- 无法解决输出相关性（写写相关）及读后写相关性的问题

### 寄存器重命名

```
R3:=R3 + Ra    (I1)
R4:=R3 + 1      (I2)
R3:=R5 + 1      (I3)
R7:=R3 + R4    (I4)
```

上面这个例子中，四条指令因为 R3 这个寄存器出现了一大堆的相关性问题。怎么解决这一问题呢？可以通过寄存器重命名：保证先写后读相关不变的情况下，复制一大堆 R3 寄存器，把对 R3 的写重定向到其他寄存器中

解决这些相关性的方法是基于传统的资源冲突解决方法：资源复制。现在的技术称为**寄存器重命名**——将不同指令使用的同名寄存器映射到不同的物理寄存器上去，一个逻辑寄存器映射到多个物理寄存器。

```
R3b:=R3a + R5a    (I1)
R4b:=R3b + 1      (I2)
R3c:=R5a + 1      (I3)
R7b:=R3c + R4b    (I4)
```

I1 写入的 R3 和 I2 读取的 R3 仍然必须是同一个，不然 I2 指令就会读取到错误的指令；

I3 写入的 R3 并不需要和 I2 读取的 R3 是同一个，因此把它们映射到两个不同的硬件寄存器，可以消除二者之间的资源相关性。

**不带下标（上面）的寄存器引用指的是指令中找到的逻辑寄存器**。带下标的寄存器引用指向被分配用来保存新值的硬件寄存器。当对一具体逻辑寄存器进行新的分配后，作为源操作数访问那个逻辑寄存器的后续指令要修改成对最近被分配的硬件寄存器的引用(最近是依据程序的指令顺序而定)。

用户并不知道写入时具体写入了 R3a, R3b 还是 R3c 寄存器；存储到哪个硬件寄存器完全对用户透明，用户不需要关心。

#### 相关性分析举例

**An Example**

> I1: LOAD R1, A
> I2: FADD R2, R1（浮点加法，我们认为只有一套浮点 ALU，因此多个浮点加法、多个浮点乘法是相互冲突的；浮点加法和浮点乘法间互不冲突）
> I3: FMUL R3, R4（浮点乘法）
> I4: FADD  R4, R5（浮点加法）
> I5: DEC   R6
> I6: FMUL  R6, R7（浮点乘法）

所有指令之间的相关性（冲突）如下：

> I1~I2: Write-read dependency
> I3~I4: read-write dependency
> I5~I6: write-read dependency, output dependency, read-write dependency
> I2~I4: functional unit dependency（ALU 只有一套浮点运算设施，存在资源冲突）
> I3~I6: functional unit dependency
>
> 若无特殊说明，一般认为浮点加乘运算会有资源冲突

输出相关（写写）和读后写相关可以通过寄存器重命名解决。

资源冲突和控制冲突可以一定程度上通过乱序发射/接受缓解。

### 超标量中提高性能的技术

提高性能的技术包含：**三种硬件技术**

> 资源复制、乱序发出（寄存器窗口）、寄存器重命名
>
> 目前的 CPU 一般是先利用寄存器重命名技术解决反相关、输出相关等问题，再乱序发出，这样可以发出的指令就会更多些

能在超标量处理器中提高性能的三种硬件技术：资源复制、乱序发出和重命名。

![image-20211124113322684](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704540.png)