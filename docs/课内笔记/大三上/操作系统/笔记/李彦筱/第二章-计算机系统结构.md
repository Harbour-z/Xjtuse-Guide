# 第二章 计算机系统结构

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/79012797bb974f2a998ebe0bf474f931.png)

> 易俊泉学长的原始笔记链接如下：
>
> [第二章-计算机系统结构](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第二章-计算机系统结构.md)

## 2.1 计算机系统操作

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/0fc01e66b64240999e16cdf78dacafe7.png)

- I/O 设备与 CPU 可并行运行

- 每一设备控制器负责一个设备类型（在后续的第十三章 I/O 系统中会详细介绍设备控制器）

  设备控制器：控制其他外设（硬盘，打印机，显示器）的控制器

- 每一设备控制器有一局部缓存

- CPU 通过局部缓存与主存交换数据

- I/O从设备到设备控制器的局部缓存

- 设备控制器通过引起<font color="red">*中断* </font>通知CPU操作已完成（因此，CPU 不需要持续轮询外设的状态）

### 中断机制

中断就是打断当前程序并把控制权交给操作系统的过程，能使系统更高效以及能提高系统的并发度，包括硬件中断与软件中断

:star: **硬件中断**：设备控制器利用中断通知CPU它已经完成了某个操作，属于外中断

:star: **软件中断**：也称为陷阱，包括系统调用(System call)，指令故障（缺页）

> 系统调用：调用系统的 API，比如 read、write 函数，os.system 函数这种
>
> 异常：CPU 当前执行指令出现问题引发的，注意和高级语言中的异常（比如 Java 的 Exception 类）不是一个概念

现代操作系统是中断驱动的，中断会将控制权转移到中断服务程序

> 中断服务程序也是操作系统的一部分，专门用于处理中断

中断也可以分为外中断和内部异常，外中断和内部异常的区别：

- 外中断是 CPU 当前执行的指令之外发生的事件引起的，比如打印机完成打印、某个 I/O 操作完成。某些中断是可屏蔽的，通过“关中断”，可以忽略部分中断。
- 异常是 CPU 当前执行的指令出现问题而引发的，比如缺页中断/当前指令引用了不存在的地址/运算溢出等问题。异常是无法屏蔽的。

一般我们所称的外中断 = 硬件中断；异常 = 软件中断。

软件中断中包含系统调用，而系统调用在异常/外中断的分类下属于异常，是一种“自陷”，即故意安排的异常，用于在用户态下调用操作系统内核指令。由于其分类为异常，系统调用也是无法屏蔽的。

外中断可以屏蔽，异常无法屏蔽。

**中断向量表与中断向量**

问题来了，现在我按下'y'键，触发了一个系统中断，那操作系统怎么找到处理这种中断的程序呢？答案是：使用中断向量表。

中断向量表是一张表格，存储了每一种中断应该调用的中断服务程序的地址。其中每一行内容称为中断向量。当触发中断时，操作系统查找中断向量表，找到可以处理此中断的中断服务程序的地址，并调用此服务程序。

> 将所有中断向量集中放在一起，形成中断向量表。8086系统有256个类型的中断源。每个类型对应一个中断向量,一个中断向量由四个字节组成：2个高地址字节：存放中断服务程序的代码段的段值；2个低地址字节：存放中断服务程序的偏移地址。中断向量表放在内存的低段地址0单元开始的单元:00000H~03FFFH。

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/16e047abc10648b8869595c1201c2c00.png)


### I/O 中断

两种 I/O 操作：同步与异步

> Synchronous 同步：当 I/O 操作开始时，系统会等待 I/O 操作结束才执行其他的操作
>
> 同步 I/O 只能同时执行一个 I/O 操作。I/O 操作完成后，可以立刻继续执行
>
> Asynchronous 异步：当 I/O 操作开始时，系统不会等待，而是直接去执行其他的操作
>
> 异步 I/O 可以同时执行多个 I/O 操作，但是需要回调函数等方法在 I/O 完成后通知程序，且程序需要对 I/O 操作返回顺序不同执行不同的操作。

I/O操作结束后，会触发一个中断通知系统
![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/179d5894c80740da9ce9f0865f0881e5.png)

> 可以看出，同步 I/O 操作中，程序会等到 I/O 结束，操作系统返回系统调用（即一直阻塞）
>
> 异步 I/O 操作中，程序发起的系统调用立刻返回，系统通过中断通知 I/O 操作的结束

基于中断的方法:

> **设备状态表**：包含每个I/O设备的条目，其中包括设备类型、地址和状态
>
> 每个I/O设备的**等待队列**（等待请求的列表)

### DMA 操作

像典型终端输入设备这样的低速设备，会把大部分 CPU 时间留给其他操作，因此，其通常会被分配一个低优先级的中断，允许其他更重要的中断先被处理。

高速 I/O 设备能够以接近内存速度传输信息，如果 CPU 需要对每个字节的中断都做出响应，它就没有多少时间来执行进程。

对于高速设备，用直接内存访问(Direct Memory Access)，设备控制器在本地缓冲和内存之间直接传输一整块数据而无需CPU干预，降低中断的频率，再也不需要一个字节就中断一次了（

## 2.2 存储结构层次

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/17a0bd1da7634c9887902b2c81819361.png)

从上到下，存储设备的存储空间依次增大，访问速度依次变慢，成本依次变低

**Speed 速度**

**cost 成本**

**volatility 易失性**：断电以后数据会消失，如内存易失，硬盘不易失

> 寄存器和缓存归编译器/硬件直接管理，不归操作系统管，所以下面直接从主存储器开始讲解

### 主存储器（Main Memory）

包括随机存取存储器(RAM)，是 CPU 可以直接访问的唯一大型存储介质（CPU 可以直接访问寄存器，cache 与主存，需要 I/O 设备的帮助才能访问外部设备和磁盘）

存储数据与指令

**缺点**：存储空间不够大（相比硬盘）以及具有易失性

### 二级存储（Secondary Storage）

二级存储，指的主要是磁盘，是主存的扩展

磁盘是覆盖了磁记录材料的硬金属或玻璃盘片；此外，光盘、U 盘，固态硬盘（NAND）等也是二级存储。

### Cache

缓存，暂时保存最近访问的数据，访问速度很快。

命中率：CPU 先访问 cache，没有相应的数据才去访问主存

> 没有cache的访问时间是100ms，有cache的访问时间为20ms，命中率为80%，平均需要：（100+20)x0.2+20x0.8=40ms，注意都要加上cache的访问时间

**缺点**：cache 的使用会造成数据的不一致，在多道程序、多处理机、分布式下。

这是因为，同一个数据 A 会随着 CPU 的读取，存在于硬盘、主存、cache 等多个位置。由于多个 CPU 具有单独的一级/二级缓存，因此不同 CPU cache 中的同一个数据可能不同。

主存可以看作二级存储的 cache。

## 2.3 硬件保护

在古老的单用户时代，程序员可以通过程序控制整个计算机系统。程序写错了，最多就是把计算机搞崩溃了。但在多用户环境下，编写错误的程序可能修改其他程序的内存甚至修改操作系统的内容，这显然是不可接受的。因此，多用户环境，需要保护磁盘上的文件、数据。

为了在程序出错时发现并终止程序，现代计算机实现了「两状态操作」。

### Dual-Mode Operation 两状态操作

程序可能在两个状态下执行：

:one: ***User** mode* – execution done on behalf of a user.**用户态**-代表用户执行

:two: ***Monitor** mode* (also *supervisor mode* or *system mode*) – execution done on behalf of operating system.  **管态**（特权模式或系统模式）-代表操作系统执行

**模式位**(mode bit)是计算机硬件中的一个比特标志位，表示当前模式

系统引导时，硬件处于管态，在用户模式下执行用户进程；**一开机的时候处于管态，要执行用户程序的时候转换为用户态**

### 两状态的切换

**当出现中断或者陷阱（即系统调用）时，硬件会切换到管态**
![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/e8d0b20ade1f43a2b04a0f1f1270b05b.png)


系统怎么知道程序当前执行的指令可能有错误，因此要转换为管态？——**引入特权指令**

特权指令：只能在管态下运行的指令，通常使用系统调用。一般可能引发硬件错误的指令都被划分为特权指令，比如直接访问寄存器、栈。

> 在用户态下，需要转换模态（通过系统调用，即发起一个软件中断）才能使用
>
> 在管态下直接使用即可

:star: 特权指令: 设置定时器的值、清除内存、关闭中断，写时钟，从管态切换为用户态

非特权指令：读时钟、从用户态切换为管态

### I/O Protection （I/O 保护）

**所有的I/O操作都是特权指令，用户不能直接进行I/O操作，必须通过系统调用**。确保了用户程序不能在管态下控制计算机

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/8d0cf38d64084aca91508afd12478e39.png)

要保护 I/O 操作，需要保护中断向量表与中断向量不被程序修改，由于它们是存储在内存中的， 所以必须进行内存保护

> 恶意程序可以让中断服务程序指向自己，这样当恶意程序发起系统调用，操作系统切换到管态后，就会在管态下调用恶意程序，实现提权。

### Memory Protection 内存保护

确定进程能访问的合法空间，使用基址寄存器与界限寄存器，即内存的开始地址与长度

基址寄存器确定一个程序所能使用的最低地址；界限寄存器保存程序所能使用的最大地址长度。

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/5acda20ccec04d3182198fc00a1aea51.png)

在程序访问内存时，CPU 检查程序访问的内存地址是否 >= 基址寄存器，是否 < 基址寄存器+界限寄存器。如果不满足，则发起一个异常，打断程序的执行。

基址寄存器和界限寄存器只能由操作系统通过使用特殊的**特权指令**加载，即只能在管态下进行。用户程序无法修改基址寄存器和界限寄存器，从而无法逃脱监管

在管态下执行时，操作系统对监视器和用户的内存都有无限制的访问

### CPU Protection

防止用户程序陷入死循环或者不调用系统服务且不将控制权返回到 OS；此时操作系统无法获得控制权。解决方法为：设置定时器 (Timer)

定时器：设置定时器在一段时间后产生中断，当时间到后会产生中断，控制权会返回给OS，可以用来实现分时系统

加载定时器也是特权指令，因此只有操作系统才能设置定时器并中断用户程序，用户态下无法关闭定时器中断。
