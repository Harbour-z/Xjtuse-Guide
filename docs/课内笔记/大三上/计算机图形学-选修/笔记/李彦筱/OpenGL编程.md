# OpenGL 编程

OpenGL 即 Open Graphics Library（开放式图形库），一个三维的计算机图形和模型库。

它是标准的跨平台 3D 图形接口，Windows，macOS 和 GNU/Linux 上都支持这种接口。

OpenGL 包含如下基本操作：

- 坐标变换：视图变换和模型变换
- 光照处理（光照系统）
- 着色（颜色上色）
- 反走样
- 颜色融合
- 雾化
- 纹理映射
- 动画

OpenGL 没有提供三维模型操作的高级命令，只是通过点、线和多边形建立 3D 模型。我们可以导入 obj/ply 格式的模型到 OpenGL 中，以便实现较好的动画效果。

## OpenGL 库文件

OpenGL 库（C++ 版本）主要包含三类文件：

- 头文件（glu.h）
- 静态链接库文件（glu32.lib）
- 动态链接库文件（glu.dll）

库包含六个部分：核心库，实用库，辅助库，工具库，Windows 专用库和 Win32 API 库。只有前四个是跨平台的。

核心库包含 OpenGL 的基本函数，其前缀为 `gl`。用于常规的、核心的图形处理

实用库的函数开头为 glu，其中的函数通过调用核心库的函数，实现一个较为复杂的组合操作，比如坐标变换，纹理映射。

工具库的函数开头为 glut，用于辅助创建窗口，提供基于窗口的工具。

辅助库函数开头为 aux，提供窗口管理和输入输出管理。

## OpenGL 基本语法

opengl 的函数名称有着固定的命名规则：前缀表示此函数属于哪个库（比如 gl 开头表示此函数属于核心库），后缀表示此函数接受多少参数，每个参数类型如何。比如：

`glVertex2i` 表示此函数属于核心库，功能为画一个顶点（Vertex），参数为两个 int 型。

OpenGL 是一个大型的状态机；即使用某些函数会改变 gl 的状态，这些改变会在同一个程序中一直生效。

## 点、直线和多边形

数学上的点没有大小，但计算机中为了显示点，必须让点具有一个像素的面积。

数学中的直线没有宽度，同样为了显示，计算机中的直线至少有一个像素的宽度。

OpenGL 要求多边形必须为凸多边形，不能为凹多边形。

glVertex 系列函数可以绘制顶点，根据后缀不同，接受的参数是不同的。

glBegin 和 glEnd 之间可以调用 glVertex 函数。OpenGL 会根据 glBegin 函数调用的模式位，决定这些顶点会形成什么内容。

比如：

```c++
glBegin(GL_LINES);
glVertex2i(-1, 0);
glVertex2i(1,0);
glVertex2i(0,1);
glVertex2i(0,-1);
glEnd();
```

会绘制一系列线段，其中第一条线段为（-1，0）到（1，0）的，第二条为（0，1）到（0，-1）的，两条线段之间没有关联。

`glLineStipple` 可以设置直线的样式，比如虚线，直线，波浪线……第一个参数为 factor，表示此函数生效范围为后多少个点；第二个参数为 pattern，指示直线的样式。pattern 和样式的对应如下：

![image-20241219093405929](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOFZ6R0S5HkHxJyAdb-k1XyakcsEaIAAu8UAAIHrilVcKzN-BdFWLQ2BA.png)

### 多边形

从三维的角度来看，一个多边形具有两个面

绘制方式：**填充**、边缘轮廓线、顶点

可为两个面分别设置不同的方式

glPolygonMode(GL_FRONT, GL_FILL);  

glPolygonMode(GL_BACK, GL_LINE);  

glPolygonMode(GL_FRONT_AND_BACK, GL_POINT); 

–**正面**：顶点以逆时针顺序出现在屏幕上的面

glFrontFace函数交换“正面”和“反面”

glFrontFace(GL_CCW); // 设置CCW（逆时针）方向为“正面”，CCW即CounterClockWise，逆时针

glFrontFace(GL_CW);  // 设置CW方向为“正面”

镂空多边形：



### 颜色

OpenCV 对颜色具有两种传递和显示方式：

- RGBA 颜色：
- 索引查询：可以提高效率

注意：glColor 函数可以传入 0-1 之间的任何浮点数（相当于把 0-255 规范化到 0-1 之后再传入），但这种颜色是否能够真正显示取决于显示器的色彩范围。

glColor：

glIndex：

glShadeModel 可以为颜色之间添加过度。设置 `glShadeModel(GL_SMOOTH)` 时，可以让绘制出的颜色之间平滑过渡，实现渐变色左右的效果。

## 坐标变换

要观察一个物体，我们可能想：

- 从不同的位置去观察它（视图变换）

- 移动或者旋转它，可以放大或缩小它（模型变换）

- 如果把物体画下来，可以选择：是否需要一种“近大远小”的透视效果。另外，可能只希望看到物体的一部分（剪裁）（投影变换）

- 希望把整个看到的图形画下来，但它只占据纸张的一部分，而不是全部（视口变换） 

每个视点都是 4x4 的矩阵表示的，这种矩阵既用于表示观察点的位移也用来表示物体本身的方向和位置，因此在修改一个之前我们需要先声明想要修改哪个：

`glMatrixMode(GL_MODELVIEW)` 可以声明我们想修改模型的旋转和平移，而不是观察点自身的。
`glTranslate`，`glScale`，`glRotate` 分别对一个物体做平移，缩放，旋转变化，其中旋转需要 3x3 的旋转矩阵，其他都只需要 1x3 的向量（分别表示对 x,y,z 的操作）

`gluLookAt` 需要三个参数表示观察点的位置，还有三个参数表示观察者认为的「上」方向，否则观察者和模型的相对关系不唯一。

视觉里就学过的概念：请注意先旋转再平移不等于先平移再旋转（假设平移的长度是固定的），因为旋转前后坐标系变了。一般采用先平移再旋转。

### 投影变换

投影变换：定义一个可视空间，可视空间以外的物体不会被绘制到屏幕上。OpenGL支持两种投影变换：透视投影和正投影。

透视投影：点光源投影（观察点为一个点），会出现近大远小的情况，需要指定观察视角，可视区域的长宽，最远/最近可视范围，得到一个圆台。

![image-20241224141123788](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOGZ6R0TZHlSP5pNiENV3Vq6aDEnDwAAvAUAAIHrilVnSrR6o04vH82BA.png)

正投影：定义一个长方体六条边边界的位置即可，不需要定义透视投影那么多东西。最后得到长方体

![image-20241224141110874](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOHZ6R0T1Fvu6IJh31UH5WDsDHK09YAAvEUAAIHrilVY5IjLQc1sck2BA.png)

视口变换：图像坐标系-相机坐标系的变换（2D-2D），给出视口的左下角位置

![image-20241224141225464](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOIZ6R0Um2NefRn62gkaNfnMvTYabwAAvIUAAIHrilVIHJk3XfOgZs2BA.png)

### 矩阵堆栈

`glPushMatrix` 和 `glPopMatrix` 函数可以暂存/取出矩阵到一个栈中。因为视角变换就是进行矩阵运算，可能需要暂存一些矩阵，OpenGL 提供了这些函数。

### 总结

OpenGL通过矩阵变换来把三维物体转变为二维图象，并在屏幕上显示

- 指定当前操作是何种矩阵（修改观察点还是模型）：使用 glMatrixMode

- 移动、旋转观察点或者移动、旋转物体

- 缩放物体 glScale（不常用，用的时候一般也会等比例缩放 x,y,z）

- 定义可视空间：正投影or透视投影  

- 定义绘制到窗口的范围 glViewPort（相机坐标系-图像的 2D-2D 变换）

- 引入矩阵“堆栈”，方便进行保存和恢复

## 计算机动画

电影和动画的工作原理： 快速的把看似连续的画面一幅幅的呈现在人们面前。

现实世界是连续的，但是游戏和动画只能一帧帧的播放单独图片。不过，由于视觉暂留效应，人会错误地认为一系列图片是连续的，最低只需要 24 帧就够了。

绘制动画时，需要每次循环时显示一张图片，等待一小会，再显示下一张图片。

如果用C语言伪代码来描述这一过程： 

```c
for(i=0; i<n; ++i)
{
   DrawScene(i);
   Wait();
} 
```

不过，这种代码会导致连着好几帧被吞掉，只显示出来最后的帧，因此实际不能这么写。

计算机上的动画与实际的动画有些不同： 实际的动画都是先画好了，播放的时候直接拿出来显示就行 

计算机动画则是画一张，就拿出来一张，再画下一张，再拿出来

当所需要绘制的图形很简单，那么这样也没什么问题，但当图形比较复杂，绘制需要的时间较长，问题就会变得突出。 如果需要绘制 50ms，那么无论如何帧率也超不过 20 帧，人看起来就不连续了。

> 具体问题：
>
> 把计算机想象成一个画图比较快的人，假如直接在屏幕上画图且图形比较复杂，则可能在只画了某幅图的一半时就被观众看到 ，后面虽把画补全了，但观众的眼睛却又没有反应过来，还停留在原来那个残缺的画面上。
>
> 观众有时看到完整的图象，有时却又只看到残缺的图象，这样就造成了屏幕的闪烁。
>
> 如何解决这一问题呢？ 可以使用双缓冲技术

### 双缓冲

设想有两块画板 ，画图的人在旁边画，画好以后把他手里的画板与挂在屏幕上的画板相交换，观众就不会看到残缺的画了 。

双缓冲技术：在存储器（很有可能是显存）中开辟两块区域，一块作为发送到显示器的数据，一块作为绘画的区域，在适当的时候交换它们。

这样，如果后台的画没有画完，只要暂缓交换缓冲区，就不会让用户看到残缺的画了（不过代价是用户会觉得很卡）。

由于交换两块内存区域实际上只需要交换两个指针，这一方法效率非常高，应用广泛，但虽然绝大多数平台都支持双缓冲技术，这一技术并不是OpenGL标准中的内容。

> OpenGL为了保证更好的可移植性，允许在实现时不使用双缓冲技术

启动双缓冲功能，最简单的办法就是使用GLUT工具包：glutInitDisplayMode (GLUT_ RGB| GLUT_SINGLE);

> 是的，GLUT 包不算严格遵守 OpenGL 标准的包

GLUT_SINGLE表示单缓冲，GLUT_DOUBLE就是双缓冲 

- 每次绘制完成时，需要交换两个缓冲区

  > 假如使用GLUT工具包，只要在绘制完成时简单的调用glutSwapBuffers函数 

很多时候，你并不能预先知道何时需要更新屏幕。比如，在多窗口系统下，当你的窗口被其他程序窗口挡住时， 就没必要绘制了；但其他程序窗口移开时，就必须再次开始绘制。用户程序无法知道窗口遮挡何时发生，就只能让操作系统通知了，因此使用 `glutDisplayFunc` 这种函数，在「操作系统认为适当」的时刻调用画图函数，而不是自己一直在画。

在CPU空闲的时间调用某一函数：可以使用 glutIdleFunc 函数，传入函数指针，OS 会在比较空闲的时候调用传入的函数，但不保证具体是什么时候。

### 垂直同步

如果计算机绘制简单的画面，则一秒钟可以绘制成千上万次；但要是如最大限度的利用计算机的处理能力，绘制很多幅画面，由于显示器的刷新频率不过，不仅会造成性能的浪费，还可能带来一些负面影响。

垂直同步技术：只有在显示器刷新时，才把绘制好的图像传输出去供显示。

> 计算机就不必去绘制大量的根本就用不到的图象了，如显示器的刷新率为 NHz，则计算机一秒钟只需要绘制 N 幅图象就足够，节约 CPU。

不过，垂直同步也会仅在图像绘制好整张时才显示，所以游戏帧率太低时开垂直同步会雪上加霜。

> 如刷新频率为60Hz， 如绘制一幅图画比较短，则为60FPS；如绘制一幅图画的时间1/50s，则为30FPS。如果每一幅图画的复杂程度是不一致的，会造成了帧速的跳动

设置垂直同步开关的 OpenGL 代码如下：

wglSwapIntervalEXT(1); //打开垂直同步，限制帧率

wglSwapIntervalEXT(0); //关闭垂直同步，充分发挥显卡的渲染能力

不过一般不需要手动修改，跟随用户的设置即可。

### 计算帧速

帧速：一秒钟内播放的画面数目（FPS） 

理论上，可测量绘制两幅画面之间时间*t*，取倒数即为帧速，但是 C 语言的 clock 等时间函数精度有限，因此可以采用计算多帧平均帧速的方法：

平均帧速测试：

测量绘制 N 幅画面（包括垂直同步等因素的等待时间）需要的时间，计算得到 FPS 的平均值 

## 光照

OpenGL 对于光照效果提供了直接的支持，调用某些函数即可简单的实现光照。

OpenGL 的光照系统分为三部分：

- 光源：发出光的物体的大小
- 材质：接受光照的物体的表面特征
- 光照环境

在真实感图形学中提到过，模型面片法向量可以用于计算光的反射方向。而 OpenGL 不会尝试自动计算物体表面的法向量，所以需要在模型中提供法向量、或者自己在程序中计算。

指定法向量的方法和设置颜色类似：只需要给出每个顶点的法向量，就可以计算出其相关面的法向量。修改函数为 `glNormal`

`glRotate`，`glTranslate` 函数不会导致法向量变化，但各个坐标轴缩放不同时，`glScale` 函数可能改变法向量，因此尽量少用。

### 控制光源

OpenGL 只支持 0-7 共计 8 个光源，且每个都预定义了一个符号，比如 `GL_LIGHT0`。使用 `glEnable` 可以开启一个光源。

> 光源越多，运算速度越慢

每个光源都可以通过 `glLight` 函数设置其属性。

GL_AMBIENT/GL_DIFFUSE/GL_SPECULAR 指定了光源本身颜色，漫反射后的颜色，镜面反射后的颜色。

GL_POSITION 记录光源所在的位置，x,y,z,w 记录，w=0 表示光源无限远，xyz 用于表示方向；w 不为 0 表示有限远，x/w, y/w, z/w 为光源实际的位置，因此一般取 w=1。

> 方向性光源（无限远光源）计算更快

### 控制材质

`glMaterial` 系列函数可以指定模型的属性，可以通过 `GL_BACK/GL_FRONT/GL_FRONT_AND_BACK` 决定指定正面还是反面还是全部的属性。

GL_SHINTINESS 为镜面指数，说明材质粗糙还是光滑的像镜面（越小越粗糙）

OpenGL 打开光照处理需要调用 `glEnable(GL_LIGNTING)`，别忘记了。

## 显示列表

之前演示的所有程序都是利用 glVertex, glCircle 等函数画出几个图形。但如果一个复杂（几千面）的模型全部使用 glVertex 画出来，那可能需要非常多的运算，导致速度变慢，有什么解决方法吗？

**显示列表**：编写程序时，如果需要反复调用一组函数，就创建一个显示列表，把函数装入，在需要时调用显示列表即可。

> 即显示列表中存放最常用的绘制函数

可以预先编译和解析反复调用的函数，缓存结果到显示系统内部，提高效率，适合每次刷新都需要进行较多绘制的程序。

步骤：

1. 分配显示列表编号（`glGenLists` 返回没有使用的编号，`glIsList` 判断某个编号是否已被占用）

2. 创建显示列表（`glNewList` 和 `glEndList` 函数之间调用的所有函数都在列表中）

   glNewList(int, flag) 第一个参数表示装入哪个显示列表，第二个 GL_COMPILE 为仅编译不执行，GL_COMPILE_AND_EXECUTE 为装入时编译并立刻执行一次。

   比如：

   ```c
   glNewList(list, GL_COMPILE);
   glColor3f(1.0f, 0.0f, 0.0f);
   glVertex2f(0.0f, 0.0f);
   glEndList();
   ```

   中，中间的 glColor 和 glVertex 被装入显示列表

   你自己的逻辑无法装入显示列表（因为你的逻辑执行时无法被 GL 感知），比如：

   ```c
   glNewList(list, GL_COMPILE);
   if (a > 0){
   glColor3f(1.0f, 0.0f, 0.0f);
   glVertex2f(0.0f, 0.0f);
   }
   glEndList();
   ```

   gl 会认为两条语句都在显示列表中，不会记录 a>0 的条件判断，执行时也不会做判断。

   （显然，你不调用 OpenGL 的库函数，只给个逻辑，它怎么知道这要装入，总不能直接读你的代码吧）

3. 调用显示列表（`glCallList`，参数为列表编号）

   可以使用 `glListBase` 让调用显示列表偏移，比如：

   ```c
   glListBase(10);
   glCallList(4);
   ```

   实际上调用了编号为 14 的列表，而不是 4。

4. 销毁显示列表：`glDeleteLists`

   两个参数：销毁的第一个列表编号，销毁长度。比如 `glDeleteLists(10, 4)` 会销毁 10，11，12，13 四个显示列表。

显示列表类似于手动定义的函数，适当使用可以提高性能（因为经过了预编译）。

## 混合

举例：通过红色的玻璃看绿色的物体。

定义：把某个像素原先的颜色和新绘制的颜色通过某种方法混在一起，实现半透明效果，先绘制远处的绿色物体，再绘制近处的红色玻璃并开启混合，即可实现真实的颜色。

开启和关闭：`glEnable(GL_BLEND)`

前提：**颜色模型为 RGB 且不是颜色索引模式**（必须直接给出颜色）

将要画上去的颜色为「源颜色」，已经在此点的颜色为「目标颜色」。

### 设置混合模式

`glBlendFunc` 可以设置混合模式，包含两个参数，都是一些标识位：

- 第一个参数 s：对于源颜色的使用方式
- 第二个参数 o：对于目标颜色的使用方式

可取指包含：GL_ZERO：不使用此颜色；GL_ONE：完全使用此颜色 GL_APLHA：根据 alpha 通道的值混合颜色。

### 三维混合

三维下需要「深度缓存」决定每个目标距离观察着的深度，如果要绘制的像素近于之前的就绘制，否则不绘制。

深度情况下，即使遮挡者是半透明的，也需要考虑遮挡关系，不能直接绘制后侧的内容。

每次绘制时，必须先绘制不透明物体、再设置深度缓冲区为只读，然后再绘制半透明物体，最后设置深度缓冲区为可读写。

> 1. 绘制所有不透明
> 2. 设置深度缓冲区只读（glDepthMask(GL_FALSE)）
> 3. 绘制所有半透明物体
> 4. 设置深度缓冲区为可读写

## 像素操作

- 矢量图：系统存储每个几何物体的位置，放大缩小时重新计算，不会失真
- 像素图：图像由一系列像素组成，一大堆像素组成了整个图像，放大就会糊（因为信息有限）

BMP 文件用于存储位图，可以包含图片每个像素的值，可以存储 256 色的单色图片或者 24 位真彩色

Windows 所使用的的 BMP 文件存储了 54 字节文件头，其中包含图像的宽度和高度（32 位整数），因此打开图片时可以直接得知其大小。宽度位于 0x0012H（十六进制），高度位于 0x0016H。（十六进制）

图像的真实信息从 54（十进制）位置开始。

注意：BMP 文件存储采用 BGR 格式（学 OpenCV 导致的），

BMP 总空间：每行的宽度 * 每个像素需要多少空间 * 存在多少行。

### ReadPixel

glReadPixel：把已经绘制的内容（通常在显存中）读取到内存里

glDrawPixel：把内存的数据输出到显存中

glWritePixel：把一块绘制好的内容拷贝到另一个区域，且不需要经过内存。

`glReadPixel` 包含七个参数，其定义为：

- 左下角坐标（两个参数）
- 宽度和高度（两个参数）
- 读取方式（比如只读取单通道还是全部通道？）
- 保存到内存中的格式（GL_UNSIGNED_BYTE, GL_FLOAT，对应 CV_8UC1/CV_32FC1）

注意：此函数在存在双缓冲区时，默认从前缓冲区中读取；`glWritePixel` 绘制时，默认绘制到后缓冲功能区，因此记得交换两个缓冲区。

解决典中典的 BGR/RGB 顺序的方法：

- 手动交换两个通道
- 用 GL_BGR 参数读取 BGR 文件，GL_RGB 读取 RGB 文件

（我真不知道为什么 Windows BMP 和 OpenCV 都这么喜欢默认 BGR）

`glAlignmentPixel` 可以设置像素的对齐方式

可以使用 glReadBuffer 和 glWritePixel 等函数实现截图（截取当前显示的图片）

`glDrawPixel`：前四个参数对应宽度、高度、像素数据格式、像素数据在内存的格式（即 ReadPixel 的 3-6 个参数），第五个参数表示输入位置（要绘制的内容）的指针。

此函数不直接指定绘制的位置，绘制的位置可以通过 `glRasterPos`系列函数更改。

> `glRasterPos`：两个参数，指定复制目标位置起点的 x,y 坐标

`glCopyPixel`：直接从显存中复制一部分像素数据，生成新的像素数据，而不经过内存。五个参数为：

- 复制矩阵的左下角（x,y）
- 宽度和高度（w, h）
- 待复制数据的格式（GL_COLOR, GL_DEPTH, GL_BGR 等颜色格式）

> 在复制前，有时需要通过 `glReadBuffer` 函数先复制后缓冲区的内容，不然默认复制前缓冲区的内容可能导致复制了块空内容）。

`glPixelZoom` 函数可以缩放复制的区域的大小



## 纹理

开启纹理功能需要 `glEnable(GL_TEXTURE_2D)`，默认是不开启的。

载入纹理使用 `glTexture2D`

参数 4-5：载入纹理的宽度和高度

参数 6:边框的大小（一般不用）

参数 7，8，9：内容（GL_BGR），类型（GL_UNSIGNED_BYTE）和地址指针

`glShadeMode` 可以设置纹理使用渐变还是默认，如果设为渐变，OpenGL 会在纹理的合适位置选择颜色并渐变的填充物体。

纹理的高度最好是 $2^n$，如果不满足可以用 `gluScaleImage` 在使用前缩放纹理。

纹理通常很大，因此载入非常慢。如果使用多个纹理时，每次使用时才载入纹理，使用完成后丢弃，就需要花费很长的时间，有没有什么方法可以把所有纹理预先读取，在使用时通过序号指定哪个纹理呢？

`glGenTexture` 可以分配一个纹理对象编号（像 `glGenList` 一样）

`glBindTexture` 可以把图片绑定到某个纹理对象，包含两个参数：一个`GL_TEXTURE_2D` 对象，一个编号（说明绑定到哪个对象上）。

