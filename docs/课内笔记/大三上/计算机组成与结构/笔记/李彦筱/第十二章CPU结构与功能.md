# 第十二章 CPU结构和功能

## KEY POINTS

1. 处理器内部结构，了解就行

2. 寄存器分类：用户可见和控制状态寄存器，通用寄存器能存什么,数据和地址寄存器是否区分，长度如何确定，条件代码用来干什么，存在哪里

3. 指令周期，包括哪几个部分，子周期关系，前后关系，哪些必须，哪些可能

4. 流水线

> 为什么要采用流水线，流水策略有哪些，分段，:star: 指令流水操作时序图
>
> 哪些因素影响流水线性能、流水线性能衡量标准：加速比与吞吐量

5. **指令流水线处理条件转移指令的五种方式**

>易俊泉学长的原始笔记链接如下：
>
>[chapter12 CPU 结构和功能](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter12CPU结构和功能.md)

## CPU 组成

CPU 由如下部分组成：ALU，CU，寄存器。其中，CU 是最复杂的。

第九章中提到了 ALU，这里我们来了解一下寄存器。

CPU 的主要功能就是执行指令，而执行指令需要如下步骤：

- 取指令

- 解释指令（译码）

- 取数据

- 处理数据

- 写回数据

为了完成处理数据和解释指令，CPU 必须包括 ALU 和 CU。为了统一 ALU 这个组合逻辑电路和其他时序逻辑电路的矛盾，CPU 需要临时存储一些数据，包括 ALU 处理的数据或者下一条指令的位置。因此，CPU 需要一个小的内部内存——寄存器

![image-20211110112906449](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704513.png)

上图描述了 ALU 和寄存器的联系。ALU 是组合逻辑电路，其计算出的结果暂时存储到寄存器中。

CU 和 ALU、寄存器间都存在连接。

## 寄存器组织

寄存器：CPU 中用于暂存的一小块工作空间（I/O中也有）

是 CPU 设计需要考虑的一个重要因素。寄存器的数目和功能取决于 CPU 其他部分的设计

寄存器位于存储金字塔的顶端（最贵，访问速度最快，容量最小）

:one: 用户可见寄存器 User-visible registers

> 允许**机器语言或汇编语言**的编程人员通过优化寄存器的使用，减少对主存的访问。
>
> Java 和 C++ 这种高级语言是无法直接接触的；在编译器支持下，说不定可以访问

 :two: 控制和状态寄存器 Control and status registers

 > 由控制器来控制 CPU 的操作，或由拥有特权的操作系统来控制程序的执行
 >
 > 不面向普通的程序员开放

### 用户可见寄存器

根据存储内容，可以分为四种：通用目的寄存器，数据寄存器，地址寄存器，条件码寄存器

**通用目的寄存器 general purpose register**

也许真的是通用的，也可能是受限制的

可能有用于浮点和堆栈操作的专用寄存器

可用于数据或寻址

**数据寄存器**

累加器

**地址寄存器**

段指针、栈指针

**条件码寄存器**

由CPU硬件设置的位，作为最后一次操作的结果

COAPZS

> 正，负，零，溢出，等等，

在存储最后一个操作的结果之后，还会设置一个条件代码，这个代码可以用于条件分支

可以被程序隐式地读取、通常不能被程序设置

对程序员部分可见

**采用更多的通用寄存器/专用寄存器?**

> :one: 采用更多的通用寄存器
>
> > 增加灵活性，给程序员提供了更大的自由，寻址方式也可以更丰富
> >
> > 增加指令的长度和复杂度
>
> :two: 采用更多地专用寄存器
>
> > 更短的指令
> >
> > 灵活性变差
>
> 更多通用寄存器会让指令变长，大概是因为寄存器多的话需要更多的位做编码，会导致指令中的地址码部分更长。

### 控制和状态寄存器

**程序寄存器 PC**：存有待取指令的地址

**指令寄存器 IR**：存有最近取来的指令

**存储器地址寄存器 MAR**：存有将要读取/写入的存储器的地址

**存储缓冲寄存器 MBR**：存有将被写入存储器的数据字或最近被存储器读出的字（内容）

很多 CPU 设计都包括**程序状态字 PSW**。

程序状态字是一个或一组寄存器，一般包含条件码寄存器和其他状态信息。大多对程序员不可见，可能包含如下内容：

> 符号sign
>
> 进位carry
>
> 等于equal
>
> 溢出overflow
>
> 中断允许\禁止（中断使能）
>
> 监管位 supervisor（CPU 处在监管模式还是用户模式）

子程序调用，不需要保存现场，就是一段代码的替换

**设计控制寄存器时要考虑两个因素**

:one: 操作系统支持

> CPU 设计与操作系统设计是紧密联系在一起的，二者应该相互配合

:two: 控制信息分配在内存和寄存器

> 控制信息也可以存储在主存的前几百个字中，设计者必须决定有多少在寄存器中，有多少在内存中

### 微处理器寄存器举例

![image-20211226205539906](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704507.png)

## 指令周期

指令周期：执行一条指令所需要花费的时间。

一般分为两个子周期：取指周期和执行周期。各条指令在取指周期花费的时间差不多，因此主要时间差来源于执行周期。

在考虑中断时，这两个子周期后还有一个中断周期：CPU 在此时检查是否发生中断，如果有，就暂停当前进程的执行，引导 PC 指向中断服务程序的首地址。中断周期结束后，CPU 就开始执行中断服务程序了。

在考虑间接寻址给出的操作数时，需要在执行周期前增加一个「间址周期」。在这个周期中，CPU 访问地址码给出的地址，从中实际拿到操作数的地址，为执行周期做准备。

指令周期和机器周期没有必然联系。

> 取指周期和执行周期是必须的，无论何时都存在的。
>
> 间址周期和中断周期是可选的。当采用间接寻址/偏移寻址等无法直接得到有效地址的寻址方式时，才会出现间址周期；当中断发生且 CPU 开中断（允许接受中断）时，才会出现中断周期。

![image-20211110115010089](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704515.png)

### 间接寻址周期

可能需要内存访问才能获取操作 

间接处理需要更多的内存访问 

可视为附加指令子周期

![image-20211110115400739](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704516.png)

![image-20211110115452013](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704517.png)

一旦取来一个指令，它的操作数指定符必须被识别，然后读取存储器中的每个操作数，**这个过程可能要求间接寻址**。寄存器操作数不需要从存储器读取，一旦操作完成，可能需要一个类似的过程将结果存入主存。

### 数据流

假定一个 CPU 中有一个 MAR、一个 MBR、一个 PC、一个 IR

#### 取指周期

在取指周期开始时，PC存有待取的下一条指令的地址

1. PC 地址被送到 MAR
2. 地址放在地址总线中，控制器发出一个存储器读的请求，存储器根据地址读取到下一条指令的内容
3. 存储器将读取结果放在数据总线中，CPU 将其复制到 MBR，然后传送到 IR

同时，PC+1（可以认为 PC+1 是在取指周期完成后进行的）

> ![image-20211110115853266](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704519.png)

#### 间接周期

一旦经历取指周期，检查器检查 IR 的内容，确定是否有操作数使用间接寻址，若是则进入间接周期，如果不是则直接进入执行周期。

间接周期中，仅仅得到操作数的有效地址，不会直接把操作数从有效地址里取出来（这是执行周期干的事）

1. MBR 最右边的 N 位是一个地址引用（操作数地址的地址），被送入 MAR

2. 控制器发一个存储器读，得到操作数的真实地址，送入 MBR

3. 可以选择把 MBR 得到的有效地址更新到 IR 中。

> ![image-20211226210853282](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704508.png)

#### 执行周期

没有固定地形式，取决于实际执行的指令

#### 中断周期

目的：把 PC 更新到中断服务例程的首地址，并保存当前的现场

由于过程是一定的，中断周期所需的操作可以预测。

1. PC 的当前的内容被保存，以便在中断之后 CPU 能恢复先前的动作

   具体步骤：PC 的内容被送到 MBR，并写入存储器

   一个专门的存储器位置被控制器装入 MAR，以保存 PC（可能是一个栈指针）

2. 中断子程序的首地址装入 PC，因此下一个待获取指令成为中断处理程序的第一个指令

> ![image-20211112102111756](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704520.png)

## 指令流水线（重点）

### 指令预取

在前一条指令执行时，我们先把后一条指令取过来，称为指令预取。

可以将指令处理分为两个阶段：取指令和执行指令。在指令执行过程中，主存可能没有存取操作，可以在解码和执行当前指令时获取下一个指令。

![image-20211112102552622](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704509.png)

这种方式需要指令缓存，需要更多的寄存器

![image-20211112102941718](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704521.png)

通过上图，我们可以看出指令预取可以提高指令执行速度。

由于需要寄存器存取预取来的指令，执行单条指令的执行时间可能增加；但执行多条指令的速度更快。

预取可以提速，但是速度不会翻一番：

1. 预取最多只能省下所有指令的取指周期时间，但取指周期不一定占整个指令执行时间的一半

2. 若指令之间有关系（存在跳转或转移指令），会造成无效缓存以及速度降低

### 指令流水线 instruction pipelining

流水线来源于类似工厂流水线的思想；指令的执行实际上有多个阶段，这些任务按顺序执行。我们将一个指令周期分为如下六段，不同指令的不同段可以在同一时刻进行。

> 处理相关任务时，资源能错开使用，不均等分段会降低流水线的效率

下面给出每个阶段时，同时给出其英文全称，方便记忆英文简写。

1. 取指令 FI（Fetch Instruction）：从 cache 中读下一条指令

2. 译码指令 DI(Deocde Instruction）：译码

3. 计算操作数 CO(Calculate Operand)：计算每个源操作数的有效地址，涉及偏移寻址、寄存器间接寻址等

4. 取操作数 FO(Fetch Operand)：从存储器中取出操作数，寄存器中的数不需要取

5. 执行指令 EI(Execute Instruction)：执行指定的操作

6. 写操作数 WO(Write Operand)：把结果保存到内存

六段内容花费的时间应当接近，这样进行流水线操作时，才不会因为某段执行太慢耽误流水线速度。

下图是流水线操作的时序图，**非常重要**。横轴每格代表*一拍*，表示一段指令执行所花费的时间。

时间每经过一拍，正在执行的指令就进入下一段操作。

![image-20211112104443134](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704522.png)

引入流水线后，9 条指令只需要花费 14 拍执行；而之前 9 条指令需要 9*6=54 拍执行，提升将近达到了 54/14 = 3.85 倍。

> 流水线执行指令花费的时间：第一条指令花费 6 拍（因为总共 6 拍），剩下的指令每条都只多花费一拍。
>
> 即如果流水线分为 n 拍，存在 m 条指令，则一共需要 n + (m-1) 拍执行完所有的指令

> 如果同时执行 900 条指令，提升达到 900*6 / (6+899)=5.96 倍。不过这只是梦里才有的理想情况，实际上由于指令的相互依赖，速度不会有这么快。
>
> 而且，有些指令可能并不需要在六个流水段都执行操作才能完成。比如，转移指令只需要更改 PC 寄存器的值，显然不需要写回更改后的操作数。
>
> 即使某些指令不需要六个流水段，也需要走一次对应的段消磨时间，不能跳过某个指令的某个执行阶段。

实际运行中，指令之间肯定会有依赖，条件转移也会降低速度。

> C 语言中的 goto 是无条件转移、for 循环是条件转移

![image-20211112105633163](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704524.png)

无条件转移指令在**译码阶段（DI）**就知道是否要转移。有条件转移在**执行阶段（EI）**才知道转还是不转

上图中，假设指令 3 是一个条件转移指令，目标为指令 15。在第七拍（指令 3 执行阶段），CPU 发现指令 3 需要转移，因此要清除 4-6 三条指令在前四个阶段中留下的寄存器值等痕迹，转移到指令 15，再重启流水线。

之前 14 拍可以运行 9 条指令，出现一次有条件转移指令，就只能执行 5 条指令了，减速了很多。

> 无条件转移在译码阶段就知道需要转移，因此译码完成后（第三个阶段，计算操作数时）就可以预先取转移目标指令进入流水线了，比有条件转移对流水线的伤害更小，但还是有伤害。
>
> CPU 发现指令需要转移后，需要清除当前流水线的缓存内容，但可以**立刻**从缓存目标处重启流水线，**不需要**等待转移指令执行结束再重启。

满载：流水线的每个阶段都有指令在执行的状态称为满载状态。这种状态下的流水线执行效率最高。

- 流水线阶段划分增多会让处理速度更快吗？

  未必，因为划分的阶段越多，每次由于条件转移指令损失的阶段越多，减速越多；此外，更多阶段需要更多的控制电路支持，导致电路过于复杂。

### 流水线性能

指令流水线的周期$\tau$，是在流水线中**将一组指令推进一段所需的时间**，表示公式如下（<mark>掌握定义</mark>）：
$$
\tau=max_i[\tau_i]+d=\tau_m+d\qquad 1\le i\le k
$$
其中：

> $\tau_i=流水线第i段的电路延迟时间$
>
> $\tau_m=最大段延迟$
>
> $k=指令流水段数$
>
> $d=锁存延时$

CPU 的时钟周期长度 = 流水线的周期长度。其中，$\tau_m$ 取所有流水线步骤中，花费时间最长的那个就可以。

假设现有 n 条指令在进行，无转移发生，令 $T_{k,n}$ 为 k 阶段流水线执行所有 n 条指令所需的总时间，则有:

（即第一条指令花费 k 个周期完成，后面每条指令在前一条指令结束后的一个周期内完成，因此 +(n-1)）

> 总共需要 k+n-1 个周期完成执行，每个周期时间为 $\tau$

$$
T_{k,n}=[k+(n-1)]\tau
$$
提速比：nkt 是使用流水线前，指令执行的所需时间（nk 为阶段数量，t 为每个阶段的时间）

> 请掌握定义而不是死记硬背公式，因为下方公式只适用于满载状态，如果因为条件转移指令导致减速就不能这么算了。

$$
s_k=\frac{nk\tau}{[k+(n-1)]\tau}=\frac{nk}{k+(n-1)}
$$
吞吐率$T_p$：**流水线单位时间内完成的指令数（注意不是阶段数）**（<mark>掌握定义</mark>）
$$
T_p=\frac{n}{[k+(n-1)]\tau}
$$

满载指令：Tpmax，流水线满载状态下，单位时间完成指令的条数。

满载状态下，流水线每个周期都有一条指令完成，因此每 $n\tau$ 时间完成 n 条指令，因此完成一条指令所需时间为 $\tau$，单位时间完成指令数量为 $\dfrac{1}{\tau}$。
$$
T_{pmax}=\frac{1}{\tau}
$$

$n>>k，T_p\thickapprox T_{pmax}$

> 在满载状态下，平均 CPU 每个时钟周期都可以完成一条指令

#### 举例

考虑一个时钟周期为50ns的单流水线处理器有5个流水线阶段:FI、DI、FO、EX和WB（少了计算操作数地址的阶段）。假设每个阶段的持续时间相等，需要2个时钟周期。它需要执行8个连续指令。

绘制流水线各功能阶段时序图，计算提速和吞吐量。假设在执行指令期间没有冲突、依赖或分支。

如果指令4是一个条件转移指令，并且转移的目标是指令7。在此执行中，结果是进行分支。绘制流水线各功能阶段时序图，计算提速和吞吐量。假设在指令8之后，没有其他指令要执行。

![image-20220220180233871](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704511.png)

注意：**被转移指令跳过的指令不算被执行过**（因为没有完全完成）

### 流水线冲突 pipeline hazard

流水线冲突是指，因为某些条件不允许流水线运行，而必须停顿，也称为流水线气泡 pipeline bubble

> 这是因为停顿就像是流水线中出现了气泡，占用了某个处理位置，让流水线没发进行下去了

上面看到的条件转移指令就会导致流水线冲突。

根据不同冲突原因，可以把流水线冲突分为三种类型：

#### 资源冲突（结构冲突）resource hazard

发生在两条（或多条）已进入流水线的指令需要使用相同资源的时候（比如都想要访问同一个 cache 位）

指令在访问相关资源时，必须按照串行顺序执行，不能使用流水线并行进行了。这也会影响其他不使用此资源的指令，导致流水线无法做到一个时拍完成一条指令了。

![image-20211226232412316](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704512.png)

上图中，假设计算机从内存读指令、读操作数、写操作数是无法同时执行的。假设指令 11 的操作数在内存中（其他指令操作数都在寄存器中），所有指令都在内存中，那么 11 在第三拍读取操作数时，指令 13 就无法同时访问内存取指，因此需要停顿一拍。

#### 数据冲突 data hazard

数据冲突发生在对一个操作数位置的访问出现冲突的时候。比如，一条指令想写一个操作数，而另一条想读取这个操作数，二者就会产生冲突。

> 程序中的两条指令是依次执行，并且都将访问同一个内存或者寄存器操作数。如果这两条指令是严格执行的，那么没问题发生。如果在流水线中运行，可能会使操作数不按次序更新，从而产生不正确的结果

举例：

> ![image-20211112115032253](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704525.png)

> 第一条指令是 2 地址指令，将 EAX 和 EBX 相加，结果放入 EAX。而第二条指令运算需要取 EAX 作为操作数，因此第二条指令的取操作数（FO）必须在第一条指令的写回结果（WO）之后进行，导致流水线全部延迟两拍。
>
> 这是一种写后读冲突。

解决方式：流水线气泡。等待上一条指令完成写入，在此之前一直等待，什么都不做。

常见的三种问题：读后写，写后读，同时写。（同时读取不会出现问题）

写后读（RAW）：

一条指令更新了某个寄存器/内存的值，而后续指令需要读取这个值。如果后续指令在前一指令的写回阶段完成前就进行了取操作数，会导致取脏数据（不对的数据），因此后续指令在取操作数步骤前必须停顿，直到之前的指令完成了写操作数的步骤。

读后写（WAR）：

一条指令读一个寄存器或内存位置，而后续的指令将改写该寄存器或内存位置的内容。如果在读操作完成之前，写操作就开始进行，会导致写先于读，读取指令错误的拿到被更新的数据。

> 这个一般不太可能发生，毕竟 FO（读操作数）在周期中先于 WO（写回结果），一般流水的情况下，前一指令的读步骤往往在后一指令的写步骤前好几拍。

写后写（WAW）：

两条指令要改写同 一个寄存器或内存位置。如果这两条指令的写操作发生次序与期望的次序相反，那么就会发生冲突（写入结果错误）。



#### 控制冲突 control hazard

流水线对转移指令预测错误时，就会出现控制冲突。

> 这里的转移指令是指有条件转移指令；无条件转移指令是必定转移的，也就没啥可预测的。

条件转移指令只有两种去向：要么转移，要么不转移。如果流水线预测需要转移，但是其实不需要转移，已经进入流水线处理的后续部分指令就必须被丢弃。反之同理。

转移预测错误导致的主要问题并不是流水线延迟，而是预测错误时可能错误的访问了内存或者外存。

处理转移预测错误的五大方法：

- 多指令流
- 预取转移目标
- 循环缓冲
- 转移预测
- 延迟转移

完全消除转移的损失基本是不可能的。不过，我们可以尽可能降低转移带来的伤害。

**多指令流**

保留两条指令流水线，第二条流水线仅仅在遇到分支语句时启动，把每个转移目标放到一个流水线中执行，这样就可以并行执行两个转移目标的语句。

优点：优化了速度，转移后不用重新执行指令

缺点：转移指令的两个目标位置的指令可能访问同一资源，导致访问冲突；流水线的硬件设施贵

一般多流只用两条流水线，如果预执行转移语句时再遇到转移指令，就采用其他处理方法。

**预取转移目标**

前面提到，预测错误时最怕的是错误的访问了内存或者外存，因为访存花费的时间非常长。预取转移目标就是在译码一条指令，得知它是转移指令后，先把转移指令目标位置的指令预取来，放到寄存器中。

> 只预先取指令，不会对指令译码和取操作数，因为取操作数可能引发缺页中断

如果真的转移了，寄存器中指令可以节约取指时间；如果没转移，把指令清空即可。

> 使用较少，因为节约的时间很少

**循环缓冲**

增加一个小的缓冲区，存放最近访问到的 n 条机器指令。

> 这个缓冲区在物理上由 cache 构成（SRAM）

如果发生了转移，CPU 在访存寻找指令前，先在缓冲区中搜索指令。

**转移预测**

在遇到条件转移指令，在转移前，先预测最可能进入的分支。

- 预测转移永不发生

  猜测条件转移指令永远不会转移，总是取下一条要执行的指令，而不是取转移目标的指令

  如果取下一条指令会触发页故障（缺页），则暂停执行，直到条件转移指令执行完毕，得到是否要转移的信息，防止无效的访问外存

- 预测转移一定发生

  猜测条件转移指令永远都会跳转，总是取转移目标的指令，而不是下一条指令

  如果取下一条指令会触发页故障（缺页），则暂停执行，直到条件转移指令执行完毕，得到是否要转移的信息，防止无效的访问外存

  前两种预测方法和什么都不做的区别在于：它们在可能引发页中断时会停止预取。什么都不做的话，指令会按照不转移继续流水，可能引发页中断；废了 $10^6$ns 级别的时间读取到页之后，发现其实是转移的，那就白白浪费一个页中断的时间。以上两种方法不会出现此情况。

- 依据操作码预测

  有些指令会大概率引发跳转，对这种指令就认为它一定会跳转（比如调用函数，函数返回）；有的指令只有小概率引发跳转，这些指令就认为永不会跳转。

  如果取当前预测结果处指令会引发页故障，就暂停执行，直到条件转移指令执行完毕，得到是否要转移。

  这种情况下，猜对的概率会达到 75% 以上

- 转移-不转移切换

  根据之前执行转移指令时，转移的多还是不转移的多，对下一次转移指令做预判。

- 根据转移历史表预测

  建立一个 cache（称为转移历史表，BTB/BHT），每个表项包含三部分：

  - 转移指令的逻辑地址
  - 转移目标的逻辑地址
  - 转移历史信息（此指令是否转移了）

  根据记录的信息，决定是否转移。具体算法如下：

  ![image-20241106104852816](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAM-Z6F5PaU2TEYZbhhHBfzHX12aBy0AAqMSAAK0lBBVyKmfzUzUi102BA.png)

  猜错两次才转向：不管目前预测转移发生还是不发生，都只会在现实结果和预测结果错误两次后再更改预测结果。

前三种转移方式称为静态转移，后两种称为动态转移，因为后两种会根据之前执行的转移语句决定当前是否转移。

**延迟转移**

插入 NULL 操作占据时拍，不让流水线提前执行，访问内存或者外存。相当于什么都没做，浪费了时间，因此现在更常让编译器重新排序指令。

RISC 机采用这种方案。
