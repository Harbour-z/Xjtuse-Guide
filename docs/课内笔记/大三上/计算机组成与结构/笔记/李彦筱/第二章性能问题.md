# 性能问题

> 此部分和「计算机演变」部分在书上都属于第二章，不过老师在授课时分为两部分讲解。
>
> 易俊泉学长的原始笔记链接如下：
>
> [chapter02 计算机演变与性能](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter02计算机演变与性能.md)

## KEY POINTS

1. CPU 和主存的接口是最关键的路径
2. 性能评估相关公式，CPI, $I_c$，MIPS 等概念
3. Amdahl 定律



## Designing for Performance

### Microprocessor speed（微处理器速度）

目前，处理器的速度已经非常快，以至于执行一条指令花费的时间可能快于读取指令的时间。因此，除非持续以计算机指令的形式向其提供工作流，否则微处理器无法达到其潜在的最大速度。任何阻碍工作流的事件都将降低处理器的速度。

CPU 速度/内存容量遵循摩尔定律。但是，内存的速度并不遵循摩尔定律，因此 CPU 处理指令的速度可能快于外界输入指令的速度…

满足 CPU 速度的技术：**流水线**（Pipeline），**分支预测**(Branch prediction）、**数据流分析、推测执行**

> 流水线：如果两个指令都需要按顺序使用 E1、E2、E3 三个单元，那么其实没必要等待第一个指令完成才执行第二个；可以在第一个指令进入 E2 时，立刻将第二个指令放到 E1 执行。或者，计算机在取某条指令的操作数时，可以同时译码下一条指令。
>
> 这种技术被称为流水线，因为它与工厂上的流水线很相似：不需要等待某个产品完成才生产下一个产品。这种并行处理的方式可以大大提高计算机的处理效率。
>
> 分支预测：预测当前的条件跳转指令会跳转到何处，并提前取哪里的指令并译码
>
> 推测执行：CPU 推测这条指令会加载什么东西/存储什么东西，因此在处理此指令时提前进行 I/O，以免被下一部分 I/O 指令卡住。

**困境**：其他关键部件**尤其是主存**速度慢于 CPU 速度、CPU 需要等待从而陷入瓶颈，降低整体性能

> 事实上，I/O 操作，主存，总线操作均慢于 CPU，只不过主存读写慢的影响是最大的。

### Performance Balance（性能平衡）

**CPU 和主存之间的接口是最关键的路径**，主存读写过慢是最大的性能瓶颈。

DRAM：动态随机存取存储器，用于制作主存

DRAM 虽然容量增加很快，但读写速度的增长远比处理器速度增长的慢——不平衡

**解决办法**：

:one: 优化系统结构，平衡CPU、内存、I/O整体性能

:two: 改进CPU和内存之间的接口

- 增加一次接受的比特数：让DRAM“更宽”而不是“更深”（每次取的数据更多）
- 改变DRAM接口：增加高速缓存（Cache）。Cache 使用 SRAM，集成度相对较低（因此密度较低，总容量不大），但速度明显更快。Cache 中一般存储主存常用数据的副本
- 减少内存访问频率：更复杂的缓存和芯片上的缓存
- 增加互连带宽：高速总线

:three: 缓存和缓冲方案

:four: 高速互连总线和更精细的互连结构

> 高速设备挂高速总线，离 CPU 更近；多个低速设备挂到同一个高速总线上，这根总线再接入主要的总线（传递了一下）。毕竟产生数据速度这么慢，慢点到 CPU 也无所谓（

:five: 使用多处理器配置可以帮助满足 I/O 需求

### Improvements in Chip Organization and Architecture（芯片组成与体系结构的改进）

虽然现在 CPU 快于外设导致连接成了瓶颈，但这不代表 CPU 可以不再发展了。

:one: 提高处理器的硬件速度

- 基本上是由于逻辑门尺寸的缩小，导致数据传递速度变快，时钟频率增加


:two: 增加缓存的大小和速度

:three: 改善处理器组织和架构（并行）

时钟频率和芯片密度的提升也会受到一些阻碍：

:one: 功耗：功率密度（W/cm^2^）随逻辑密度和时钟速度而增加，耗电和散热成为一大问题

:two: RC 延迟:：电子流动的速度受到连接它们的金属线的电阻和电容的限制。元件离的越近，电阻和电容就越大。

:three: 内存速度滞后于处理器速度

## Multicore, MICs and GPGPUs(重点)

**Multicore**：即多核，在一个芯片上使用多个处理器可在不提高时钟速率的情况下提高性能。

> 这种性能提高是线性的：单核到双核的性能提高接近 100%

多核处理器通常也需要更大的高速缓存。最开始，二级缓存是处理器中所有核共用的；现在，二级缓存也是每核一个了，三级缓存倒是共用，但是大小增大到了接近 5MB。

**MIC**：即集成众核，MIC 是联合处理器的软件架构，使用的核的数量多达几十个。多核通常只有几个核。

> 一般的多核处理器的每个核都是强大且通用的，针对各种场景都有优化；MIC 的核仅针对特定工作弱化，而且功能相对较弱，仅在处理量较大，任务单一的处理场景中更好用。

同构多核：处理器的所有核心结构相同，地位对等

异构多核：不同核心具有不同特点，计算能力有强有弱。一般采用主处理器核+协处理器架构，主处理器核用于控制核通用计算，协处理器核用来执行特定运算。

> Intel 出的大核-小核处理器也是异构多核

**GPU**：Graphics Processing Unit，即图形处理单元，是一种专门在各种设备上做图像和图形相关运算工作的微处理器，常用于深度学习（不过和原先的目的一点关系都没有）

最初的 GPU 是一个可插拔的图形卡，能够渲染 2D/3D 的图像和视频。

GPU 适用于大批量、重复的简单计算，比如处理大量同方法的浮点运算，类似于一个向量处理器（

GPGPU：GPU 上的通用计算。部分科学计算（比如矩阵运算）也是大量简单的重复运算，因此也适合在 GPU 上完成。英伟达的 Cuda 让在 GPU 上执行科学计算（和炼丹）变得非常简单。

## Performance Assessment（性能评估）(重点)

怎么评估不同的 CPU 的性能？有什么通用的指标吗？

### 性能评估计算

**时钟频率**：处理器执行的操作由系统时钟控制，处理器的速度由系统时钟的脉冲频率决定，以每秒周期(Hz)为时钟频率

> 时钟频率不能直接用于比较处理器的强度，因为不同架构的处理器执行相同指令花费的时钟周期数不同，需要比较”时钟频率*指令花费的周期“这个变量，即处理器时间

**处理器时间**T：处理器执行给定程序所需的时间

:red_circle: $T= 程序的CPU时钟周期数量*时钟周期的长度τ=程序的CPU时钟周期/时钟速率$

:red_circle: $T= CPI ×I_C ×τ = CPI ×I_c /时钟速率$

$CPI$: 每条指令的平均周期	$I_c$: 指令数   τ：时钟周期的长度
$$
CPI = \Sigma^n_{i=1}CPI_i\times p_i
$$
CPI 等于每个指令花费的 CPU 周期 * 该指令出现概率的和

> CPI 的出现是为了解决不同指令执行时间存在天然差异的问题：它通过计算所有指令使用的平均周期数来表示。
>
> 计算机的性能要提高，就要降低 CPI 或者 Ic。但是，实际上，这两个参数基本是“按下葫芦起了瓢”的关系：降低 CPI，Ic 就会增加，反之亦然。精简指令集（RISC）致力于让指令更简单，从而降低 CPI（每条指令的占用周期），但是指令数量会增加；复杂指令集（CISC）致力于让一条指令干最多的事，降低指令数量，但是 CPI 会增加。

受指令集体系结构、编译技术、处理器实现和内存层次结构的影响

**处理器速度**：指令执行的速度，单位为每秒数百万条指令 (MIPS)，称为 MIPS 速率

后面的公式一般用于计算 MIPS rate；前面的公式用于计算「100 万条指令在这个计算机上需要执行多长时间」这种问题。

f：处理器的时钟频率；Ic：一个程序包含指令的条数 T：此 CPU 执行这个程序需要的时间。
$$
MIPS\ rate = \frac{I_c}{T\times 10^6}=\frac{f}{CPI\times 10^6}
$$
浮点操作速度：浮点运算操作指令执行的速度，单位为每秒数百万个浮点指令(MFLOPS)

![image-20211006200128178](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211006200128178.png)

### 基准测试程序

由于指令集不同，指令执行速率并不是比较处理器性能的最好方法。例如，便以相同的高级语言程序时，精简指令集的指令数多于复杂指令集。二者可能花了相同的时间完成，那么 RISC（精简指令集）的 MIPS 速率就高于 CISC（复杂指令集），但能说精简指令集指令执行速度快于复杂指令集吗？未必。

**Benchmarks**：用高级语言定义的一组程序，在一个特定的应用程序或系统编程领域中，尝试提供一个计算机的代表性测试

**特征**：

> - 用高级语言编写，使其可移植到不同的机器
>
> - 代表一种特殊编程风格，如系统编程、数字编程或商业编程
>
> - 测量容易
>
> - 分布广泛

基准测试程序本质上就是在比较同一个程序在不同 CPU 上消耗的 CPU 时间（CPU 周期数量 * 每个周期长度），以确定处理器的性能。

**SPEC**：一个行业协会，定义和维护最知名的基准测试套件集合

性能测量被广泛用于比较和研究目的

**SPEC CPU 2006** : 最著名的 SPEC 基准套件,用于处理器密集型应用程序而不是 I/O 的行业标准套件

### Amdahl 定律计算(重点)

> 对系统某部分加速时，其对系统整体影响取决于该部分重要性和加速程度。
>
> 要想显著加速整个系统，必须提升全系统中相当大的部分的速度。
>
> 加速比：优化系统之后，其速度相比之前提升了多少。计算式：
>
> 加速比 = $\dfrac{加速后的速度}{加速前的速度}=\dfrac{加速前执行时间}{加速后执行时间}$

$$
设变量\ \ F_e=\frac{能改进的部分的执行时间}{整体的执行时间}\le1 \qquad  \  S_e=\frac{某部分改进前的时间}{改进后的时间}\ge1\qquad\qquad
$$

再设  $T_0:任务在性能提升前的执行时间$

改进后整个任务的执行时间为：
$$
T_n = T_0(1-F_e)+T_0(\frac{F_e}{S_e})
$$
前半部分表示「没有改进的部分需要的执行时间」，它等于改进前没动的部分的执行时间。后半部分表示「改进部分现在的执行时间」，等于改进前的整体时间乘 Fe（能改进的总时间）除 Se 
$$
T_n = T_0(1-F_e+\frac{F_e}{S_e})
$$
加速比为：改进前执行时间 / 改进后执行时间
$$
S_n=\frac{T_0}{T_n}=\frac{1}{(1-F_e)+\frac{F_e}{S_e}}
$$
$F_e$对系统性能提升的限制作用很强：

- 当 Fe 趋近于零时（几乎没有可改进的了），那么无论 Se 有多大， $S_n=1$，即没有任何加速

$S_e$ 对系统性能的提升效果有限：

- 即使 Se 趋近于无穷（极大幅度优化某一部分），Sn = $\dfrac{1}{1-Fe}$ 也到不了很大，也就是说 Sn 的上限受 Fe 的限制很大。

**举例**：假设一个任务大量使用浮点运算，40%的时间被浮点运算占用。在新的硬件设计下，浮点模块的速度提高了k倍。这种改进带来的总体加速是多少?

解: $F_e=0.4$（因为可优化部分占用时间为 40%）,$S_e=K$，根据Amdahl定律:
$$
S_n=\frac{T_0}{T_n}=\frac{1}{(1-F_e)+\frac{F_e}{S_e}}=\frac{1}{0.6+0.4/K}
$$
当$S_e= ∞, Sn=1.67 $，所以总体加速最多为1.67