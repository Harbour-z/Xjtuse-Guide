# 操作系统结构

> 易俊泉学长的原始笔记链接如下：
>
> [第三章-操作系统结构](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第三章-操作系统结构.md)

## 3.1 Operating System Services操作系统服务

操作系统提供的服务如下：

> - **用户界面：包括命令行界面与图形化界面**
> - **程序执行**：读取并执行一个程序
> - **I/O操作**：I/O 是特权指令，需要系统完成
> - **文件系统操作**：读、写、创建、删除文件
> - **通信：运行的进程在同一计算机或者网络中的不同计算机之间传递信息的过程。两种方式：共享内存与消息交换(进程部分会细讲)**
> - **错误检测**：探测 CPU、硬件、I/O、用户程序中可能存在的错误。

其他的功能不是用于帮助用户，而是为了系统效率：

- Resource allocation 资源分配 ：把资源分配给多个用户或多个同时运行的作业
- Accounting 帐务（统计）：跟踪和记录用户对资源的使用，用于帐单和统计
- Protection 保护：确保对资源的所有访问均在控制中

![image-20211221141947085](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211221141947085.png)



## 3.2 System Calls 系统调用

### 系统调用的概念

**系统调用提供在运行程序和操作系统之间的接口，属于一个软件中断、陷阱（预先设计好的异常）**

通常以汇编语言指令形式提供；替代汇编语言的、供系统编程的语言，允许直接使用系统调用

其实，用户程序主要通过**高级应用程序接口（API）**访问系统功能，而不是直接系统调用使用

> API 可能把多个系统调用做了封装，可以便捷的完成多个工作。

三个最常见的API

> Windows 的 Win32 API
>
> POSIX API 用于基于 POSIX 的系统(包括几乎所有版本的 UNIX、Linux 和 Mac OS X)
>
> 用于 Java 虚拟机(JVM)的 Java API

系统调用可以由用户态下的程序提出，但一定在管态下处理

### 系统调用的过程

:one: 当用户使用系统调用时，产生一条相应的指令

:two: CPU在执行到该指令时发生中断，发出有关的信号给中断处理机构；

:three: 处理机构在收到了CPU发来的信号后，启动相关的处理程序去完成该系统调用所要求的功能

:four: 在处理系统调用之前，中断处理机构还需**保存处理机现场**（PSW、PC、系统调用号、用户栈指针、通用寄存器、用户定义的参数等）

常见问题：

1. 如何找到实现系统调用功能的子程序？

使用**入口地址表**（类似中断向量表），每个入口地址与相应的系统程序对应。系统调用时，查询地址表即可。

陷入处理程序用系统调用功能号查找入口地址表,得到该系统程序的入口地址,并执行之

系统调用处理结束后，要恢复处理机现场，从而用户程序可以继续执行

2. 在发生系统调用时，哪些内容是操作系统保存的，哪些是硬件保存的？

   PC 由中断隐指令自动保存；PSW 由硬件保存，CPU 用户态/管态关键字的切换由硬件完成。

   操作系统需要完成：保存通用寄存器的值，初始化中断向量表（这个在开机时做一次就行，不用每次中断都做），查询中断向量表、执行对应的中断服务程序。

![image-20211003164249246](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211003164249246.png)

系统调用的三步骤：保护现场，查询入口程序表寻找处理程序并执行，返回并恢复现场

> 其实任何应用程序中的中断都是这样的流程

### 系统调用中状态的明析

1. 系统调用中，什么将用户态转变为管态？

   答案：这是硬件完成的。中断服务程序/入口程序运行于核心态下，因此无法实现转换；一般转换是在系统调用指令触发后，执行前，由硬件设置的。

2. 系统调用中在用户态下执行还是管态下执行？

   系统调用**在管态下执行**。用户态下，只能实现触发系统调用；由于系统调用包含的内容一定是特权指令，其一定在管态下执行。

   系统调用的触发/调用可以在用户态下，执行一定在管态下。

   用户态到管态的转换由硬件完成，见上一个问题。

在用户态下发生 != 在用户态下执行。比如，系统调用和缺页中断、外部中断都可能在用户态下发生，但是这些事件发生后，会立刻进入管态，在管态下处理事件。

3. 系统调用需要保存 PSW（程序状态寄存器）和 PC，而一般的过程调用（CALL 指令）只需要保存 PC，不需要保存 PSW，因为子过程调用通常不会导致 PSW 变化。

### 系统调用中，向操作系统传递参数的常见方式

 3 种常用方式用于在运行程序和操作系统之间的参数传递：

:one: Pass parameters in *registers*寄存器中的参数传递

:two: 参数存在内存的一张表中，表地址作为寄存器的参数传递

此时，这些参数存在内存的块或者表中，而块和表中的地址通过寄存器来传递

![image-20211003170141181](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211003170141181.png)

:three: 程序把参数压入栈，由操作系统弹出

==注意：**先传递系统调用参数，再执行访管指令（trap）让用户态陷入管态**。==

### 系统调用的常见类型

五大类：进程控制、文件管理、设备管理、信息维护、通信

## 3.3 System Structure 系统结构

### 简单结构 Simple Approach 

**MS-DOS**

MS-DOS 以最小的空间提供最多的功能。但是，它甚至连模式位都没有，没有双模式，任何程序都可以直接干掉系统（

> 不划分模块
>
> 尽管有某种结构，其接口与功能层没有划分清楚

应用程序可直接访问 BIOS 例程，来直接操纵设备，当然这受限于当时的硬件，intel 8088 没提供双模式和硬件保护，这使得 DOS 别无选择只能任由应用程序访问 BIOS.

![image-20211015213656837](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211015213656837.png)

**UNIX**

受硬件功能限制，早期UNIX只是有限的结构化。 UNIX包括2个分离的部分:系统程序与内核

内核包括了在物理硬件之上，系统调用之下的一切，提供文件系统、CPU调度、存储管理和其他操作系统功能：每一层有大量的功能

![image-20211015214509920](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211015214509920.png)

### 层次化结构 Layer Structure

分层法：操作系统划分为若干层，在低层上构建高层。底层（0层）为硬件；最高层（ N层）为用户层。每一层都使用下一层提供的服务，并对上一层封装，不能跨层调用。

**分层的基本原则**：每一层都使用其底层所提供的功能和服务，以便于系统调试和验证。

**困难**

> 层次的划分和安排，要保证不出现双向依赖关系

![image-20211015214831105](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211015214831105.png)

**优点**(<font color="red">重点</font>)

> :one: 低层和高层可分别实现（便于扩充）；
>
> :two: 高层错误不会影响到低层，便于调试、利于功能的增删改；
>
> :three: 调用关系清晰（高层对低层单向依赖），避免递归调用，有利于保证设计和实现的正确性 

**缺点**

> 1. 难以设计：高层只能依赖底层，底层不能向上依赖，很难分解为单一方向的依赖关系
> 2. 执行效率不高：执行一段程序需要穿越多层，效率可能较低/
>
> ==最主要的缺点是难以设计==。太复杂和效率不高虽然也可能出现，但效率不高不是一定的；优化的好的话效率也还可以。这和微内核结构不同：微内核结构的效率一定不高。
>
> 

### 微内核 Microkernels

**Mach 首先使用微内核结构，**典型系统如 MACH 和 Windows NT

通过划分系统程序和用户程序，把所有不必要的部件移出内核，形成一个小内核，微内核提供最少量的**进程管理**、**存储管理**，以及通信功能

操作系统由**两大部分**组成

> 运行在核心态的微内核
> 被从核心态移出的，运行在用户态并以 C/S（客户端-服务器） 方式运行的进程层

程序必须通过微内核才能访问用户态的其他进程

基于微内核结构的OS和传统OS相比，具有以下特点：

:one: **内核精巧**．通常内核只由<font color="red">任务管理、虚存管理和进程间通信3个部分</font>组成．传统OS内核中的许多部分都被移出内核．采取服务器方式实现；

:two: **面向多处理机和分布式系统**．基于微内核的OS，在内核中引入了多处理机调度和管理机制，并引入了细粒度并发机制——线程，使得多个处理机可以在同一个任务中并行地执行；

:three:  **基于客户／服务器体系结构**．在微内核结构的OS中，任务间通信机制—— 消息机制是系统的基础，OS的各种功能都以服务器方式实现，向用户提供服务．用户对服务器的请求是以消息传递的方式传给服务器的。

<font color="red">优点</font>

> 易于扩充，易于移植
> 提高系统的可靠性：（非核心模块的崩溃不会导致整个系统崩溃）
> 提供多种操作环境
> 便于实现分布计算：以同样的调用形式，在下层可通过核心中的网络传送到远方服务器上  (RPC, Remote Procedure Call)

<font color="red">缺点</font>

> 由于需要频繁通信和进行管态/用户态切换，执行效率更低：==不高效。效率低==

### 可加载的内核模块

> 使用面向对象的方法 
>
> 每个核心组件都是分开的
>
> 每个都通过已知的界面与其他人联系
>
> 每个都可根据需要在内核内加载
>
> **任何一个模块的崩溃都会导致系统崩溃**

主内核提供核心服务，其他服务在主内核运行时可动态加载。

类似于分层，但是更加灵活，任何模块可以彼此调用。也类似于微内核，主模块只有核心功能，并知道如何加载其他模块和如何让模块进行通信

### 混合系统

大多数现代操作系统都不是单纯的一个结构，而是会采用多种上面提到的结构



## 3.4 System Programs系统程序

**系统程序提供程序开发和执行的便利环境**。可划分为：

> 文件操作、状态信息、文件修改、程序语言支持、程序调入与执行、通信、应用程序

大多数用户看到的操作系统是由系统程序定义而不是实际的系统调用定义的
