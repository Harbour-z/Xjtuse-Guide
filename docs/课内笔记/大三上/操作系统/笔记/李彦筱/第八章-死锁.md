# 第八章 死锁

> 易俊泉学长的原始笔记链接如下：
>
> [第八章-死锁](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第八章-死锁.md)

## 8.1 死锁产生的原因

**死锁 Deadlock**：计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种**互相等待**的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。

（即存在一组等待的进程，每个进程都拥有一部分资源，且在等待其他进程当前持有的资源）

死锁问题的产生主要是因为多个进程抢占数量不足的资源。

**共享资源的获取和释放**

request (申请)：如果申请不能立即被允许，那么进程必须等待直到能获取资源。（通过系统调用或者信号量来进行资源的申请和释放）

use (使用)：进程使用资源进行相关操作

Release(释放)：进程释放资源

如果一个进程要使用 OS 管理的资源，需先向系统提出申请，如果有可用资源，系统才进行分配。

**资源的分类**

:one: 根据资源性质：

> 可抢占资源—指资源占有进程虽然需要使用该资源，但另一个进程却可强行把资源从占有者进程处抢来。
>
> 不可抢占资源—指只有占用者进程不再需要使用该资源而主动释放资源外，其它进程不得在占有者进程使用资源过程中强行抢占。
>
> **一个资源是否属于可抢占资源，完全取决于资源本身的性质**
>
> 不可抢占资源才会引发死锁。

:two: 根据使用方式：共享资源和独占资源。

:three: 根据使用期限；永久资源和临时性资源。

死锁实例：

![image-20211026162748420](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026162748420.png)

这种属于竞争资源引发死锁，

**死锁的原因**

:one: 竞争资源引起死锁

资源数量不足，多个进程竞争资源引起死锁。

> 当系统中供多个进程所使用的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁

:two: 进程推进顺序不当引起死锁

就像 A 申请 R1、B 申请 R2，接下来 A 想申请 R2、B 想申请 R1，此时两者都持有对方需要的资源，且都请求对方的资源，因此死锁。

> 在多道程序系统中，并发执行的进程推进序列不可预测
>
> 有些推进顺序，进程可以顺利完成
>
> 有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成死锁

## 8.2 死锁特征（必要条件） Deadlock Characterization

四个条件同时出现，死锁将会发生

**:one: Mutual exclusion 互斥**：一次只有一个进程可以使用一个资源（资源不可给多个进程同时使用）

**:two: Hold and wait 请求并保持**：一个进程占有至少一个资源，并申请了另一个资源，而该资源被另一个进程所占有（也叫做请求并保持）

**:three: No preemption 不可剥夺**：一个资源只有当持有它的进程完成任务后自由的释放，不能被剥夺

**:four: Circular wait 循环等待**：等待资源的进程之间存在环



## 8.3 资源分配图

> 资源分配图会在后面提到的「死锁避免」中使用

资源系统模型：

系统中存在多种类型的资源：$R_1$、$R_2$、..., $R_n$；每种资源都可能存在多个实例（多份），记为 $W_1$， $W_2$…。$P_i$ 表示进程

资源分配图包含：一个顶点的集合 V 和边的集合 E

顶点存在两个种类：P：含有系统中全部的进程；R：含有系统中全部的资源

边也分为两个种类：

请求边：直接 $P_i->R_j$  （进程请求资源时的边）

分配边： $R_j -> P_i$（资源被进程占用）



具体符号：圆形-进程，方块-资源，里面点的数量表示资源实例数量

进程指向资源的边是请求边，资源指向请求的边是分配边

实例图见下图的右侧。

![image-20211026164306727](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026164306727.png)

如果图没有环，那么不会有死锁

如果图有环

- 如果每一种资源类型只有一个实例，那么死锁一定发生

- 如果每种资源类型有多个实例，可能死锁

![image-20211222102443093](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222102443093.png)

左侧：图中存在两个环，且确实死锁

右侧：图中存在一个环，但是没有死锁，因为 P4 释放掉 R2 后，P3 就能拿到 R3；P2 释放掉 R1 后，P1 就能拿到 R1，所以 P1/P3 不会死锁。



## 8.4 处理死锁的方法

目前处理死锁的方法有以下四种：

> **鸵鸟算法**：视而不见
>
> **预防死锁**：抑制死锁的必要条件
>
> **避免死锁**：在资源的动态分配过程中，用某种方式防止系统进入不安全状态
>
> **检测与解除死锁**：检测出死锁的产生，然后采用某种措施解除

分为三类：

- 鸵鸟：什么都不做
- 让系统不要进入死锁状态：预防/避免死锁
- 允许系统进入死锁状态，但之后解除：检测/接触死锁

### 鸵鸟算法

忽略这个问题，假装系统中从未出现过死锁。（这个方法被大部分的操作系统采用，包括UNIX）也叫做鸵鸟策略，像鸵鸟一样对死锁视而不见

为什么操作系统有时选择什么都不做呢？

- 处理死锁的代价很大，而且常常给用户带来许多不便的限制。

- 大多数用户宁可在极偶然的情况下发生死锁，也不愿限制每个用户只能创建一个进程、只能打开一个文件等等。

- 于是不得不在方便性和正确性之间作出折衷。

### 预防死锁 Deadlock Prevention 

抑制死锁的四个必要条件

**互斥**：共享资源不是必须的，必须保持非共享资源

> 这个条件不能打破，许多资源必须只有一个进程访问

**占有并等待**：打破方式：**必须保证进程申请资源的时候没有占有其他资源**

具体实现方式（两种）：

- 要求进程在执行前一次申请全部的资源（比如数据库中的三级封锁协议）

- 没有资源时，可以申请资源。在申请更多其它资源之前，需要释放已有资源

这两种实现方式都存在利用率低的问题，且可能出现饥饿

**非抢占**：打破方式：如果一个进程的申请没有实现，它要释放所有占有的资源；需要抢占的资源放入进程等待资源列表中，只有进程能够重新得到旧的资源和新申请的资源时，才可以重新开始

**循环等待**：打破方式：将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源；编号递增申请。

这种打破方法称为：**资源有序分配**

比如：对所有资源类型编号，CPU 是 1 、打印机是 2、I/O 是 3……当申请多个资源时，必须先申请 1（CPU），再申请 2 （打印机）……

> 利用编号，强制资源申请成为线性的过程，打破环

以上预防死锁的方式通过限制进程请求资源打破死锁的必要条件实现。

死锁预防的副作用：

> 降低设备利用率和吞吐量
>
> 可能有进程饥饿（其所需资源不断被其他进程抢占）

### 死锁避免

死锁预防是通过限制进程申请资源避免死锁；死锁避免是通过分配资源前进行检查避免死锁。

允许进程**动态地**申请资源，系统在进行资源分配之前，先计算资源分配的安全性

若此次分配不会导致系统从**安全状态向不安全状态**转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。

安全状态是**指系统的一种状态，在此状态下,系统能按某种顺序（例如P1、P2……Pn）来为各个进程分配其所需资源，直至最大需求，这个分配顺序使每个进程都可顺序地一个个地完成。这个序列（P1、P2…….Pn）称为安全序列。**

安全序列是一个资源分配序列，按此序列分配资源时，系统处于安全状态（不会死锁）

若某一时刻不存在一个安全序列，则称系统处于不安全状态。

> 如果一个系统在安全状态，就没有死锁
>
> 如果系统死锁，则处于不安全状态
>
> 如果一个系统处于不安全状态，就有可能死锁，也可能不会死锁
>
> 可以存在多个安全序列

为避免死锁，要让系统永远不进入不安全状态。

#### 死锁预防算法

如何求得安全序列呢？根据资源包含多少实例，分为不同状态。

**当一种资源只有一个实例**：使用资源分配图

**当一种资源有多个实例**：使用银行家算法

#### 资源分配图算法

除了请求边和分配边，增加一种边：需求边 $P_i->R_j$  代表进程 Pi 可能会申请资源 Ri，表示为虚线、

> 需求边是有向边，在检查时也计入环的构成；它表示比较弱的请求边，可以被转化为分配边。

一个进程申请资源的时候，进程-资源的边由需求边转化为分配边（箭头的指向会变得相反）。当资源被进程释放的时候，分配边转化为需求边（箭头方向相反）

当一个进程 Pi 申请资源 Rj 时，由循环检测算法检查：

如果把图中的需求边$P_i->R_j$ 转为分配边$R_j -> P_i$ ，图中会出现环路，就不实施资源分配。没有环路，才进行资源分配。

![image-20241213155551024](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMNZ2AEy-viEAeDpoXKORirOt-fK5oAAlMTAAKnjAABVxsAAbrH9ntjGDYE.png)

例如，上图表示 P2 申请资源 R1，但 R1 分配给了 P1；现在，P1 和 P2 都想申请 R2。

对于 P2 申请 R2，我们进行检查：把 P2->R2 的边变成反方向的实线（分配边），看看是否出现环，结果真的有环：（虚线可以参与构成环）

![image-20241213155717467](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMOZ2AEzgp2709QFotIfQWhy9B-AWQAAlQTAAKnjAABV7rT8kR19oGYNgQ.png)

因此，不能把 R2 分配给 P2。

我们再想想能否把 R2 分配给 P1。上图中，如果 P1 指向 R2 的虚线变为反方向的，那么图中不会出现环，因此可以分配。

从直观角度看，也确实如此：R1、R2 都分配给 P1 后，P1 肯定能正常完成，完成后资源都可以释放，再分配给 P2，不会出现死锁。

#### 银行家算法

```
在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
操作系统分配资源时，需要考虑：分配资源后，进程会不会再把资源还回来，就像贷款评估一样。
```

**当一种资源有多个实例**时使用银行家算法；一个资源只有一个实例时，可以使用更简单的资源分配图检查。

当一个进程请求资源，且系统不能给它分配资源时，它可能要等待

当一个进程得到所有的资源，它必须在有限的时间释放它们（还贷）

每一个进程必须事先声明使用资源的数量

**数据结构**

n 为进程的数目，m 为资源有多少类型

Available（系统中可以分配的资源）：数组，如果 available[j]=k,那么资源 Rj 有 k 个实例有效

Max（每个进程最多请求多少资源）：矩阵，如果 Max[i,j]=k,那么进程 Pi 可以最多请求资源 Rj 的 k 个实例

Allocation（每个请求已经分配了多少资源）：矩阵，如果 Allocation[i,j]=k,那么进程 Pj 当前分配了 k 个资源 Rj

Need（每个进程还需要多少资源）：矩阵，如果 Need[i,j]=k,那么进程 Pi 还需要k个资源Rj的实例

![image-20211026171900404](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026171900404.png)

进程需要的资源 = 最多请求的资源 - 已经分配的资源

**资源请求算法**

设$Request_i$为进程 Pi 的请求向量（数组），如果$Requset_i[j]==k$,那么进程 Pi 需要资源类型 Rj 的实例数量为 k，当进程 Pi 作出在这一资源请求时：

:one: 如果$Requset_i\le Need_i$，转到第2步，否则生成出错条件，这是因为进程 $P_i$ 提出的请求已经超过了其实际最大需求。

:two: 如果$Requset_i\le Available_i$，转到第3步，否则 Pi 应该等待，因为没有资源可用

:three: **假设（不实际分配）**系统可以分配给进程Pi请求的资源，并按以下方式修改状态

![image-20211026173833258](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026173833258.png)

Available\[j\] 数组减少；Allocation\[i\][j\] 增加；Need\[i\]\[j\] 减少。

:four: 用安全算法检查这次假想的分配发生后，系统是否处在安全状态。如果安全，则实际分配资源；如果不安全，就拒绝分配。

**安全算法**

Work：当前系统可以提供的资源个数，数组，每一格表示一个资源

Finish：进程是否已经结束（true：已结束；false：正在运行）

![image-20211026174212179](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026174212179.png)

找到 i 使得：

- 此进程正在执行（Finish\[i\] = False）
- 此进程所需资源数量 < 系统当前资源数量

如果找到了，则：

- 增加系统当前资源数量（假设此进程结束了，返还了其持有的一切资源）
- 把 Finish[i] 设置为 true（防止再次检查此进程）

检查所有满足 2 的进程，如果所有进程都能顺利结束（Finish[i] = true），那么当前就是安全的。

![image-20211222110712565](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222110712565.png)

**举例**

5 个进程 P0 到 P4：3个资源类型 A(10 个实例），B（5 个实例），C（7 个实例），问目前系统是否处于安全状态？

![image-20211026174521361](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026174521361.png)

Need = Max - Allocation（题目中可能会让你自己算）

![image-20211026174805259](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026174805259.png)

只要有任何一个安全序列，系统就是安全的。

### 死锁检测

检测死锁与恢复策略。这种情况允许系统进入死锁状态，系统会在检测到死锁状态时，解决死锁。

死锁检测和死锁避免的对比：

- 死锁避免需要保证进程在运行过程中一直不可能出现死锁，因此需要进程开始到结束的所有资源请求
- 死锁检测只需要检查特定时间下系统中是否有死锁，因此只需要知道此时刻进程的资源请求。

#### 每种资源只有一个实例

等待图法——有环就有死锁

等待图：

节点：只有进程作为节点

边：进程 Pi - > Pj 表示 Pi 在等待 Pj 的某个资源

可以很简单的把资源分配图转换为等待图，只需要去掉资源节点，把进程相互连接即可。

存在环则证明存在死锁

#### 每种资源有多个实例

使用特定死锁检测算法（类似于银行家算法里的安全检测算法）

这里 Allocation、Need、Available、Work 的定义和银行家算法里都一样，但 Finish 定义不同。

当进程拥有的资源为 0 时，Finish=true（认为其已经结束）；进程拥有资源时，Finish=false（需要计算）

![image-20211222110040556](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222110040556.png)

如果所有进程的 Finish[i] 都为 true，或者当前的 Work 向量剩余的资源无法满足任何请求时，算法结束。在后一种情况下结束时，说明存在死锁。

完成算法后，所有 Finish[i]=false 的进程 i 都处于死锁状态。

![image-20211222110819324](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222110819324.png)



举例：

![image-20211222111344136](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222111344136.png)

左图不会发生死锁。

右图是指 P2 从不请求任何资源改为需要请求一个 C 的实例。此时死锁发生，除了 P0 的进程都无法完成。

### 死锁恢复

常见三种方法：人工处理、进程终止、资源抢占

人工处理：操作员自己做一些操作解除死锁

**进程终止**：有两种方式

- 终止所有的死锁进程

- 一次终止一个进程直到死锁环消失

  选择终止顺序：通常根据进程的优先级；进程计算了多少时间，还需要多少时间

**资源抢占**

> 逐步从进程中抢占资源，直到打破死锁（即强行剥夺进程的资源，让其阻塞，直到有资源后再次执行）
>
> 抢占资源后， 进程需要回退：返回到安全的状态，然后重新开始申请资源
>
> 可能会发生饥饿：同一个进程可能总是被选中，因此一直被回退
