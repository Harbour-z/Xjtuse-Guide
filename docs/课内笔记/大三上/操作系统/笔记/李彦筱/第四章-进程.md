# 进程

> 易俊泉学长的原始笔记链接如下：
>
> [第四章-进程](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第四章-进程.md)

## 4.1 进程概念

**进程**：在批处理系统中指的是作业，在分时系统中指的是用户程序或者任务，在本篇文章中，使用的名词「作业」和「进程」，基本可互换

近代操作系统多为**并发执行**，具有许多新的特征，引入并发执行的目的是为了**提高资源利用率**。此外，由于现代计算机都是多道的，也就是内存中存在几个运行的程序，交叉运行且共享资源，难免出现资源占用冲突等问题。此时，需要引入新的概念--进程。

### 顺序与并发

#### 顺序环境

顺序环境下，计算机系统只有一个程序在运行，该程序独占系统中所有资源，其执行不受外界影响。因此，不可能出现资源冲突等问题。

**顺序执行的特点**

顺序性：按照程序结构所指定的次序（可能有分支或循环）

封闭性：独占全部资源，计算机的状态只由于该程序的控制逻辑所决定（因此不会受外界影响）

可再现性：初始条件相同则结果相同。如：可通过空指令控制时间关系。

#### 并发环境

一定时间内，物理机器上有两个或两个以上的程序同处于开始运行但尚未结束的状态，并且**次序不是事先确定的**。

**并发执行的特点**

间断(异步)性："走走停停"，一个程序可能走到中途停下来，失去原有的时序关系

> 这就体现了操作系统四大特征中的异步性
>
> 这里「失去时序关系」指的是多个程序间交叉运行的顺序不可预测；单个程序包含所有指令的执行顺序还是正确的，只是其中可能插入其他程序的指令。
>
> 为了控制各个程序之间指令的执行顺序，引入了第七章的信号量相关内容。

失去封闭性：共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征。

失去可再现性：失去封闭性 －>失去可再现性；外界环境（比如其他程序）在程序的两次执行期间发生变化，则程序结果可能变化，失去原有的可重复特征

扩展：选择性阅读

**顺序与并发总结**

> 顺序:上一个开始执行的任务完成后，当前任务才能开始执行
>
> 并发:无论上一个开始执行的任务是否完成，当前任务都可以开始执行
>
> (也就是说，AB顺序执行的话，A一定会比B先完成，而并发执行则不一定。)

**串行与并行总结**

> 串行:有一个任务执行单元，从物理上就只能一个任务、一个任务地执行
>
> 并行:有多个任务执行单元，从物理上就可以多个任务─起执行

并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力。

### 进程与程序

进程是描述程序动态特征的概念。严谨的说，进程是在运行的程序，是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。它是动态的，活着的，正在内存中被 CPU 执行的。

一个进程由**程序、当前活动、数据**三部分组成：

- 程序代码（因为进程是运行中的程序，自然包含程序的信息）
- 当前活动/上下文，比如 PC 和 CPU 寄存器
- 栈区域（临时数据，比如函数中创建的变量）
- 数据部分（包含全局变量）

后两部分都是进程的数据。

:one: **进程是动态的，程序是静态的**：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件，它是静态和可以复制的。

> 虽然二进制代码大概率在机器间不通用……但你就说能不能复制走吧

:two: **进程是暂时的，程序是永久的**：进程是一个状态变化的过程，程序可长久保存。

:three: **进程与程序的组成不同**：进程的组成**包括程序**、数据和进程控制块（即进程状态信息）。

:four: **进程与程序的对应关系**：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序

### 进程的特征

**结构特征**：`进程实体=程序段+相关的数据段+PCB`

> PCB 就是上面提到进程的「当前活动」。

**动态性**：进程的实质是进程实体的一次执行过程，因此**动态性是进程的最基本的特征。**

**并发性**: 多个进程实体同存在于内存中，且能在一段时间内同时运行。是最重要的特征。

**独立性**：指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。

**异步性**: 进程按各自独立的、不可预知的速度向前推进。

### 进程的类型

系统中主要有两大类进程

系统进程：系统进程能管理和控制资源

用户进程：执行用户程序的进程

**区别**

> :one: 资源的使用：系统进程被分配一个**初始的资源集合**，这些资源可以为它独占，也能以最高优先权的资格使用。用户进程通过**系统服务请求**的手段竞争使用系统资源；
>
> :two: I/O操作：用户进程不能直接做 I/O 操作，而系统进程可以做显式的、直接的 I/O 操作。
>
> :three: CPU工作状态：系统进程在**管态**下活动，而用户进程则在**用户态**下活动。
>
> 区别 3 直接导致了区别 2

### 进程状态

进程在执行的时候会改变状态，每个进程可能处于以下几个状态：

:hourglass_flowing_sand: <mark>**五状态模型**</mark>

**新建 new**：在创建进程

OS 已完成为创建一进程所必要的工作

> 已构造了进程标识符;
> 已创建了管理进程所需的表格;

还没有允许执行该进程：因为资源有限（比如当前内存不足），无法将其转为就绪态。

**就绪 ready**：进程等待分配处理器,**已经获得了除处理器以外的所有资源**

>
> 存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到 CPU，就立即可以运行（有多个进程处于此状态）
>
> 运行状态的进程在时间片用完后，进入就绪状态
>

**运行 running**：指令在执行

当进程由调度/分派程序分派后，得到CPU控制权，它的程序正在运行（在单处理机系统中，总只有**一个进程**处于此状态）

> 对于多核处理器，可以有多个进程同时处于 running 的状态

**(阻塞)等待 waiting**：进程等待某些事件发生

>
>进程正在等待某个事件的发生（如等待 I/O 的完成），而暂停执行
>
>即使给它 CPU 时间，它也无法执行
>
>一般进程等待的事件发生后，进程会进入就绪状态，而不会直接进入运行状态。

**终止 terminated**：进程执行完毕

:label:**注意区分就绪状态和阻塞状态：关键在于分配给该进程处理器时，能否立即执行**，能的话处于就绪状态；否则处理阻塞状态。
而且**执行状态只能由就绪状态转换，而无法从阻塞状态直接转换**

![image-20211016100320557](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016100320557.png)

以上图片描述了状态转移的可能过程

就绪状态-->执行状态：一个进程被进程调度程序选中，给予了 CPU 时间片

执行状态-->阻塞状态：请求并等待某个事件发生

执行状态-->就绪状态：时间片用完或在抢占式调度中有更高优先级的进程变为就绪状态

阻塞状态-->就绪状态：进程因为等待的某个条件发生而被唤醒

:hourglass_flowing_sand: **七状态模型**

引入了挂起:

:one: **终端用户的需要**：当终端用户在自己的程序运行期间，发现有可疑问题时，往往希望暂时使自己的进程静止下来,以便研究其执行情况或对程序进行修改

> 或者用户想试试新学的 bg 指令（

:two: **父进程的需要**：父进程常常希望考察和修改子进程，或者需协调各子进程间的活动，要挂起自己的子进程;  

:three: **操作系统的需要**：操作系统有时需要挂起某些进程，检查运行中资源的使用情况及进行记帐，以便改善系统的运行性能。

:four: **对换的需要**：为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。

> 这称为「中调度」：将内存中的部分进程换到磁盘上，以减少内存压力，下一节「进程调度」会提到。
>
> 中调度和第十章提到的「虚拟内存」并不相同。

:five: **负荷调节的需要**：当实时系统中的工作负荷较重，可能影响到对实时任务的控制时，可由系统把一些不重要或不紧迫的进程挂起，以保证系统仍然能正常运行。

![image-20211016101024340](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016101024340.png)



引入挂起后，多了两个状态：就绪状态的挂起进程（称为静止就绪）/阻塞状态的挂起进程（称为静止阻塞）

> 对应的，Ready 现在被称为「活动就绪」，Blocked 被称为「活动阻塞」

我们可以挂起运行状态/就绪状态/新建状态/阻塞状态的进程。

当静止阻塞状态的进程获得其需要的条件时，会转移到静止就绪状态。

### 进程控制块（PCB）

PCB (Process Control Block):一个专门的数据结构，系统用它来记录进程的外部特征，**描述进程的运动变化过程** 

PCB 是进程管理和控制的最重要的数据结构，在创建进程时，建立 PCB，并**伴随进程运行的全过程**，直到进程撤消而撤消。

PCB 是系统感知进程存在的唯一标志,**进程与 PCB 是一一对应的**

PCB 经常被系统访问，如，调度程序、资源分配程序、中断处理程序等，所以 PCB 应**常驻内存**。

PCB 中包含以下信息：

进程状态（上一节提到的五状态/七状态）、程序计数器、CPU 寄存器、CPU 调度信息、内存管理信息、计账信息、I/O 状态信息

进程标识符 name:

每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。

执行程序开始地址 start-addr：进程开始执行的地址

进程优先级 priority：

进程的优先级反映进程的紧迫程度，通常由用户指定和系统设置。UNIX系统采用用户设置和系统计算相结合的方式确定进程的优先级。

CPU 现场保护区 cpu status（通用寄存器，PC，PSW 等）

当进程因某种原因不能继续占用 CPU 时（如:等待打印机），释放 CPU，这时就要将 CPU 的各种状态信息保护起来，为将来再次得到处理机恢复 CPU 的各种状态，继续运行。

通信信息 communication information

是指某个进程在运行的过程中要与其它进程进行通信，该区记录有关进程通信方面的信息。

家族联系 process family

进程可创建自已的子进程，子进程还可以创建，一个进程往往处在一个家族之中，就需要记录进程在家族中位置的信息。在 Unix 系统中，进程有一个 PPID 属性（Parent PID），表示其父进程的 pid。

占有资源清单 own-resource

进程占用系统资源的情况，不同系统的处理差别很大，UNIX系统中就没有此项。

> ![image-20211221151742843](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211221151742843.png)

为了管理的方便，系统将相同状态的进程组成一个队列，如就绪进程队列，等待进程可以组成单个等待队列，也可以根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘 I/O 完成队列等等。这样，当一个资源被释放/当前执行程序转变为就绪时，系统就知道应该让哪个进程先转换状态。

当前队列指针 next 指向:登记与本进程处于同一队列的下一个进程的 PCB 的地址

![image-20211016101753918](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016101753918.png)

PCB 通过表来进行组织，PCB 表的个数（长度）就决定了系统中最多可同时存在的进程个数，称为**系统的并发度**。组织方式包括：**链接方式与索引方式**

> 链接方式：将同一状态的 PCB（比如所有就绪进程的 PCB）连接成一个队列，每个 PCB 都包含一个指针，指向与本进程处于同一队列的下一个进程的 PCB 的地址
>
> 索引方式：如下图所示，PCB 块存储在数组中，各个队列（比如就绪队列、阻塞队列）每个位置都存储 PCB 块实际位置的指针；PCB 块物理上不在队列存储表（比如就绪索引表）中。

![image-20211016102110546](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016102110546.png)

## 4.2 进程调度

多道程序设计的目的是无论何时都有进程进行，可以最大化CPU利用率；分时系统的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互。为了这些目的，**进程调度器**选择一个可用进程到CPU中进行

### 调度队列

为了方便进程调度器选择幸运进程，所有进程按照其状态排成多个队列：

**作业队列** - 在系统中的所有进程的集合（所有状态的进程都在此队列中）

**就绪队列** - 在主内存中的，就绪并等待执行的所有进程的集合（包含就绪状态的队列）

**设备队列** - 等待某一I/O设备的进程队列，位于此队列的进程都处于阻塞状态

![image-20211016104940830](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016104940830.png)

### 调度程序

调度分为三种：长程调度、中程调度与短程调度

**长程调度（或作业调度）**- 从作业队列（位于磁盘）中选择可以进入就绪队列的进程，加载到内存中

> 速度较慢（因为需要访问磁盘）
>
> 长程调度控制了多道程序的“道”，即控制了内存中总进程的数量。假设这是一个四道的操作系统，那么内存中最多存在四个进程，已经有四个进程时，长调度不会调度任何进程进入内存。

**短程调度（或CPU调度）**- 从就绪队列中选择可被下一个执行并分配 CPU 的进程

> 速度较快，切换频率高

**中程调度**-为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上（变为挂起状态），降低多道程序的度。当这些进程重新具备运行条件时，再从外存上调入内存。这一方案称为**交换**

> 这种交换是以进程为单位的；后面虚拟内存技术部分提到的交换是以内存页为单位的。

![image-20211016103931218](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016103931218.png)

进程可以大致分为两种：

- I/O 型进程：花费 I/O 时间多于计算，存在许多短 CPU 处理
- CPU 进程：花费 CPU 时间远多于 I/O 时间，存在许多长 CPU 处理。

一般长调度在选择进入内存的进程时，会综合的选择 I/O 型进程和 CPU 进程，防止二者负载不均的情况。

### 上下文切换

当CPU切换至另一个进程时，系统必须保存旧进程状态，读取待进入进程之前保留的状态。上下文切换的时间开销较重；在切换时，系统没有做有用的工作，时间取决于硬件的支持（取决于保存和载入的速度）

<font color="red">**具体的操作**</font>

> 当发生上下文切换时，内核CPU会将旧进程的上下文（通用寄存器、PC、PSW 等）保存在PCB中，并加载计划进行的新进程的上下文

## 4.3 进程上的操作

操作系统引入进程就是为了管理执行的程序，那么进程有哪些可以执行的操作呢？

![image-20211221154313632](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211221154313632.png)

上面这张图说明，进程执行操作后，就会从一个状态转变为另一个状态。比如，进程创建后，就会变为就绪状态；进程进行了阻塞性操作（比如请求操作系统进行 I/O），就会从运行变为等待状态。

> 注：上图没有画出所有进程状态之间的转换关系，比如「运行」到「就绪」状态的转换在 CPU 时间片耗尽，或者在可抢占分配的系统中被更高优先级的进程抢占时发生。

进程的状态发生了变化，一定是因为进程执行了某种操作。

### 进程创建 Process creation

进程何时创建？

- **作业调度**（长调度时创建）：批处理系统中，**作业调度程序**调度到某个作业以后，就把这个作业装入内存，并分配必要的资源,创建进程，插入就绪队列。

  > 即长调度（进程从硬盘到内存，从作业队列到就绪队列）时，进程就被创建了

- **用户登录**：在分时系统中，用户在终端键入**登录命**令后，若是合法用户，系统建立一个进程，并插入就绪队列。
- 提供服务：用户要求执行某操作时，操作系统主动创建一个进程为用户服务（比如用户需要打印，操作系统创建打印进程）
- 应用请求：应用进程的需要，由它自己创建一个新进程，使新进程以并发运行方式完成特定任务。（比如输入数据并将处理结果输出到表格上）

由第四点可以看出，父进程可以创建子进程，如此轮流创建下去，构成一个进程树

父子进程间的资源关系通常有三种：

1、父进程子进程共享所有的资源

2、子进程共享父进程资源的子集

3、父子进程无共享

当进程**创建**新进程时，可能有两种执行可能：

- 父进程与子进程并发执行

- 父进程等待，直到子进程终止（比如父进程调用了子进程的 wait 方法）

新进程的**地址空间**也有两种可能

- 子进程是父进程的复制品，具有和父进程一样的程序和数据（比如 Unix 上的 fork 函数创建的子进程）

- 子进程加载另一个新程序

#### 进程创建的过程

:one: **申请空白的PCB**：为新进程分配唯一的**数字标识符**，并从PCB集合中索取一个空白的PCB。

:two: **为新建立的进程分配资源**：为新进程的程序和数据，以及用户栈分配必要的内存空间

:three: **初始化程序控制块**

- 初始化标识符信息。将系统中分配的标识符、父进程标识符填入新PCB中。

- 初始化处理机状态信息（内存空间信息）。存储程序计数器指向程序的入口地址，栈指针指向栈顶。

- 初始化处理机控制信息。将进程的状态设置为就绪状态或静止就绪状态。

:four: **将新进程插入就绪队列**。

#### UNIX例子

在 Unix Shell 中输入一个命令并执行时，系统就创建了一个进程。

fork()：系统调用创建新进程

execlp()：系统调用用一个新程序替代进程的内存空间

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    int pid;
    pid = fork(); /*fork another process*/
    if (pid < 0)
    { /* error occurred */
        fprintf(stderr, "Fork Failed");
        exit(-1);
    }
    else if (pid == 0)
    { /* child process */
        execlp("/bin/ls", "ls", NULL);
    }
    else
    { /* parent process */
        wait(NULL);
        printf("Child Complete");
        exit(0);
    }
}
```

> pid=fork()： 调用这个函数时，立刻产生一个和父进程完全相同，且 PC 指针相同（都执行到刚调用完 fork 的位置）的子进程。
>
> 从系统调用 fork 返回时，CPU 在父进程中时，pid 值为所创建子进程的进程号，大于 0。若在子进程中时，pid 的值为零。
>
> （显然，子进程中，程序可以通过 getpid 得到自己的进程号；而父进程中，除非返回子进程号，否则其没有办法获得子进程的 pid。为了让程序能判断自己位于父进程还是子进程，子进程中 getpid 也不能返回父进程 pid，只能返回 0，不然无法区分了）
>
> 即两个进程的程序完全相同，PCB 显然不同，数据区域只有 pid 这一个数据不同。

### 进程终止 Process termination

**进程调用**：当进程完成执行最后语句并且通过系统调用 exit() 请求操作系统删除自身时，进程终止。此时，进程可以返回状态值(通常为整数)到父进程。所有进程资源会被系统释放

父进程可终止子进程的执行。比如，如下情况下，父进程可能会终止子进程：

- 子进程使用了超过它需要的资源

- 赋予子进程的任务不再需要

- 父进程终止

**僵尸进程**：当进程已经终止，但是其父进程尚未调用 wait()（此时子进程的退出信息无人取走，因此不能完全消失）

**孤儿进程**：父进程没有调用 wait() 就终止，其子进程成为孤儿进程

> 此时子进程会以 init（系统默认进程）作为其现在的父进程

### 进程阻塞 Process blocking

一个处在运行状态的进程，因等待某个事件的发生（如等待打印机、同步事件等）而不能继续运行时，将调用阻塞原语，把进程置为阻塞状态，并转进程调度程序（等于让出处理机）。

调用进程阻塞操作是在进程处于**运行状态**下执行的。它的执行将引起等待某事件的队列的改变

![image-20211016112500530](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016112500530.png)

### 进程唤醒

当进程所等待的事件发生时，该进程将被唤醒(由进程唤醒操作完成)。

唤醒一个进程有两种方法：由系统进程唤醒、由事件发生进程唤醒

> 注：被唤醒的进程进入就绪队列，不能直接送给 CPU 执行

![image-20211016113113001](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016113113001.png)

## 4.4 协同进程 Cooperating Processes

独立进程不会影响另一个进程的执行或被另一个进程执行影响

协同进程可能影响另一个进程的执行或被另一个进程执行影响

> 共享内存空间的进程一定是协同进程（比如使用 fork 创建的父子进程）

进程协同的优点

> Information sharing 信息共享
> Computation speed-up 加速运算
> Modularity 模块化
> Convenience 方便

## 4.5 进程间通信 Interprocess Communication (IPC)

通常有两种方式：消息传递与共享内存

消息传递：两个进程利用内核作为中介通信

共享内存：两个内存同时读写同一块内存区域，可以直接在这段内存中传递信息。

![image-20211016114045548](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211016114045548.png)

### 共享存储

使用共享存储模型的进程间通信要通过内核建立共享存储区，进程通过读写共享存储区来交换信息，由通信进程来确定交换的数据和位置，**不受操作系统的控制**

> 创建共享存储区需要内核参与，而后续读写此区域时就不需要内核参与了。

### 消息传递

若P与Q需要通信，需要建立通信连接与通过send/receive交换信息。

消息传递有两种方式：**直接通信与间接通信**

生产者进程生产供消费者进程消费的信息 ，无界缓冲没有对缓冲区大小的限制，有界缓冲对缓冲区大小作了限定

> 判断缓冲区是否满了：计算 in + 1 (mod n) 是否等于缓冲区的大小。
>
> in：缓冲功能区写入区域；out：读出区域

#### 直接通信

进程发送消息前必须显式说明自身；接受消息时也需要指定接受谁的消息（也可以不指定，此时接受任何消息）

> send(P, message)：向进程P发信息
>
> receive(Q, message)：从进程Q收消息（如果 id 是空的，那么任何进程都可以向本进程发送消息。

#### 间接通信

消息导向至信箱并从信箱接收（被视作端口port）

每一个信箱有一个唯一的 id；仅当共享一个信箱时进程才能通信

> 发送和接受函数的定义：:
>
> ​    send(A, message) – send a message to mailbox A
>
> ​    receive(A, message) – receive a message from mailbox A
>

进程创建的邮箱是私有的，操作系统创建的邮箱是共享的

>  仅当进程具有一个信箱时连接才能建立；连接可同多个进程相关（多个进程可以共用一个邮箱）

邮箱共享时谁得到信息？**随机一个正在接收消息的进程**。因此，两个都在接受消息的邮箱可能都会拿到错误的消息（都拿到对方该接受的消息了）

解决方案：允许一个连接（邮箱）最多同 2 个进程相关；只允许一个时刻有一个进程执行接受操作；允许系统任意选择一个进程作为接收者，且发送者被通知谁是接收者

### 客户端-服务器通信

常见方式：

- Socket（套接字，类似网络通信）

- Remote Procedure Call（远程过程调用，RPC）

  即本地某个函数的功能是调用远程主机上的一个函数，就像那个函数在本机一样。传输过程中，需要发送包含调用函数名、参数字节化后的字节流。不过，对客户而言，这是不可见的，就像函数真的在本机一样。

- Remote Method Invoke（仅限 Java，远程方法调用）

  类似 RPC

### 同步 Synchronization

消息传递要么是阻塞的，要么是非阻塞的。

**阻塞的消息传递是同步的**：发送者调用发送函数后会等待消息被接收，接收者会等待消息到达可用

**非阻塞的消息传递就是异步的**：发送者会一直发送消息不必等待，接收者同样也可以不必等待

### 缓冲 Buffering

不管通信时直接的还是间接的，通信进程交换的信息总是驻留在临时队列中。队列实现有三个方法：

- **零容忍**：发送者必须等待接收者（因为没有缓冲，必须等待接受者收取完所有内容）

- **有限容量**：缓冲区具有有限的长度，若连接满了发送者必须等待接受者收取一条消息才能继续发送

- **无限容量**：无限长度，发送者从不等待

### 消息传递的例子

#### Mach

所有内容都是消息传递，即使是系统调用也是通过消息传递实现的

在创建一个进程时，进程中创建了两个特殊邮箱：内核邮箱 kernel mailbox 与通知邮箱 notify mailbox。内核通过内核邮箱与任务通信，将事件发生的通知发送到通知邮箱。

消息传递只需要三个系统调用：`msg_send(), msg_receive(), msg_rpc()//远程调用`

系统调用 port_allocate() 创建新邮箱，并为消息队列分配空间，最大长度位8个消息

#### Windows XP

XP 使用 LPC（Local procedure call），只允许相同机器上的进程相互通信。

1，对于少量信息：使用端口的消息队列，消息的最大长度为 256 字节，简单。

2，对于大量信息：使用 section object, 即建立一块共享内存。