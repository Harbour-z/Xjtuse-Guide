

# 第十三章 I/O系统

> 易俊泉学长原始笔记的链接如下：
>
> [第十三章-IO系统](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第十三章-IO系统.md)

**I/O 硬件**

> I/O 设备、设备控制器、I/O 通道、总线系统

**I/O 控制方式**

> 程序 I/O 方式、中断驱动方式、DMA 方式、I/O 通道控制方式

**缓冲技术**

> 缓冲的引入、单缓冲、双缓冲、循环缓冲、缓冲池

**I/O软件**

## 13.1 I/O 系统的组成

计算机系统中，除了需要直接用于 I/O 和存储信息的**设备**外，还需要有相应的**设备控制器**。在大、中型计算机系统中，还需有 **I/O 通道**，由这些设备以及相应的**总线**构成了 I/O 系统

### I/O 设备

I/O 设备类型繁多，从 OS 观点看，其性能指标有：

> 数据传输速率
>
> 数据的传输单位（按块还是按单字节传输）
>
> 设备共享属性等 （独占还是共享）

#### 按速率分类

> **低速设备**
> 传输速率仅为每秒钟几个字节至数百个字节。属于低速设备的典型设备有键盘、 鼠标、语音的输入和输出等设备。
>
> **中速设备**
> 传输速率在每秒钟数千个字节至数万个字节。典型的中速设备有**行式打印机、激光打印机**等。
>
> **高速设备**
> 传输速率在数百K个字节至数十兆字节。 典型的高速设备有**磁带机、磁盘机、光盘机等。** 

#### 按信息交换的单位分类

> **块设备**
> 信息的交换以块为单位，不能仅仅读取一个字节。<font color="red">**用于存储信息。**</font> 由于信息的存取总是以数据块为单位，故而得名。 典型的块设备是**磁盘**，每个盘块的大小 为 512 B~4 KB 。磁盘设备的基本特征是其**传输速率较高**,通常每秒钟为几兆位；另一特征是可寻址 ,即对它可随机地读 / 写任一块；此外，磁盘设备的 I/O 常采用DMA 方式。 
>
> **字符设备** 
> 信息的交换以字符为单位。<font color="red">**用于数据的输入和输出。**</font> 其基本单位是字符， 故称为字符设备。 
>
> 块设备一定是可寻址的；字符设备不一定是可寻址的。

**时钟**：**既不是块设备也不是字符设备**

#### 按设备的共享属性分类

> **独占设备**:在一段时间内只能有一个进程使用的设备，一般为低速I/O设备（如打印机，磁带等）
>
> **共享设备**:在一段时间内可有多个进程共同使用的设备，多个进程以交叉的方式来使用设备，其资源利用率高（如硬盘）
>
> **虚拟设备**:通过虚拟技术把一台独占设备变换为若干台逻辑设备，可供多个用户使用

### Controller（设备控制器、I/O 接口）

设备不能直接与 CPU 进行通信，而是与设备控制器通信。**每个设备都对应一个设备控制器**。

> 不和 CPU 通信是因为以外设的时钟频率和传输速度，直接在总线上传输数据会严重拖慢 CPU 运行

每个 I/O 设备通过设备控制器与计算机的数据总线和地址总线相连接。

设备控制器位于 CPU 和 I/O 设备之间，其接受 CPU 发来的命令，控制 I/O 设备工作。

某些设备（如磁盘设备）有内置的控制器

设备控制器是一个可编址设备，

当它仅控制一个设备时，它只有一个唯一的设备地址，若控制器可连接多个设备时，则应具有多个设备地址，使每一个地址对应一个设备。

![image-20211222214715761](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222214715761.png)

设备控制器分为三部分：

- 控制器和 CPU 的接口：设备控制器和 CPU 之间存在数据线、地址线和控制线相连，数据线传输读/写的数据，状态信息，地址线传输 CPU 需要访问的 I/O 设备的编号，控制线传输读/写信号。
- 控制器和设备的接口：设备控制器可能连接一个或者多个设备，每个设备都具有三个接口：数据接口，状态接口和控制接口。
- I/O 逻辑：译码 CPU 传来的控制命令，调度对应 I/O 设备。

### I/O 通道

**定义**：通道是独立于 **CPU 的专门负责数据 I/O 传输工作的处理机**，对外部设备实现统一管理，**代替CPU 对 I/O 操作进行控制**，从而使I/O操作可与CPU并行操作。 通道具有执行程序的能力，可以执行专门为其编写的通道程序。

**目的**：建立独立的I/O操作，不仅**使数据的传送独立于CPU**，而且使有关对I/O操作的组织、管理及其结束处理也尽量独立，即把CPU从繁杂的I/O任务中解脱出来，提高CPU与设备，设备与设备之间的并行工作能力. 、

![image-20211222214823420](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222214823420.png)

由于通道价格昂贵，致使机器中所设置的通道数量势必较少，这又往往使它成为I/O 的瓶颈，造成整个系统吞吐量的下降。 

![image-20211222215101983](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222215101983.png)



## 13.2 I/O 控制方式

这块计组详细讲过，因此操作系统课中除了 DMA 之外都快速略过。

### 程序 I/O 方式(轮询Polling)

CPU 与设备串行工作

CPU 循环测试设备 I/O 是否完成—浪费大量CPU时间

### 中断驱动 I/O

在现代计算机系统中，对 I/O 设备的控制，广泛采用**中断驱动**（Interrupt---Driven）方式。

在 I/O 设备输入/输出每个数据的过程中，无须 CPU 干预。

仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。不过，中断驱动要求外设每传输一个字节都要 CPU 介入处理一次中断，对于高速设备还是比较浪费 CPU 的。

### DMA 控制方式

中断驱动 I/O 是以**字（节）为单位**进行I/O的，若将这种方式用于块设备的 I/O，显然将会是极其低效的。

为了进一步减少 CPU 对 I/O 的干预，而引入了直接存储器访问（Direct Memory Access）方式。

DMA方式的特点是：

> 数据传输的基本单位是**数据块**，而不再是字节。
>
> 所传输的数据是从设备直接送入内存的活着内存直接进入设备，无需 CPU 介入
>
> 整块数据的传送是由控制器完成的，仅在一块数据开始和结束传输时，才需要 CPU 介入。

### I/O 通道控制方式

DMA 每次只能执行一条 I/O 指令，不能满足非常复杂的 I/O 操作要求。在大、中型计算机系统中，普遍采用由专用的 I/O 处理机（I/O 通道）来接受 CPU 的委托，独立执行自己的通道程序来实现 I/O 设备与内存之间的信息交换，这就是通道技术。

步骤：CPU 向 I/O 通道发送 I/O 指令，指定通道需要执行的通道程序位置和要访问的 I/O 设备位置，通道执行通道程序，和一个/多个 I/O 设备交换数据，在完成所有任务后通知 CPU。

通道和 DMA 的区别：

- DMA 需要 CPU 控制传输的数据块大小，目标内存位置，而通道中这些都由通道自身完成
- DMA 只能对应一台 I/O 设备，而通道可以处理多个 I/O 设备。



## 13.3 缓冲池

引入缓冲的主要原因有以下三点：

> **缓和 CPU 与 I/O 设备间速度不匹配的矛盾**
>
> **减少对 CPU 的中断频率，放宽对中断响应时间的限制**
>
> **提高 CPU 和 I/O 设备之间的并行性** 

OS提供以下几种缓冲形式：单缓冲、双缓冲、循环缓冲、缓冲池

循环缓冲属专用缓冲。当系统较大时，为了提高缓冲区的利用率，目前广泛流行公用缓冲池，池中的缓冲区可供多个进程共享。

![image-20211222222207252](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222222207252.png)

缓冲池（Buffer Pool）的组成 ：

> 空（闲）缓冲区；
>
> 输入缓冲区:装满输入数据；
>
> 输出缓冲区:装满输出数据

为了管理上的方便，可将相同类型的缓冲区链成一个队列，形成以下三个队列：

> 空缓冲队列emq；
>
> 输入队列inq；
>
> 输出队列outq

同一块缓冲区根据其存储数据的不同，可以动态的在三个队列之间流转。比如，一个空缓冲区接受了 I/O 设备的输入，就进入了输入队列；其内容被程序读取后不再有用，回到空缓冲队列。

四种工作缓冲区：

> 收容输入缓冲区
>
> 提取输入缓冲区
>
> 收容输出缓冲区
>
> 提取输出缓冲区； 

![image-20211222222500057](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222222500057.png)

单缓冲：内存从 I/O 设备读取数据和 CPU 从内存读取设备是不能并行的，只能串行

> 读取数据和 CPU 处理 I/O 数据是可以并行的

双缓冲：内存从 I/O 设备读取数据和 CPU 从内存读取设备是可以并行的，但是：

当前正在从 I/O 读取的数据**无法并行读取到 CPU**；在内存从 I/O 设备获得数据时，**CPU 只能从内存中读取上一次（内存从 I/O 获得的）数据**。

题目：

某文件占 10 个磁盘块，现要把该文件磁盘块逐个读入内存，并送用户区进行分析，假设一个缓冲区与一个磁盘块大小相同，把一个磁盘块读入缓冲区的时间为 100us，将缓冲区的数据传送到用户区的时间是 50us，CPU对一块数据进行分析的时间是50us。在单缓冲和双缓冲区结构下，读入并分析完该文件的时间分别是多少？

1550us   1100us



## 13.4 I/O 软件（I/O 子系统）

为了处理 I/O，操作系统提供了一些软件，方便用户访问 I/O 设备。

**I/O 软件功能**

提供设备使用的用户接口：命令接口和编程接口。设备的符号标识

设备分配和释放：使用设备前，需要分配设备和相应的通道、控制器。

设备的访问和控制：包括并发访问和差错处理。

I/O 缓冲和调度：利用前面讲到的缓冲区等技术，提高 I/O 访问效率

**I/O软件的基本思想**:

按**分层**的思想构造 I/O 子系统。

较低层的软件要使较高层的软件独立于硬件，向较高层提供一些服务。

较高层的软件则要向用户提供一个友好、规范、清晰的界面。

**I/O 软件组织成以下4个层次：**

> (1)用户空间的I/O软件（用户使用 I/O 的接口）
>
> (2)与设备无关的I/O软件(设备独立软件)
>
> 这是一部分通用的 I/O 功能，与具体设备无关，作用：根据设备名，找到具体设备的驱动程序（下一层），以实现操作设备控制器；缓冲、设备保护和设备的分配与释放。
>
> (3)设备驱动程序
>
> (4)中断处理程序（处理设备 I/O 操作完成的消息）

![image-20211222224318393](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211222224318393.png)

I/O 设备有很多种，大致可以分为如下两类：**字符设备**和**块设备**。二者的数据传输单位不同，因此操作系统对于两者的处理方式不同。

块设备通常按照块为单位传输数据，因此常用缓冲区暂时存储器传输的数据。



下面详细介绍这四层的功能和实现。

### I/O 子系统（第一层）

操作系统提供部分接口，允许用户进程发起系统调用，请求 I/O 操作。

> I/O 指令是特权指令，只能由操作系统发出，因此用户程序进行 I/O 需要发起系统调用，陷入管态后，由操作系统完成 I/O 操作，再把结果返回给用户程序。



## 13.5 设备独立软件（第二层）

完成与设备无关的 I/O 操作,具体包括：

- 向上层提供统一接口

- 分配和释放独占设备，为设备命名

- 实现设备独立性等

- 抽象：将设备抽象为块设备、字符设备

**设备命名**

- 负责把设备的符号名映射到相应的设备驱动程序。

- 设备命名后，所有设备的名字集合称做设备的名字空间。

在 UNIX 系统中： 

UNIX 把设备当作文件来管理，提供统一的操作命令，这是设备独立性的体现。

UNIX 设备命名实现：UNIX 系统中具有字符设备开关表、块设备开关表，实现把设备的符号名映射到相应的设备驱动程序。

**设备保护**

在大多数计算机系统中，用户进程对 I/O 设备的访问是完全禁止的，所有 I/O 指令都是特权指令，那么用户进程是如何使用设备的呢? 需要先申请设备：

用户进程调用系统调用，其中有参数说明要申请的设备名称，操作系统处理该系统调用时，会按照设备特性（是独占还是分时共享式使用）及设备的占用情况来分配设备，返回申请是否成功标志。

### 设备分配

在多道程序环境下，系统中的设备不允许用户自行使用，必须由系统分配。

为了实现设备分配，必须在系统中设置相应的数据结构，包含：

设备控制表 DCT

> 系统为每一个设备都配置了一张设备控制表，用于记录本设备的情况

控制器控制表 COCT

> 每个 I/O 设备都对应一个设备控制器，本表就用于记录每个设备控制器的情况。

通道控制表 CHCT：记录 I/O 通道的使用情况

系统设备表 SDT：存储系统中当前的所有设备和状态，以便 OS 检查当前是否存在某个设备。

> 整个系统有一张系统设备表；系统设备表中包含每个设备的 DCT 的位置

设备控制表存储了如下内容：

![image-20241111142750801](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMEZ1_ykkGJHVd4q8wpWzTb9loQA8UAAhkTAAKnjAABV1OGm0Zni2_LNgQ.png)

指向控制器表的指针：设备需要控制器才能正常运行，因此每个设备信息中给出指向该设备控制器表的指针，方便寻找其控制器。

设备队列队首指针：多个进程可能都想访问此设备，因此使用一个设备队列存储等待使用该设备的进程；当前占用设备的进程完成后，从设备队列取一个进程，让新的进程再使用本设备。



系统设备表（SDT）存储了如下内容：

![image-20241111150227137](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMFZ1_ylfg7MthzepLNMZL8DUYOuOMAAhoTAAKnjAABV6NS4uVfg_PRNgQ.png)

系统设备表**需要存储每个物理设备驱动程序的地址**，每个设备在设备控制表中的指针位置。



![image-20211125142402239](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211125142402239.png)

### 设备分配的考虑因素

为了使系统有条不紊地工作，系统在进行设备分配时，应考虑这样几个因素：

- 设备的固有属性：独占还是可共用的？

- 设备分配算法

- 设备分配的安全性

- 设备独立性 

**:one: 固有属性**

独占设备：同时只能被一个进程使用，因此需要考虑效率和死锁问题。两种分配方式：

> 静态分配在死锁一章提到过

静态分配：在进程运行前, 完成设备分配；运行结束时，收回设备

优点：一定不会死锁

缺点：设备利用率低。使用一个设备时，其他该进程申请的设备没有在使用。



动态分配：在进程运行过程中，当用户提出设备要求时，进行分配，一旦停止使用立即收回

优点：效率高；缺点：分配策略不好时,，可能产生死锁



共享设备：可以同时分配给多个进程使用

> 提出 I/O 请求的不同进程以排队方式分时地占用设备进行 I/O。比如，多个进程读取磁盘时，进程需要排队等待，等前一个设备完成读取后，下一个设备再读取。
>
> 由于有多个进程同时访问设备，且访问频繁，会影响整个设备使用效率，影响系统效率。因此要考虑多个访问请求到达时服务的顺序，使平均等待时间越短越好

把独占设备改造成虚拟设备，以实现共享

**:two: 设备分配算法**：

如果多个进程都要使用同一个设备，这个设备该分配给谁？

> 设备分配问题和 CPU 调度问题类似

与进程的调度算法有些相似，但相对要简单些：可以使用 CPU 调度的算法：

- 先来先服务
- 优先级高者优先 

**:three: 设备分配中的安全性**

从进程运行的安全性上考虑，设备分配有以下两种方式：

> 安全分配方式：每当进程发出I/O请求后，便进入**阻塞状态**，直到其I/O操作完成时才被唤醒。
>
> 不安全分配方式：进程发出I/O请求后仍继续运行，需要时又可发出第二个I/O请求、第三个I/O 请求。仅当进程所请求的设备已被另一进程占用时，进程才进入阻塞状态。 
>
> 不安全分配状态下，进程可能出现死锁，因为满足了请求并保持的条件

:four: **设备独立性**

**目的**：为了提高 OS 的可适应性和可扩展性。

**基本含义**： 应用程序独立于具体使用的物理设备。

> 即程序中不指定要使用的具体 I/O 设备，而使用更泛化的方式指代。
>
> 比如，我买了一台惠普的打印机，因此编写程序时就指定使用「HP Printer」这个名字访问打印机；但是几天后，这个打印机坏了，我又买了一个爱普生的，此时我就需要把程序里访问打印机用的名字改成「Epson Printer」。这太麻烦了，有办法做到让我的应用程序在不知道物理设备名的情况下，访问打印机吗？

为了实现设备独立性而引入了**逻辑设备和物理设备**这两个概念

- 应用程序使用逻辑设备名称来请求使用设备（不需要知道物理设备名）

- 系统使用物理设备名

- 系统需将逻辑设备名称转换为某物理设备，进行映射

> 这非常类似于内存管理中所介绍的逻辑地址和物理地址的概念。 

可以通过逻辑设备表记录逻辑设备名和物理设备名之间的映射关系（就像内存管理用的页表一样）

逻辑设备表 LUT(Logical Unit Table) ： 将应用程序中所使用的逻辑设备名映射为物理设备名。此外，它还存储物理设备驱动程序的入口，方便对设备操作。

LUT的设置可采取两种方式

- 记录逻辑设备名、物理设备名和驱动程序入口

- 记录逻辑设备名和其对应物理设备在系统设备表中的指针。

> 系统设备表中已经存储了设备的物理名称和驱动指针。

![image-20211125143617795](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211125143617795.png)

### 独占设备的分配程序

> 指针说明：
>
> 系统设备表中包含指向每个设备的设备控制表的指针，还包含指向该设备驱动程序的指针
>
> 设备控制表中包含指向该设备控制器的指针
>
> 设备控制器控制表中包含指向该设备所用 I/O 通道的指针。
>
> 即指针关系为 SDT->DCT->COCT->CHCT

对于具有I/O通道的系统，在进程提出I/O请求后，系统的设备分配程序可按下述步骤进行设备分配：

1. 分配设备 （根据物理设备名查找 SDT（系统设备表），找到设备DCT，分配设备）

2. 分配设备对应的控制器 （根据DCT找到COCT，分配控制器）

3. 分配设备对应的通道 （ 根据COCT找到CHCT，分配通道）

此种分配方式的问题：

- 采用设备的物理名称寻找设备，不利于扩展



上面提到，可以把独占设备改造成共享设备，从而允许多进程同时访问。那具体怎么完成呢？通过下面介绍的 SPOOLing 技术

## 13.6 以 SPOOLing 方式使用外设

SPOOLing：Simultaneous Peripheral Operations On-Line

SPOOLing 技术是用于**将一台独占设备改造成共享设备**的一种行之有效的技术

SPOOLing 技术是在批处理操作系统时代引入的，即所谓**假脱机**输入/输出技术

主要思路：

1. 外部进程使用设备时，先把其需要传递的输入放到磁盘上，然后把进程放入设备的等待队列
2. 设备空闲时，从磁盘上读取该进程需要输入的数据，进行处理，然后输出回磁盘上
3. 操作系统把设备在磁盘上的输出返回给外部进程。

SPOOLing 是一种虚拟设备技术，虚拟设备是指把一个物理设备映射为多个逻辑设备。

### 概念

> 共享不是指同一时刻设备可以被多个进程一起使用，而是指在一段时间内，多个进程可以交替使用设备，造成类似同时使用设备的景象，和并发的概念很相似。

脱机：把输入数据先放置到磁盘上，在外围控制机的控制下，再把磁盘上的数据输入主机。这是第二章讲多道批处理系统的概念。

SPOOLing：

利用多道程序中的**一道程序来模拟脱机输入时的外围控制机**的功能，把低速 I/O 设备上的数据传送到高速磁盘上；

> 由于这一道程序依然在主机上运行，并不是在单独的机器上运行，因此叫做假脱机。

用**另一道程序来模拟脱机输出时外围控制机**的功能，把数据从磁盘传送到低速输出设备上

这样，便在**主机的直接控制下，实现脱机输入、输出功能**。

此时的外围操作与CPU对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为SPOOLing (Simultaneous Peripheral Operations On-Line)，或称假脱机操作。

### 组成

SPOOLing 系统是对脱机输入、输出工作的模拟，它必须有高速随机外存的支持，这通常是采用磁盘。

SPOOLing 系统组成如下：

输入井和输出井：

输入井：暂存存储 I/O 设备**向内存输入的内容**，模拟脱机输入的磁盘

输出井：暂存内存**向 I/O 设备输出的内容**，模拟脱机输出的磁盘

输入缓冲和输出缓冲：输入/输出井无法保存多个应用程序给出的内容，因此，在输入/输出缓冲中保存除了第一个进程外，其他进程给出的需要输入/输出的内容。

输入进程和输出进程：模拟脱机输入时的外围控制机。

输入进程将 I/O 设备返回的数据放到输入缓冲，进而传入输入井中。当 CPU 空闲时，将输入井的内容读入内存。

输出进程将用户要输出的数据放到输出缓冲，进而传入输出井中。当 I/O 设备空闲时，从输出井中读取数据并处理。

**注意：输入和输出是相对内存而命名的，而不是相对 I/O 设备的**。

### 实现

SPOOLing 技术可将一台打印机改造成一台可供多个用户共享的设备。

当用户进程请求打印输出时，SPOOLing 做以下两件事：

1. 由输出进程在输出井中为之申请一空闲盘块区，并将要打印的数据送入其中；

2. 输出进程为用户进程申请一张空白的用户请求打印表，并将用户的打印要求（进程信息、打印文件位置）填入其中，再将该表挂到请求打印队列上。

打印机空闲时，输出进程从请求打印队列中依次取出请求打印表，根据表中的要求将要打印的数据从输出井传送到内存缓冲区，再由打印机打印。

### 特点

提高了 I/O 速度

将独占设备改造为共享设备

实现了虚拟设备功能



## 13.7 设备处理（第三、四层）

设备处理工作由两部分完成：设备驱动程序、中断处理程序

设备驱动程序：操作系统如何对待 I/O 设备，才能保证每次新增外部设备时，不需要重写自己已有的代码？

### 设备驱动程序

操作系统能够以统一的方式对待不同的I/O设备，因为具体的差别被称为 **设备驱动程序** 的内核模块所封装。与设备相关的代码放在设备驱动程序中。应为**每一类设备**配置一种驱动程序（同类的多个设备可以共用一种驱动程序）

设备驱动程序是 I/O 进程与设备控制器之间的通信程序，因为它常以进程的形式存在，故也可以称为设备驱动进程。它是常驻内存的。

**设备驱动程序实际是处理或操作硬件控制器的软件**，它抹平了不同设备之间的差异，让操作系统能使用统一的接口控制 I/O 设备。

**处理过程**

![image-20211125150444380](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211125150444380.png)

### 中断处理程序

在 I/O 时，设备控制器如果准备好服务，会向 CPU 发出中断请求。

这些中断表示输入数据已有，或输出已完成，或已检测到错误。

CPU 响应后便转向中断处理程序

无论是哪种 I/O 设备，其中断处理程序的处理过程都包含了以下几个步骤

> 唤醒被阻塞的驱动程序进程；
>
> 保护被中断进程的CPU环境；
>
> 分析中断原因、转入相应的设备中断处理程序；
>
> 进行中断处理；
>
> 恢复被中断进程的现场。

