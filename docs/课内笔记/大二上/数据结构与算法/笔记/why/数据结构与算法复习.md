# 数据结构与算法复习

## 写在前面

这个笔记是我期末复习时整理的，建议大家在考前稍微看一下就可以。可以边看边回想一些考点细节，整理得不是很细致，如果有模糊的地方可以去看看别人的笔记。

### 基本概念

数据

数据对象(类型相同的数据元素组成的集合) eg:一个班的学生信息

数据元素(数据的基本单位) eg:一位同学的信息

数据项(最小组成) eg:一位同学的姓名



数据结构三要素:逻辑结构,存储结构(或物理结构),运算

逻辑结构:线性表(线性结构),集合,图,树(非线性结构)等

存储结构:顺序存储,链式存储

运算:检索、排序、插入、删除、修改等



数据类型:一个值的集合及定义在该集合上的一组操作，用以刻画操作对象的特性 eg:整型

抽象数据类型(ADT)=逻辑结构+数据运算



时空权衡原则

### 算法分析

衡量算法在资源上的两个方面:**时间复杂度**(时间代价)和**空间复杂度**(空间代价)



题目:

算法的时间复杂度取决于问题的规模,待处理数据的动态



### 线性表

线性表:栈(stack)和队列(queue)

有前驱和后继

实现方法:顺序表和链表

顺序表(顺序存储)

* 用数组
* 插入:将curr位置元素及以后的元素都向后移一位,再将要插入的元素插入到curr位置(从后向前)
* 删除:将curr位置以后得元素向前移动一位(从前向后)(删除时会返回要删除的元素)
* 特点:查找快(随机存取 O(1)),插入/删除慢(O(n))

链表(链式存储)

* curr指针指向的是当前元素的前驱节点(便于插入和删除)
* 表头节点(为空,哑元节点)
* 找后继节点O(1),找前驱节点O(n)
* tail指针后面的节点是NULL
* 链表插入必须至少有一个元素,不能为空(顺序表可以)
* 特点:
  1. 与顺序表相反
  1. 动态存储(不需要确定预容量)

**栈**

后进先出

进栈顺序确定,出栈顺序不唯一

顺序栈:

* 栈中有n个元素时将位置n-1作为栈顶(位置是从0开始的)

* top是位置n(栈中有n个元素),为空 

  *top若为位置n-1则空栈时top初始化为-1*

* 进栈时先进栈top再自增,出栈时top先自减再出栈

**注**:存储变长字符串的顺序栈 书P69

链式栈:

* 不需要表头节点
* 长度可变,会产生结构性开销

**注**:可用栈来模拟递归(先压栈再出栈)(*采用非递归方式重写递归程序时不一定使用栈*)

应用:

* 中缀表达式
* 括号匹配

**队列**

先进先出

所有操作为O(1)

顺序队列:

* 循环数组
* 数组的大小比实际能存储的的元素多1
* front表示队首元素的前驱位置,rear表示队尾元素,front=rear时为空队列
* rear和front不会超过size-1

链式队列:

* 不需要表头节点
* front和rear分别指向队首和队尾
* 入队时先判断队列是否为空

应用:

* 打印数据缓冲区

### 二叉树

分类:

* 满二叉树:每个节点的子节点为空或全满
* 完全二叉树:从左到右填充
* 完美二叉树:n层全满
* 平衡二叉树:左右子树高度差不超过1

定理:

* m=n-1 m为边数,n为节点数(除根节点外每个节点往上都有边)
* $n_0=n_2+1$ $n_0$代表叶子结点,$n_2$代表度为2的节点

遍历:

* 层次遍历
* 先(前/根)序遍历
* 中序遍历
* 后序遍历

**注**:遍历可通过递归函数或栈(非递归)来实现

实现(存储结构):

* 顺序存储:适用于完全二叉树
  * 不存在结构性开销
  * 索引从0开始
* 链式存储:适用于其他
  * 每个节点有两个指针指向左右子节点
  * 可设置节点的值并返回



题目

二叉树的还原:先序+中序 或 后序+中序,可唯一确定(可判断两棵二叉树是否相同)

二叉树的层数从0开始

**二叉检索树(BST)**

左子树$\lt$父节点,右子树$\geqslant$父节点

中序遍历打印时会得到从小到大的排序

作用:查找

元素类型为Elem,用key来返回关键码

实现:

* 查找:找到时也要进行最后一次比较
* 插入:从根节点往下找到要插入的位置
* 删除:选择右子树中的最小值来代替要删除的值
* 时间代价取决于深度,平衡二叉树的为O($\log n$),不平衡的为O(n)

**Huffman编码树**

叶子结点的外部带权路径长度最短

路径长度:两个节点的路径数量

外部路径长度:所有叶节点到根节点的路径长度之和

**注**:没有度为1的叶子节点

实现方法:贪心算法

应用:文本压缩

* 用0,1来编码
* 符合前缀特性,可以反编码

**堆**

完全二叉树(用数组实现)

* 父节点为i,左子节点为2i+1,右子节点为2i+2

最大值堆(大根堆)

实现:

* 下沉:将某个元素下移置于正确位置,复杂度为O($\log n$)

* 插入:使用上浮,至正确的位置,复杂度也为O($\log n$)

* 弹出最大:根节点,将最后一个元素移到根节点位置,下沉O($\log n$)

* 建堆方法
  * 插入堆,上浮,O($n\log n$)
  * 筛选法建堆:对每个父节点(n/2开始减)进行下沉(从倒数第二行往上),O($n$)
  
  注:建堆的时候需要一个辅助记录单元(涉及到元素的交换)

**堆排序**

依次弹出最大元素,$O(n\log n)$

应用:找第k大的元素,时间复杂度$O(n+k\log n)$

### 树和森林

树的度:最大的节点度数

节点为n的树必有n-1条边(同二叉树)

树的周游:前序,后序,中序,层次

子节点表示法

* 在数组中存储树的节点.每个节点包括节点值,父指针和一个指向子节点链表的指针
* 若两棵树在不同的数组中,则合并困难.在同一数组中只需将一棵树的根节点添加到另一棵的子节点链表中即可

左子节点/右兄弟节点表示法

* 每个节点存储节点的值,指向父节点,最左子节点和右兄弟节点的指针
* 若两棵树存储在同一数组中,只需设置三个指针
* 空间效率高
* 每个节点需要固定的存储空间

动态节点表示法

1. 子节点指针存储在规模固定的数组中
   * 第一个域中存放值,第二个域中存放子节点指针数组的规模
2. 动态分配节点空间

动态左子节点/右兄弟节点

顺序表示法

1. 先序遍历,用/来表示空指针
2. 先序遍历,分支节点加',分支节点的空子节点用/,叶节点不加标记
3. 先序遍历,叶节点加),叶节点为父节点的最后一个节点加))

森林的遍历

1. 深度优先先根遍历:一棵一棵树遍历

   注:森林转化为二叉树后遍历序列不变

2. 深度优先后根遍历

   注:等同于二叉树的中序遍历

3. 广度优先遍历:一行一行遍历

并查集

* find/union
* 重量权衡合并规则:将节点较少树的根节点指向节点较多树的根节点
* 路径压缩:将每个不是根节点的指针指向根节点

树和森林与二叉树的转换

* 树变为二叉树

  1. 给兄弟节点之间加线
  2. 给除最左子节点的孩子去线

  注:树的先序遍历=二叉树的先序遍历,树的后序遍历=二叉树中序遍历

* 森林变为二叉树
  1. 森林中的每棵树变为二叉树
  2. 将每棵二叉树横向相连
* 二叉树变为树和森林:与树变二叉树过程相反

### 图

G=(V,E)

顶点数为$|V|$,边数为$|E|$

$|E|$与$|V|^2$比较,分成密集图和稀疏图

完全图:包括所有边

无向图/有向图:边是否有方向

无向图最大的连通子图为连通分量

自由树:不带简单回路的无向图,有$|V|-1$条边

存储:

* 相邻矩阵
  * 矩阵中$a_{ij}$表示i指向j的边,有则为1,无则为空
  * 空间代价为$O(|V|^2)$
* 邻接表
  * 以链表为元素的数组
  * 空间代价为$O(|V|+|E|)$

**注**:

* 相邻矩阵和邻接表都可以存储无向图和有向图(无向图中的边可以用两条有向边来代替)
* 密集图用相邻矩阵,稀疏图用邻接表,空间效率高
* 空间代价也为查找代价

图的实现?

图的遍历:

* 深度优先搜索(DFS)
  * 用递归或栈去实现搜索过程
  * 时间代价$O(|V|+|E|)$
* 广度优先搜索(BFS)
  * 用队列实现
  * 时间代价同DFS
  
  注:DFS可以在处理某个节点的所有邻接节点之前/之后访问那个节点,BFS只能在节点入队/出队时访问

**拓扑排序**

* 递归
* 优先队列

拓扑排列序列有序,相邻矩阵为三角矩阵

**最短路径**

单源最短路径:Dijkstra算法

* 密集图中扫描顶点表
* 稀疏图中使用优先队列

每对顶点间的最短距离

**最小支撑树**

连通且权和最小

* Prim算法
  * 用相邻矩阵寻找最近的节点
  * 用优先队列
  * $O(n^2)$
* Kruskal算法
  * 最差情况为$O(|E|\log |E|)$,一般情况为$O(|V|\log |E|)$,适合稀疏图

### 排序

不稳定的排序:选择、希尔、快速排序、堆排序

**插入排序**

* $O(n^2)$
* 让前面n个序列有序

**冒泡排序**

* $O(n^2)$
* 第i次从下往上交换n-i次

**选择排序**

* $O(n^2)$
* 先选出最小的n的数,每次只交换一次

**shell排序**

* $O(n^{1.5})$
* 对子序列排序用插入排序

**快速排序**

* $O(n\log n)$
* 空间复杂度$O(\log n)$,需要用栈来存放递归
* 递归次数与初始数据的排列次序有关

**归并排序**

* $O(n\log n)$
* 空间复杂度O(n),需要空数组
* 最好,差,平均运行时间相等

**基数排序**

* O(n*M),M为数据位数
* 空间复杂度O(M)

### 查找(检索)

查找:在数据集合中寻找满足某种条件的数据元素的过程

查找表

* 静态查找表:元素不改变
* 动态查找表:元素可插入、删除

查找长度:在查找运算中,比较关键字的次数

平均查找长度(ASL):在所有查找中查找长度的平均值

​	*注*:分为$ASL_{成功}$和$ASL_{失败}$

顺序查找法:从线性表的一端查找到另一端

* $ASL_{成功}=\frac{n+1}{2}$,$ASL_{失败}=n+1$

折半查找法:适用于有序的顺序表

* high,mid,low
* 可化为二叉检索树查找,$ASL_{成功}=O(\log n)$

**散列表**

散列:根据关键字的值计算出关键字在表中的位置(可以压缩关键码的索引范围)

散列函数(Hash Function)

散列表:m个地址,位置0-m-1

​	*注*:直接寻址表缺点为空间消耗大,关键字范围大,有浪费

散列地址:散列表中的地址

* 直接定址法:取关键字的线性变换的函数值作为散列地址
* 数字分析法:选取数码分布均匀的若干位作为散列地址
* 平方取中法:取关键字的平方值的中间几位作为散列地址
* 除留余数法:H(key)=key%p,p为小于等于m的素数,m为散列表长度

解决散列函数的冲突

* 开散列方法:将散列表中的元素变成链表(可以存储多条数据,称为桶)(链地址法)

* 闭散列方法

  * 线性探测法:插入位置有冲突时往后移动,直到不冲突
    * 不能真正删除元素,只能逻辑删除
    * 会产生基本聚集

  * 平方探测法:k位置冲突时,探测$k\pm1^2,k\pm2^2...$的位置
    * 也不能真正删除
    * 会产生二次聚集
  * 双散列探测法:第一个hash函数冲突时使用第二个hash函数确定偏移量(最后在散列表中的位置为第一个hash值确定的位置+第二个hash函数确定的偏移量)

  **注**:$ASL_{成功}$为每个数的平均查找次数(查找总次数/总数),$ASL_{失败}$为每个地址(Hash函数能映射到的位置)向后移动到空位置的平均次数(和空位置也要进行比较)

装填因子:$\alpha=N/M$,N为记录总数,M为散列表长度















