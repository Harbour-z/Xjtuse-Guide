# 第十一章 指令集：寻址方式和指令格式

## KEY POINTS

1. 寻址方式的定义

2. 各种寻址方式。在学习时，记住取指周期的目的是得到操作数的有效地址。思考每种寻址方式中，有效地址位于哪里？
3. 指令的格式，简单了解变长/定长指令。

> 易俊泉学长的原始笔记链接如下：
>
> [chapter11 指令集：寻址方式和指令格式](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter11指令集：寻址方式和指令格式.md)

## 寻址方式

**寻址方式**：确定当前指令中数据地址或下一个指令存储地址的方法。它取决于 CPU 硬件并影响指令格式和功能

寻址方式分为两种类型：**指令寻址（包括顺序寻址和跳跃寻址）和数据寻址**。顾名思义，指令寻址是寻找下条指令的方法，数据寻址是寻找本指令操作数的方法。

顺序寻址：下条指令的地址码使用程序计数器PC给出

跳跃寻址：下条指令的地址不由PC给出，而是由本条指令给出。一般仅用于转移指令

数据寻址方式很多，包含：

立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、偏移寻址、栈寻址

### 寻址方式说明

每个计算机都提供不止一种寻址方式：

指令操作码一般与其寻址方式一一对应（指令操作码一旦确定，其寻址方式就确定了）

还有使用指令格式中的一段作为寻址方式说明字段，但由于会占用地址空间，这种情况较为少见。

**有效地址**：操作数的真实地址

在没有虚拟存储器的系统中，有效地址就是内存的物理地址和寄存器。

在虚拟存储器系统中，有效地址就是虚拟地址或者寄存器。虚拟地址的长度往往会超过地址字段或者是寄存器的位数，就需要通过间接寻址或者是寄存器间接寻址以及偏移寻址方式等方式来获得，不能使用直接寻址了。

> ![](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704496.png)

上方表中符号说明：

A: 指令中地址字段的内容

R：指向寄存器的指令地址字段内容

EA：指操作数的真实地址，被访问位置的实际（有效）地址

> 在没有虚拟存储器的系统中，有效地址就是内存的地址或者是寄存器；在虚拟存储器系统中，有效地址就是虚拟地址或者寄存器

 X：存储器位置X或寄存器X的内容

### 立即寻址｜Immediate Addressing

**操作数是指令的一部分，操作数就是地址**

> 例如：ADD 5
>
> 5 就是操作数，不需要访问内存/寄存器来寻找操作数了。

其加载到数据寄存器中时，标志位将扩展到左侧（补充长度）以实现填满地址码位置。

这是最简单的寻址模式，无需访问内存或缓存；但范围有限，受地址码长度限制

**应用**：

定义和使用常数 

设置可变的初始值

![image-20211110102926350](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704499.png)

### 直接寻址｜Direct Addressing

地址字段包含操作的**有效地址**，且此地址指向主存。

> Cache 对程序员是透明的，所以我们不管地址对应的内容到底是在 Cache 里还是主存里

有效地址 （EA） = 地址字段 （A） 

> 例如。MOV AX， [1070H] 
>
> 将地址 1070H 的内容移动到 AX 
>
> 1070H 是一个内存地址，可以直接在此处写入，不需要多次查找

优点：只需要进行一次存储器访问，没有额外的计算来计算有效地址 

缺点：地址空间有限，受限于地址码的长度

![image-20211110102907461](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704500.png)

### 隐含寻址｜implicit addressing

操作的地址没有明确显示，它隐藏在操作码或**特殊寄存器**，如 AC 

 隐含的具体寄存器与所使用的指令密切相关。只有特定指令才能使用特定的寄存器。

这种做法可以省略地址字段，有利于缩短指令长度

> 只会出现在 1 地址指令和 0 地址指令中

### 间接寻址｜indirect addressing

指令中的地址字段（形式地址）不直接给出操作数地址，而是**指出有效地址所在的存储单元的地址**（即记录地址的地址）

有效地址 EA  =（A）（地址 A 中实际存放的内容（ 

查找地址 A，找到 A 中存放的内容 (A)，该内容才是真正的操作数有效地址(A)，然后再通过该地址查找到真正的操作数。可以嵌套寻找

> 举例：load（A）
>
> 将内存内容地址 A 指向累加寄存器的地址内容加载

![image-20220220165503948](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704498.png)

优点

- 更大的地址空间 

  对于一次间接寻址，如果地址的地址所在存储单元为 N 位字长，则寻址范围可达 $2^N$

缺点

- 需要两次（使用一次间接寻址）或多次 （嵌套多次间接寻址） 内存访问来查找操作数，速度较慢

### 寄存器寻址｜register addressing

指令中的地址字段（形式地址）直接给出了寄存器的编号，直接从寄存器中读/写操作数

有效地址：EA=R

**优点**

- 由于寄存器的数量有限，指令中仅需要一个较小的地址字段

- 不需要存储器访问，速度很快

可以把经常使用的变量或者计算的中间结果定义为寄存器变量，以加快访问。

![image-20211226193949572](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704501.png)

### 寄存器间接寻址｜register indirect addressing

与间接寻址类似，地址字段给出的是寄存器的编号，操作数的有效地址是寄存器里的内容

有效地址：EA=(R)（有效地址为 R 寄存器中存储的内容）

- 同样可以获得较大的地址空间
- ﻿﻿指令的执行仍需访存（先访问寄存器获得操作数地址，再访问该地址获得操作数）
- 寄存器间接寻址比间接寻址少一次存储器访问，比间接寻址更快。

![image-20211110104547873](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704502.png)

### 偏移寻址｜displacement addressing

偏移寻址是一种有力的寻址方式，结合了直接寻址和寄存器间接寻址

有效地址：<mark>EA=A+(R)</mark> 

在偏移寻址中，指令要求有两个地址字段表示一个操作数的地址，且两者可以有一个是隐式的。我们可以假设：

A = 偏移地址

R = 基址值

反之亦可。

![image-20211110104836847](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704503.png)

分为三种类型：相对寻址、基址寄存器寻址、变址寻址

#### 相对寻址

此时 R 是隐含的，其等于程序计数器，PC。因此这种方法又被称为 PC 相对寻址。

有效地址 EA = A +（PC） 

- A是地址字段的值，被看为是补码（可正可负）
- ﻿﻿有效地址是对当前指令地址（PC）的一个前后范围的偏移（由 A 决定）

即从 PC 指向的当前位置前/后 A 单元中获取操作数，常用于跳转到不固定的地址。

常用于转移类指令，基于局部性原理，跳转的指令和目前正在执行指令距离不远，那么使用相对寻址可以节省指令中地址码所需的位数

#### 基址寄存器寻址

用于 OS 的地址转换，**常常用于分页或分段后查找真正的物理地址**（参见操作系统第九章：虚拟内存）

有效地址 EA=A+ （R）

- ﻿A：偏移量，被认为是无符号数，即只能向后增加
- ﻿﻿R：基址，可以是显式/隐式的

R 可以指向内存某页的开始处，通过和 A 增加（页内偏移），计算出真正的物理地址

#### 变址｜Indexed Addressing

A=基址（一般固定）

R=displacement（偏移量，一般是无符号数）

有效地址：EA=A+（R）

这种方法相当于 A 和 R 的含义交换后的基址寄存器寻址，通常适用于数组或循环。

EA=A+（R），通过把 A 指向数组的起始地址，R++，可以依次得到数组中的所有内容，使得程序更简洁

![image-20211110105542137](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704504.png)

扩展：后变址和前变址

后变址：EA=(A)+(R)

有效地址是 A 的内容+ R 的内容的值，常用于访问具有固定格式的数据块，比如 PCB。

前变址：EA=(A+(R))

有效地址是 （A+R）地址的内容。可以用于构建多路转移表。

### 堆栈寻址

操作数（隐含的）放在栈顶，因此访问堆栈时，一般局限于栈顶。

SP 寄存器指向栈顶，因此对存储器中栈的访问实际属于寄存器间接寻址（取出 SP 存放的内容（栈顶地址），访问此地址，即可得到栈顶内容）

![image-20211226194752996](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704505.png)

### 总结

| 方式                                   | 算法                             | 主要优点                                         | 主要缺点                                               | 操作数位置                               | 应用                 |
| -------------------------------------- | -------------------------------- | ------------------------------------------------ | ------------------------------------------------------ | ---------------------------------------- | -------------------- |
| 立即寻址<br />**Immediate Addressing** | 操作数=A                         | 无存储器访问，速度更快                           | 操作数范围有限                                         | 操作数在指令中                           | 定义和使用常数       |
| 直接寻址<br />direct addressing        | 有效地址 （EA） = 地址字段 （A） | 只要求一次存储器访问无需额外计算就可得出有效地址 | 受限于地址字段长度，只能提供有限的地址空间             | 操作数在地址地段指向的地址中             |                      |
| 间接寻址<br />indirect addressing      | EA  =（A）                       | 更大的地址空间                                   | 速度较慢                                               | 操作数在地址地段指向的存储器中           | 中断服务程序入口寻找 |
| 寄存器寻址                             | EA=R                             | 无存储器访问                                     | 地址范围有限                                           | 操作数在地址地段指向的寄存器中           | 定义常用变量         |
| 寄存器间接寻址                         | EA=(R)                           | 访问一次存储器                                   | 只需要一次内存访问，却可以提供和间接寻址相同的地址空间 | 操作数在寄存器中存储的地址里             |                      |
| 偏移寻址displacement addressing        | <mark>EA=A+(R)</mark>            | 灵活                                             | 复杂                                                   | 操作数在基地址和偏移间接结合指向的地址中 | 分页或分段           |
| 栈寻址stack                            | EA=栈顶                          | 无存储器访问                                     | 应用有限                                               |                                          |                      |


## 指令格式

指令格式规定指令的样式以及其各个构成部分的具体含义

大多数的指令集使用不止一种指令格式

指令格式中必须定义如下内容：

- 指令长度  
- 操作码位数
- 地址码位数
- 地址码个数
- 寻址方式
- 指令字长和操作码的位数

### 指令长度

决定了汇编编程人员所看到的指令的丰富性和灵活度

影响因素：

> 内存大小 内存组织 总线结构 CPU 复杂性 CPU 速度

指令长度需在指令的强有力性和存储时节省空间之间进行权衡考虑

指令长度应当等于数据总线宽度或其整数倍数，这样可以在取指周期内取得整数条指令。

指令长度应当等于字符长度或定点数长度的整数倍，以便存放操作码和地址码

### 位分配

**对于一个给定的指令长度，显然要在操作码数目和寻址能力之间进行权衡**，决定操作码和地址码各自分配多少长度。

> 操作码越多，操作码字段越长，地址码就越少，寻址空间越小
>
> 操作码太少，操作种类就少，功能不全

解决方式：**使用变长的操作码**

- 指定一个最小操作码长度

- 对于某些长度更长的操作码，可以通过使用指令附加位的方法来指定附加的操作

- 只用于要求较少操作数及寻址方式较少的指令的情况

**使用可变长度的指令**

- 提供不同长度的各种指令格式

- 操作码长度不同

- 寻址方式可更加灵活

但是，CPU 结构会更加复杂，因为需要先判断指令长度，再针对性的进行译码。