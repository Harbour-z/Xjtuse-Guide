# 第十章 指令集：特征与功能

## KEY POINTS

1. 指令集设计需要考虑的重要方面有哪些
2. 指令的地址数量：4、3、2、1、0 地址指令中，每个地址的含义
3. 操作数的类型与机器指令的常见类型

> 易俊泉学长的原始笔记链接如下：
>
> [chapter10 指令集](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter10指令集.md)

## 机器指令特征

机器指令是指 CPU 能直接识别并执行的指令。机器指令是**二进制**编码的。

指令集（Instruction Set）CPU 能执行的所有机器指令的集合

- 指令集決定 CPU 所能完成的各项功能
- ﻿﻿指令集的格式和功能直接影响机器的硬件结构及机器的适用范围

比如，一个 CPU 中不存在浮点运算指令，那机器硬件上就无法处理浮点运算。

> 指令集属于计算机所谓的「体系结构」，即计算机中对程序员可见的特性，影响到程序逻辑的编写和执行。

为了方便识别与开发，开发人员会使用汇编码与机器码对应

### 机器指令要素

机器指令需要包含如下四个要素，才能让 CPU 正常执行：

**操作码** operation code：指令需要完成的操作

**源操作数引用** source operand reference：操作所需的输入

**结果操作数引用 **result operand reference：操作可能产生的结果的存放位置

**下一条指令引用** next instruction reference：执行当前指令以后去何处取下一条指令

> 这部分要素一般采用 PC 指定，或者由跳转（JMP）指令指定

源操作数和结果操作数可能位于的范围

- 主存或虚拟内存

- 处理器寄存器

  如果只有一个寄存器，引用可以是隐式的，不需要指明寄存器编号

  若有多个，需要指定寄存器唯一的的名字或编号

- 立即数：操作数被硬编码到指令中

- I/O 设备

  如果使用存储器映射 I/O 方式，形式上将会是另一个主存或虚存

![image-20211105103150013](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704491.png)

### 指令表示

每一条机器指令有一个位串表示，其各个部分对应了机器指令的*四要素*，格式如下：

![image-20211105103825116](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704493.png)

前四位代表*操作码*，4-10 位表示*源操作数*，10-16 位表示*目标操作数*。*下一条指令引用*一般由 PC 计数器完成，不需要在指令中携带。

为便于使用和记忆，普遍使用机器指令符号表示法

操作码可以用助记符表示，如`ADD：加`;`SUB：乘`

操作数也可以用符号表示，如`ADD R,Y`

### 指令类型

指令类型分为：

> 四类指令对应了第一章提到的计算机的四个基本功能

**数据处理**：算术和逻辑指令。这种指令主要由 ALU 执行

**数据存储**：存储器指令，控制寄存器和主存/存储器的交互

**数据传送**：I/O指令。如果 I/O 接口采用和存储器统一编址的方法，则这部分指令可以省略

**控制**：测试和转移指令。一般用于条件跳转（测试某个条件是否完成，如果是，则跳转到某处）

- ﻿﻿任何数据处理任务都可以通过上述指令进行表达
- ﻿﻿任何用高级语言编写的程序需要转换成上述机器指令才能执行

高级语言和机器语言的区别：

- ﻿高级语言使用变量，并以简明的代数形式来表达操作（因为面向人）
- ﻿机器语言是以涉及数据移入移出寄存器的基本形式来表达操作（因为面向机器）

### 地址数目

在上方的「指令表示」一节中可以看到，机器指令分为操作码和地址码两部分。

操作码用来指明该指令需要执行的操作。

地址码用来指出该指令的源操作数地址、结果操作数地址以及下一指令地址

- 地址可以是存储器地址、寄存器地址以及1/0设备地址

指令依据地址码所给出地址的个数可分为四地址指令、三地址指令、二地址指令、单
地址指令以及零地址指令

下面以以主存地址为例，分析指令的地址码字段

#### 4地址指令

![op1](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAM9Z6F2txE0Oml8VaGhyO6-mgzeWPsAAp0SAAK0lBBVj7yUsr2WTZE2BA.png)

包含四个地址：两个操作数地址+目标操作数地址+下一指令地址，是最全的一种指令

$A_1$ 和 $A_2$ 操作数进行 OP 操作后，存放数据到 $A_3$ 位置，下一指令的地址为 $A_4$。

- 简单直观，后续指令地址可以任意填写
- ﻿﻿但这种方式基本没有实施，因为地址码数量太多时，每个操作数地址长度都太短，支持的地址空间太小；此外，地址码太多还会导致访存次数太大。

#### 3地址指令

包含三个地址：两个源操作数地址+一个运算结果地址。

下一条指令地址被隐藏（由 PC 寄存器决定，不需要显式给出）

![23](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704484.png)

$A_1$ 和 $A_2$ 操作数进行 OP 操作后，存放数据到 $A_3$ 位置。

这种方法也不普遍，因为三个地址码仍然会导致可表示的地址空间太小。

好处：$A_1$，$A_2$ 操作数在完成指令后不会变化。但这其实并不是必要的，我们可以把运算结果存储在一个操作数中，形成二地址指令

#### 2地址指令

![21](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704486.png)

二地址指令存在三种：将结果操作数放到两个源操作数中，或者放到隐含的寄存器里。

- 前两种方式中一个地址既用于源操作数又用于结果操作数
- ﻿第三种方式隐藏了结果操作数地址，一般为某个寄存器
- ﻿﻿地址码数量减少，可扩大寻址范围

包含两个地址：两个源操作数地址。运算结果存储在其中一个操作数/某个不指明的寄存器中。

> :label: <mark>二地址指令有两个操作数，这些操作数并不一定都在主存中，往往有一个在通用寄存器中</mark>
>
> 二地址指令不会隐含一个操作数的地址，只会隐含结果的地址

#### 1地址指令

![21](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704487.png)

单地址指令分为上方两种情况。指明的地址 $A_1$ 和不指明的寄存器做 OP 操作后，存储到 $A_1$ 或者那个寄存器中。

隐含的操作数地址往往是一个寄存器，通常是累加器 AC。这种做法在早期机器中很普遍

也可能真的只需要一个操作数（比如 LOAD 读取存储器指令），目标位置是隐含的（AC）

#### 0地址指令

![image-20211105111548714](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704488.png)

零地址指令只给出操作码字段，主要包含以下两种情况：

1. 不需要操作数的指令，往往是控制 CPU 自身行为的指令。如空操作指令、停机指令、关中断指令等

2. 所有地址都被隐含了。常见于堆栈计算机中的零地址运算类指令。堆栈计算机中参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算的结果再隐含地压入堆栈中。

现代的计算机通常使用 2~3 地址指令

#### 取多少地址合适？

地址数目多：

- 指令功能相对强大，但同时指令也会更复杂。
- 为了提高速度，往往需要更多的寄存器（寄存器之间的操作更快） 
- 编写的程序总的指令条数更少（因为每条指令都更复杂）

地址数目少

- 指令比较简单，功能相对单一，速度快
- 单地址指令通常只有一个通用寄存器可以利用
- 同样任务，使用地址数目少的机器指令编写的程序总的指令条数更多，总的执行时间可能会更长

为了平衡这两方面的优点及灵活性的要求，大多数当代计算机采用了 2-3 地址指令的混合方式。比如，对算术逻辑运算使用 2 地址指令，对其他复杂指令使用 3 地址指令。

## 操作数的类型

机器指令可以操作的数据通常分为：

**地址**：一般是无符号整数

**数值**：包含二进制整数/二进制浮点数/十进制数

> 支持十进制数是为了方便人类阅读。一般计算机中使用 BCD 码表示十进制数，即 4 位二进制代码表示 1 位十进制数，4 位二进制代码仅在取 0000～1001 间有效。

**字符**：字符数据一般通过 ASCII/EBCDIC 等编码方式编码为二进制数后存储。

**逻辑数据**：包含位或标志和布尔类型的数据。实现上就是一位二进制数。

## 机器指令的类型

机器指令的操作码主要包含如下几种：

- 数据传送
- 算术运算
- ﻿﻿逻辑运算
- 转换
- I/O
- 系统控制
- 控制转移

下面具体介绍数据传送指令和算术运算指令。

### 数据传送 Data Transfer

这是最基础的机器指令，把操作数从源送到目的位置。

数据传送指令必须指明如下操作数（地址码）：

1. 源和目的的操作数位置必须指明

   可以位于寄存器，存储器或者栈顶中

2. 必须指明将要传送数据的长度

3. 必须为每个操作数指明寻址方式（这一项在任何指令中都需要指定）

> 常见数据传送指令：Move，Store，Load，Exchange:swap contents of source and destination，Clear : all 0，Set:   all 1，Push/pop
>

### 算术运算 Arithmetic

- 加，减，乘，除
  这些指令可能针对无符号整数、有符号整数，浮点数或压缩十进制数。
- ﻿﻿其他可能有的指令
   Increment (at+)
   Decrement (a--)
   Negate (-a)
   Absolute (lal)

### 逻辑运算 Logical

- 按位进行操作/布尔运算
- ﻿与，或，非，异或
- ﻿﻿测试，比较
- ﻿﻿设置控制变量
   设置控制保护、中断处理、时间控制等标志
- ﻿﻿移位

移位指令包含逻辑移位和算术移位。

逻辑移位（SHL，SHR）是指把数字向左/右移动相应位数，超出存储范围的数据直接丢弃，空余部分**固定使用 0 填充**。

逻辑移位常用于加速正整数乘/除 $2^n$ 的运算，或者解压压缩 BCD 码。

算术移位（SAL，SAR）是指把数字向左/右移动相应位数，超出存储范围的数据直接丢弃，左移时空余部分**固定使用 0 填充**，右移时空余部分使用**符号位填充**。

算术移位常用于对有符号数的乘2"以及除2的运算，以便提速

循环移位（ROL，ROR）是指把数字向左/右移动相应位数，移出范围的位填补到另一侧的空余部分，不会丢失数据。常用于加密算法。

![image-20211105113749610](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704489.png)



### 转换 Conversion

转换数据格式或者对数据格式进行操作。

比如：二进制-十进制转换；ASCII 码- EBCDIC 码的转换



### 输入/输出 I/O

可能是独立的指令（分离式I/O)，也可能通过数据传送指令完成 (存储映射式I/O)

独立指令包含：（仅在分离时 I/O 下有这些指令）：

输入/读 IN(51)

输出/写 OUT(51)

启动 I/O

测试 I/O

独立指令可能通过 CPU 执行，也可能被分离的控制器 ( DMA 或 I/O 通道这种能执行命令的 I/O 接口)来完成

### 系统控制 System Control

通常是特权指令，不允许用户直接执行。

### 控制转移 Transfer of Control 

分支/转移指令：

- 有条件（依据条件码，在某种条件下跳转）
- ﻿﻿无条件（遇到指令后，立刻跳转）
- ﻿﻿可以向前转移，也可以向后转移

跳步指令：包含一个隐含地址，﻿﻿隐含地址等于下一指令地址加上该地址的长度。其表示跳过下一条指令，直接从下下条指令开始执行。

**过程调用指令** Procedure Call Instruction

过程是一个自成一体的计算机程序，并能被一个更大的程序所调用。过程调用指令属于转移指令，可实现代码重用和任务分解。

过程调用指令包含两种指令：

- ﻿﻿调用指令：用于从当前程序位置转移至子程序的入口

  把 PC 从当前指令指向待跳转指令的入口

- ﻿返回指令：用于子程序执行完后重新返回到原程序的断点

  恢复 PC 指令

这两种指令必须一一对应。

![image-20211105114528397](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704494.png)

上图是一个过程调用指令的实例。跟随右图中的箭头，就可以看到指令执行的顺序，以及控制流是如何在多个函数之间来回跳转的。

可以从多个位置调用过程。过程内部还可以调用过程，这个调用不限于别的过程，还可以调用自己，而且允许过程嵌套到任一深度

- ﻿﻿过程嵌套就是指在过程调用中又发生了过程调用
- ﻿﻿过程调用自身称为递归

每一次调用必须要有对应的返回指令

实现返回指令，就需要保存待返回的地址。如何保存这个地址呢？一般有三种方法：

1. 寄存器
2. 被调用过程开始处
3. 栈顶

前两种方法不利于重入（递归调用）；因此，第三种方式（把返回地址放到栈顶）最为常用。

![image-20211105115211075](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704495.png)

上图描述了之前的调用实例中，如果在栈顶存放地址，栈会是什么样子的。

过程调用和中断的区别：

- 过程调用只需要保存 PC，其他内容不会切换因此不需要修改
- 中断需要保存当前程序在 CPU 中的所有信息：PC，PSW，寄存器等
- 过程调用的开销小于中断
