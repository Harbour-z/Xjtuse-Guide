# 内部存储器

> 易俊泉学长的原始笔记链接如下：
>
> [chapter05 内存](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter05内存.md)

## KEY POINTS

1. DRAM 和 SRAM 的概念与读写原理。二者哪个需要定期上电刷新？各自常用于构成什么？
2. 各种 ROM 的名称、定义及特性（是否可擦除？）
3. 存储器扩充设计，包含位扩展、字数扩展和字位双扩展。重点了解如何接线，译码器的使用。

## 半导体主存储器

### 组织

所有的半导体存储位元都有相似的性质：

呈现两种稳态(或半稳态)，分别代表二进制的1和0;；能够写入信息(至少一次)来设置状态;；能够读出状态信息。

![image-20211102142126381](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704145.png)

不论什么存储设备，一般都可以抽象为上面这张图片：位元一般具有三个功能端：选择端（Select）的输入决定当前要对哪个存储单元进行操作；控制端（Contorl）指明当前是读取还是写入。如果是读取，最后一端输出当前的值；如果是写，最后一端提供的信号决定此位元被写为 0 还是 1。

![image-20211102142641622](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704134.png)

### DRAM 与 SRAM

随机存取：通过编排的寻址逻辑，存储器的单个字直接被存取，不需要顺序访问。

**RAM**：随机存取存储器，可以方便的从存储器读取数据和向存储器写入新数据，且读写操作都是通过使用电信号来完成的。同时具有易失性，一旦断电，数据就会丢失。

> 其实上面的存储器（除了快闪存储器）都是 RAM（可随机存取的），但是因为历史原因，只有第一种存储器被称为 RAM，其他存储器都有自己的名字。

#### DRAM

**动态随机存储器（DRAM）**：通过电容充电来存储数据，一个半导体器件存储一位二进制，位元中的电容电荷的高低分别表示二进制的1、0.

> 尽管电容用于存储 1/0，但它还是个模拟设备。根据阈值大小，判断电容电荷量被视为 1 还是 0。

因为电容会漏电的趋势，因此 DRAM 需要周期性充电刷新，甚至在有电的时候也要充。

DRAM 的结构如下：地址线为 1 （有电压）时，说明当前操作此位元，此时晶体管（Transistor）导通，输出电压；否则晶体管断路，右侧的存储电容保持其电荷量。

一个 DRAM 单元只需要一个晶体管（三极管）和一个电容，相对 SRAM 便宜不少。

![image-20211225174203136](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704146.png)

##### 写操作

电压信号施加到位线上：高电压为 1，低电压为 0；然后一个信号施加到地址线使顶端导通，让地址线的电压和电容电压同步。

##### 读操作

当地址线被选中（加电压），晶体管导通，存储在电容上的电荷被送出到位线和读出放大器。读出放大器将此电容电压与一个参考值比较，确定位元保存的是 1 还是 0。位元读出放掉了电容上的电荷，需要重新存储（对电容重新充电）才算结束。

DRAM 比较慢，适用于容量较大，掉电内容消失的存储器，即主存

#### SRAM（Static RAM）

**静态随机存储器**：通过触发器存储数据，**不需要刷新充电**。每一位需要 6 位 MOS（6 个触发器），所以更复杂、更昂贵。

因为不用刷新，因此也更快，适用于cache

![image-20211225174218876](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704147.png)

此结构中寄存器的特征：

- 下方端口高电平时，左右两端口间导通
- 下方端口低电平时，左右两端口间相当于断路

#### 逻辑 0/1 的表达

逻辑 1：C1 高电位，C2 低电位，引发 T1,T4 关闭，T2,T3 打开，这种状态定义为逻辑 1

逻辑 0：C1 低电位，C2 高电位，引发 T2,T3 关闭，T1,T4 打开，这种状态定义为逻辑 0

> 即 C1 有电就是逻辑 1，C1 没电就是逻辑 0。

##### 读写操作

> 写操作：地址线取高电位，B 线设置为目标电位（0 - 低电平，1 - 高电平），位值的反施加到 B 非线
>
> 读操作：地址线高电位表示选择此位元，此时 T5、T6 同时导通，位值从 B 线读取（B 线内容和 C1 状态相同）

#### SRAM 与 DRAM 比较

**二者都不稳定**

都需要持续充电去保存数据

**动态**

更密集、更便宜、需要刷新、适用于更大的存储单元（因为刷新成本固定，容量越大，平均每个单位刷新成本越低）

**静态**

更快，适用于缓存

### ROM 类型

ROM，即只读存储器，含有不能改变的永久性数据，掉电以后数据还在。

有一个 MOS 管代表"1"，没有 MOS 管代表"0"。

这种存储器的数据是由硬件决定的，在制造时就已经确定，无法再被更改。

存在两个问题

> 固化数据需要较大的固化成本，不管是一片还是上千片；不过，每增加一片芯片，生产成本增加很少。1 块 ROM 芯片和相同功能的 100 块 ROM 芯片成本几乎是相同的。
>
> 无出错机会，一位出错，整批芯片都没用了

常见用于嵌入式编程，超级底层的库，BIOS 表等……

#### PROM

即**可编程ROM**，也只能写入一次，但是不需要在生产时就完成写入，可以在使用时再写入。

需要用特殊设备来完成写("编程")，灵活性高，但是单块价格也高

内部通过熔丝进行存储。熔丝熔断代表此位元为 0，否则为 1。

#### EPROM

**光可擦除只读存储器**。写入操作前，需要让芯片暴露在紫外线辐照下使所有的存储位元都被擦除，还原为初始状态，可重复进行，需要20分钟以上。

可以修改多次，也能长久保存出局，更贵，集成度较低。更改内容时，需要清除整块存储器的内容。

#### EEPROM

**电可擦除只读存储器**。只需要修改想要改的部分，不用全部都初始化。写操作比读操作长的多，而且**更贵**

#### 快闪存储器（Flash memory）

使用电擦除技术，价格与功能介于 EPROM 与 EEPROM 之间

能够擦除存储器中的某些**块**，而不是整块芯片。既能用于内部存储器，也能用于外部存储器。

> 它也叫做闪存，因为其改写速度相对于 EPROM 来说「快如闪电」包括 NOR 与 NAND，NAND 内存更适合外部存储器，用于 USB 闪存驱动器、存储卡，以及固态磁盘(SSD)

![image-20211015105816853](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704136.png)

> 注：一众 EPROM、EEPROM 这些存储器虽然叫做 ROM，但实际上是 Read-mostly memory 而不是 Read-only memory。

NOR Flash：

- 随机读取速度快，但写入速度慢
- 可以按照 1byte 为单位读
- 适合用于嵌入式系统中，或存储内容基本不变的数据

NAND Flash：

- 随机写入速度快
- 需要成块阅读（一般最小 16/32 byte）
- 单位成本更低，适合作为外部存储器（U 盘/ SSD）

NOR Flash 和 NAND Flash 在存储金字塔中，大概在主存和机械硬盘（HDD）之间（即速度和存储成本都在二者之间）。

### 芯片逻辑

芯片逻辑是指如何合理的组织和封装位元，使得读写性能最好。芯片逻辑关注的核心点是**存储字长**，即。虽然大部分情况下存储字长=机器字长，但它们也不必须相等。

> 回忆：机器字长是指 CPU 内部运算支持的最长位数

存储字长有几种常见情况：

- 阵列中单元的物理排列与逻辑排列相同（存储字长=机器字长）

  例如，16M = 1M * 16bit（1M 个可寻址单元，每个单元大小 16bit）

- 字长为一个 bit

  例如，16M = 16M * 1bit（16M 个可寻址单元，每个单元大小 1bit）

半导体存储器也是封装的芯片，每块芯片包含一组存储位元阵列

![image-20211015112343148](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704137.png)

存储阵列是 2048 * 2048 大小，四层相同的位元叠在一起。访问地址为二维，存在行地址和列地址；每次访问时，提取出这个位置所有 4bit 数据并同时输出。

地址输入是 11 位二进制数，$2^{11}=2048$ 可表示一行/一列的所有单元；有一个标志位决定当前地址信号表示行地址还是列地址。

这里存在刷新电路，是因为 DRAM 是电容做的，有泄漏问题，读取完后必须重新充电。

### 芯片封装

![image-20211102144910639](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704148.png)

NC 引脚：什么都不是，为了让芯片两侧引脚数量对称。

### 模块组织与芯片扩展

以下是一个 256KB * 1bit 的芯片。通过规格信息，我们可以得知：

- 可寻址单元为 $2^{18}$ 个，故总共需要 18 根地址线
- 行/列各有 9 根地址线

现在，我们想把它升级为 256k * 8bit 的大小，该怎么做呢？

我们可以放置 8 块相同的芯片，「叠在一起」，每次给出访问地址时，同时访问 8 个芯片上的同一地址，凑出来 8 位数据。

访问地址的高 9 位应当是行地址，低 9 位是列地址，这样地址号连续的内存数据在物理上才是连续存储的。

![image-20211015113208887](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704138.png)

#### 存储器扩充（考研点)

1. 1kx4 -> 1kx8  字长扩展（位扩展）

   字（寻址单元数）满足要求，但字长不满足要求。我们需要用多块已有的芯片，拼接出对应的大小。

![image-20211015114337344](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704139.png)

> 这张图片有点糊，地址线 A0-A9 一共十位,内容输出线原先为 D0-D4 4位，现在需要 D0-D7 8位
> 

   外部输出线需要 8 位，而之前只有 4 位，因此：地址线数量不变，**同时接入两个芯片**。数据线数量增加，**错开连接**，即第一个芯片的输出接 D0-D3，第二个芯片的输出接 D4-D7，二者的使能信号并接到外部控制线上。

这种拼接方式以后称为*串联*。

需要芯片量 = 新字长/旧字长。比如，4 位扩展到 32 位，就需要 8 个芯片。

2. 1kx8-> 2kx8 字数扩展

   > 这种拼接方法类似于数电里的两个 2-4 译码器拼接成 3-8 译码器

   字长（每个寻址单元大小）满足要求，但字（寻址单元数）不满足要求

   需要芯片量 = 新字数/旧字数。比如，1k 扩展到 8k，就需要 8 个芯片。在这个例子中，需要两个芯片。

   给定一个地址，这个地址必然在两个芯片上的一个中，不可能同时在两个里。因此，可以把地址线除最高位外的线同时挂接到两个芯片的地址接口上，最高位挂接到片选接口上（最高位两个芯片之间需要加非门，保证无论最高位是什么输入，两个芯片只有一个被激活）

   为什么不用地址最低位做片选端呢？因为使用最高位可以保证相邻内存地址物理意义上在相同芯片上连续。如果使用最低位做片选，两个连续的地址一定属于两块不同芯片，对猝发式访问（读取一个连续的块）很不友好

   如果需要扩展 4 倍的话，可以使用 2-4 译码器，把地址线高两位接 2 端输入，4 端输出分别接到四个片选端口上。倍数更大时同理。

   > 两个芯片数据线接法相同，没有要特别注意的。

![](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704141.png)

3. 1kx4-> 4kx8 字位双扩展

   我们需要将 1kx4 的芯片组合，扩展为 4kx8 的存储器。放大倍数为 (4 \* 8) / (1 \* 4) = 8 倍，即需要 8 块芯片。

   在同时需要扩展字数和字长时，最好先改变字长，再改变字数，即先 1kx4->1kx8 再 1kx8->4kx8

   具体扩展字长和扩展字数的方法请见上两种情况。

![image-20211015114901716](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704143.png)

2-4译码器保证了每一次只有一个芯片有效

##### 存储器与内存的连接

存储器的常见引脚（用于画存储器-内存链接示意图）：

- MREQ（存储访问允许）：当前选择存储器还是 I/O（这个标志位是因为 I/O 和存储器可能统一编址，因此使用此标志位指示存储器是否需要操作）
- R/W非：当前模式为读取/写入（低电平：读 高电平：写）
- A0-An：地址输入线
- D0-Dn：数据输入/输出线

解题过程

1. 正确选择芯片类型和编号

> ROM用于系统区域
>
> RAM用于用户区域
> 
2. 地址线连接
>
> CPU 的地址行通常比内存的多
>
> 低位 = 低位
> 
> 用于 CS 的高位
> 

3.  CPU 数据线连接
>
> CPU 的数据线必须等于内存的数据位，如有必要，芯片位将放大
>
4. 连接命令线
>
> 读/写行与内存行直接连接 CS 与 MREQ 和 CPU 的高地址位相连 可使用逻辑电路，如解码器

##### CPU-存储器举例

Suppose CPU has 16 address lines, 8 data lines. MREQ is used for access memory control, WR is read/write cont

•1Kx4 RAM; 4K x8 RAM; 8K x8 RAM;

•2K x8 ROM; 4K x8 ROM; 8K x8 ROM;

•74LS138 decoder and all kinds of gates, as figure.（74LS138 为一种 3-8 译码器）

•Please draw the diagram of CPU connecting memory, conditions:

1. 6000H--67FFH is system area; 6800H--6BFFH is user area;

2. select reasonable chips, how many chips used, respectively？

由于题目给出了系统区（ROM）和 用户区（RAM）的地址范围，可以通过减法算出两部分的容量。

由于 CPU 地址线可能包含 I/O 接口，不一定全留给 RAM/ROM，不能借此算出存储器需要的总容量；

> 题目没给出其他能确定存储器容量的信息的话，就别用 CPU 数据线/地址线长度算

由于系统有 8 根数据线，因此存储字长应当是 8 位

![image-20211102150425367](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704151.png) 

上方做片选：选择需要的 RAM 和 ROM，计算其地址线/数据线长度，考虑 11/10 位地址如何接到 16 位的外部地址线上。在这里，ROM 和系统数据线长度都是 8 位，RAM 数据线 4 位，ROM 地址线长 11 位，RAM 地址线长 10 位，外部地址线长 16 位。

![image-20211102150446877](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704152.png) 

这里，我们要确定片选地址线：哪个位置的地址用于区分 RAM 和 ROM？由于我们的材料是 3-8 译码器（而不是想象中的 1-2 译码器），需要选择三位地址线作为输入，为了方便起见，就选择最低位能用的 A11，A12，A13。（A10 地址位被 ROM 占用了）。我们规定 100 代表访问 ROM，101 代表访问 RAM（这也是随便规定的）

![image-20211020102942584](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704153.png)

之后，我们还剩 A14、A15 两个地址线没接，它们不需要用于区分地址，不妨设置为 A15A14=01 时访问这些存储器，其他时刻都不管。因此把 A15 接 3-8 译码器的高有效使能端，A14 接低有效使能端。

MREQ 正好接到 3-8 译码器剩余的一个低有效使能端（MREQ 低电平表示访问存储器）

注意上方图中 RAM 片的使能是 A10 和 3-8 译码器输出的与，表示当前选择访问 RAM 且 A10 选择对应的 RAM 片后才访问对应芯片。

### 纠错

半导体是有使用寿命的，因此由半导体构成的存储系统在极端情况下工作时会出差错

硬故障 hard failure：永久性的物理故障（比如主控烧了）

软差错 soft error：随机非破坏性事件（比如随机 0-1 翻转），可以由电源问题或者 *α* 粒子引起——可以通过海明码解决，检查 2 位纠正 1 位

### 高级 DRAM 组织

以下是一些对 DRAM 存储器的改进：

#### 同步 DRAM(SDARM)

传统的 DRAM 是异步的，而 SDRAM 通过外部的时钟信号实现同步

由于 SDRAM 会及时与系统时钟移动数据，CPU 知道数据何时可以准备就绪，CPU不必等待 DRAM 完成操作，由于 latch(插销)它可以做别的事情

> 比如 SDRAM 告诉 CPU 需要 50ns 才能取完数据，那么 CPU 就用这空闲的 5 个时钟周期干别的事情，过一段时间再回来读取，不需要像异步通信一样一直等待 SDRAM 回传数据。

猝发方式(burst mode)允许 SDRAM 在收到一个地址时，一次性传输地址所在的一个数据块（多个字节的数据）

#### Rambus DRAM

使用异步的面向块的协议来传送地址信息和控制信息

成本较高

#### DDR DRAM

SDRAM 受限于每个时钟周期仅能发生送一次数据到 CPU。DDR DRAM 即双速率 SDRAM，能每个时钟周期发送两次数据