

# 第十五章 控制单元操作

## KEY POINTS

1. 控制器的任务有什么，什么是微操作，划分的原则是什么
2. 指令周期中，各个子周期涉及的微操作有哪些，如何实现？
3. ICC 是什么，有什么作用
4. 控制器的主要任务，ALU 中 YZ 寄存器的作用有什么

> 易俊泉学长的原始笔记链接如下：
>
> [chapter15 控制器操作](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter15控制器操作.md)

控制器负责向处理器外部发出控制信号，从而控制与存储器或 I/O 模块间的数据交换；控制器还需要向处理器内部发送控制信号，以在寄存器间移动数据，并引发ALU完成指定功能以及其他内部调整操作。控制器的输入包括指令寄存器、标志和来自外部的控制信号(例如中断信号等)，输出为操作各个门的信号。

## 微操作

**微操作 micro-operation**：每个指令周期由若干子周期组成，每个子周期包含若干小的步骤，每个步骤都涉及存储器和啜泣i，人们就把这些步骤称为微操作

**微操作是 CPU 最基本的、最原子的操作。**

![image-20211124114738784](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704541.png)



接下来，我们看看指令四个周期（取指、间指、执行、中断）周期中都分别包含哪些微操作。

### 取指周期

取指周期需要完成的工作较为固定，其**涉及的微操作**如下：

:one: 从PC中取出要执行指令的地址送到MAR

:two: MAR将地址送到地址总线

:three: 控制单元CU向内存发送读命令Read信号，启动内存读操作

:four: 内存将读到的结果放到数据总线上，放到 MBR

:five: 将MBR中的内容再传送给IR，MBR变得空闲，可继续为之后的数据存取服务

:six: 同时 PC +1

（PC + 1 可以和任何步骤同时进行）

**符号化表示**

> ![image-20211227120136938](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704543.png)

tx 代表一拍，则有两种分法：PC 放到第二拍或者第三拍。这其实不太重要，PC 放到哪里 +1 都可以

![image-20211227120158046](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704544.png)

微操作的分组必须遵守下面两个简单的原则:

:one: **事件的流动顺序必须是恰当的**。比如，(MAR←(PC)) 必须先于(MBR←内存)，因为内存读操作要使用 MAR 中的地址。

:two: **必须避免冲突**。不要试图在一个时间单位里去读、写同-一个寄存器，否则结果是不可预料的。例如，(MBR←内存) 和 (IR←MBR) 这两个微操作不应同时进行

> 此外，PC <- (PC + 1) 涉及到加法，因此需要 ALU 介入，可能需要更多的微操作才能完成。

### 间接周期

目的：通过操作数的形式地址，找到操作数的实际地址。

> 一个子周期的具体微操作实现可能不同，但只要都达到了这个周期的目的，就都是正确的。

取到指令以后，下一步就是取源操作数，若指令是间接寻址，则存在一个间接周期

> $t_1:   MAR ←(IR_{address}) - address\ field\ of\ IR$
>
> $t_2:   R ← 1(发读命令), MBR ← (memory)$ 
>
> $t_3:   IR_{address} ← MBR$

t3 微操作大部分时候是不需要的，因为使用间接寻址通常就是因为实际地址很长，放不到 IR 中；那么 MBR 中的操作数真实地址可能在 IR 中放不下。

操作数的实际地址可以直接放在 MBR 里，等执行周期直接发给 MAR 取数据就行了。

原本 IR 存的是间接地址，经过间接周期，存的就是直接地址

### 中断周期

目的：保存当前寄存器的值，将 PC 指向中断服务例程的首地址。

```c
t1: MBR ← (PC) // 存储 PC 指针，保存现场
t2: MAR ← 保存断点的内存地址
	PC ← 中断服务程序首地址 // 地址从中断向量表中提取
t3: W ← 1, memory ← (MBR) // MBR 存储了之前的 PC 指针，现在要把这个指针放到内存中
```

:warning: 注意，保存各个通用寄存器的内容是由中断处理程序做的，不属于中断周期的微操作，中断周期结束，CPU就为执行中断服务程序中的指令做好了准备

### 执行周期

执行周期根据指令不同、指令集不同，微操作存在很大的差异。我们只以几个常见的场景为例，讲解它们包含的微操作。

首先考虑 ADD R1,X，它将存储器 X 的内容和 R1 相加，结果存放到寄存器 R1，该加法指令可能产生如下的微操作序列：

> $t_1:   MAR ←(IR_{address}) $ // 读取 IR 的地址码部分（X 的地址）将其送入 MAR
>
> $t_2: MBR ← (memory)$  // 读取 X 地址处的内容
>
> $t_3:   R_1 ← R_1+(MBR)$ // 执行加法，并且保存到 R1 中。R1 是寄存器，因此不需要访问内存取操作数。

再来看更复杂 的ISZ X (自增，如果结果为0则跳步),表示先对内存地址为 X 的内容加 1，再将结果存入 X 地址，同时如果 +1 后的结果为 0，则跳过下一条指令，继续从第三条指令执行

> $t_1:   MAR ←(IR_{address}) $ // 取 X 地址的值的第一步：将其地址赋给 MAR
>
> $t_2:  MBR ← (memory)$  // 从内存中读取 X 的内容，放到 MBR 中
>
> $t_3:   MBR ← 1+(MBR)$ // X 自增
>
> $t_4: W \leftarrow 1(发送写命令)，memory \leftarrow (MBR)$
> $  if(MBR)==0\ then\ PC \leftarrow (PC)+I$
>
> MAR 的内容一直是 X 的地址没有变，因此直接发送写入命令，把 X 自增后的结果放入内存即可，不用从 IR 再读取一次 X 的地址放到 MAR 中。
>
> 同理，既然 MBR 已经存放了 X+1 的值，就不用从内存读回了，直接比较 MBR==0，如果满足则跳步（PC+=1）
>
> 微操作生成的原则就是：操作越少越好。如果有某些灵活的方法可以减小微操作，都可以使用。

最后来看子程序调用指令，转移并保存地址指令 BSA  X
把 BSA 指令后下一指令地址存入地址为 X 的内存地址，同时程序从 X＋I 处开始继续执行，用于**子程序调用**

每个 tx 段中的几条微操作都是同时执行的。

> $t_1:   MAR ←(IR_{address}) $
> 		$MBR \leftarrow (PC)$
>
> 读取 X 的地址到 MAR 中，同时 PC 进入 MBR，准备写入到 X 位置
>
> $t_2:   W ← 1,  (memory) ← (MBR)$ 
> 		$PC \leftarrow (IR_{address})$
>
> 把 MBR（存储了 PC 的值）写入 X 位置，同时把 IR 的地址码部分赋值给 PC（IR 存的是 X 的地址），此时下一条指令会从 X 地址处执行
>
> $t_3:   PC ← (PC)+I$
>
> PC +=1，这样下一条指令就从 X+1 地址处开始执行了。

指令开始时 PC 中的地址是下一条指令的地址，他被保存在 IR 指定的地址位置（X）中，此后，PC 地址变为 X，且再递增1，以提供下一指令周期的指令地址

### 指令周期

CPU 怎么知道自己处于哪个执行周期？

为区分CPU处于哪个周期，设置有2位的新寄存器，称为指令周期代码 **Instruction Cycle Code ICC**
`00:取指   	01：间接	10：执行	11：中断`

> 下面是一张状态机图，展示了 ICC 在何种条件下，会在哪些值之间相互转移。

![image-20211126103832963](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704545.png)



## 处理器控制

微操作主要包含如下分类：

- 数据传输

  :one:在寄存器之间传送数据。

  :two:将数据由寄存器传送到外部接口( 如系统总线)。（从寄存器写入数据到主存）

  :three:将数据由外部接口传送到寄存器。（从主存读取数据到寄存器）​

- 计算功能

  :four:将寄存器作为输人、输出，完成算术或逻辑运算。

控制器主要完成两项基本任务

- 排序( sequencing):根据正被执行的程序，控制器使 CPU 以恰当的顺一步步通过一系列微操作。

  > 排序的两个原则在上面已经提到过：流动顺序恰当，避免冲突。

- 执行(execution): 控制器控制微操作的执行

控制器实现这些功能的关键是使用**控制信号**。

### 控制信号

控制信号主要包含如下内容：

输入类信号包括：时钟（比如计组第一次实验由 4 个触发器实现的四阶段时钟信号）、各种标志 flag、指令寄存器、来自控制总线的控制信号（控制总线是否传输了中断信号）

输出包含：

- 控制 CPU 的信号

  在寄存器间移动数据；利用 ALU 做某个运算

- 控制总线的控制信号

  从内存读写数据，从 I/O 模块读写数据等信号

![image-20211126105359205](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704546.png)

### 控制信号举例

我们通过一个具体的例子，检查一个需求如何生成其微信号。

![image-20211126105735679](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704547.png)

只要我们管理好「门」（数据执行时的圈，即允许/拒绝数据通信的屏障），就可以正确的让 CU 控制处理器执行操作。

![image-20211126111442423](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704549.png)

上图中表示了取指、间指、中断周期中的微指令如何通过开关控制信号实现。

### 处理器内部的组织

CPU 存在**内部总线**，ALU 和所有的 CPU 寄存器都连接到单一的内部总线上

> 因此，可能出现总线冲突问题。

![image-20211126112510825](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704550.png)

ALU 部分新增了两个寄存器，**分别标记为 Y 和 Z，两个操作数来的时候，将其中一个通过 Y 进行暂存。**

ALU 是一个组合逻辑电路，其内部无存储电路。这样，当控制信号激活 ALU 的某个功能时，ALU 输入通过 ALU的组合逻辑电路被转换为 ALU 的输出。因此，ALU 的输出不能直接连到内部总线上（时钟不同步），因为这个输出会又反馈为输入。为此，**寄存器 z 提供了这个输出的暂时存储**

将存储器的值加到AC的操作有如下步骤：![image-20211126113440247](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704542.png)

> 以下内容讲的很快，大概不太重要

输出控制信号是输入控制信号的函数。我们可以根据当前处于哪个执行周期（ICC 输入信号），控制之前图中提到的各个数据门是否开启（输出信号）。二者之间的关系可以通过布尔表达式表示。

这种 CU 设计称为「硬编码」方法。比如：

![image-20241118173242488](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AANAZ6F60hqsDPvbKpKxrIkjRWOqZGsAAqgSAAK0lBBVyMFNW4gx30U2BA.png)

根据此表中的信息：只有取指周期和间指周期中，C5 才会被使用，设计 C5 和输入信号（ICC）之间的函数：

![image-20241118173334967](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AANBZ6F61FQ9ie2OtKz9xtqM2IV8zNsAAqkSAAK0lBBV3b31NtyXSP42BA.png)

但是，硬件电路常常过于复杂，如果设计时出现了错误，很难找到哪里出现了错误；而且，如果要修改部分函数关系，就需要修改硬件设计，非常的麻烦。