# 面向对象设计与 UML 建模

本部分内容从泉佬的复习笔记改进而来，原始笔记链接如下：

[系统设计与分析复习](https://github.com/yijunquan-afk/XJTUSE-NOTES/blob/master/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0.md)

本部分内容较多，但实际上并不是所有内容都会考察。重点内容如下：

1. 几种图的画法：用例图、活动图、顺序图（时序图）必考；其他图（状态机图）可能考察。
2. 面向对象的五大设计原则（在最后的部分）非常重要，需要记住原则的名称，理解每条原则的含义。

## 大作业的注意事项

**数据流图的用例图的转换原则**：

1. 将数据流图中的外部实体转换为一个参与者

2. 将数据流图中的一个加工过程转换为一个用例

3. 用例图更强调用例（加工过程）之间的关系，而非其执行流程，因此用例图中的关系并不对应数据流图中数据流；二者是不相同的。

   可以利用数据流图中数据流的内容和其指向的加工，得到用例图中的用例。比如，第一次数据流图中系办和注册、资格管理、奖励管理、成绩管理间存在数据流，因此可以认为用例图中系办与资格管理、奖励管理、成绩管理三个用例相关联；外部实体到加工间的数据流「奖励统计」、「奖励凭证」等内容可以作为单独的用例，扩展「奖励管理」用例。

**用例图关系的编写**

泛化关系和扩展关系的区别：

- 泛化类似面向对象的继承，泛化箭头指向的对象为「父类」，一般没有具体功能，只是作为一个「接口」，规定其泛化用例的共性；泛化箭头发出的对象为「子类」，具有实际功能
- 扩展是发出者在接受者基础上进行改造，实现更多功能的关系。发出者和接受者本身都是存在具体功能，可以执行的用例。

包含关系一般用在「A 是 B 的一部分」这一情况下，A 不能完整实现 B 的功能，B 也不能完整实现 A 的功能；而泛化和扩展中，箭头的发出者都是能完整实现接收者具有的功能的。

**用例图基本事件流的写法**

注意事件流要写**一个参与者和系统模块（用例）的关联**，而不是写**多个参与者之间的互动**。

比如「资格审查」应该写系办和教学管理系统的互动，而不是系办和学生之间的关系和互动。

- 参与者：和用例相关的参与者/外部实体
- 前置条件：系统需要处于 xx 界面
- 后置条件：完成 xxx （这个比较水）
- 基本事件流：画个表，分为参与者动作-系统响应两部分。参与者每次进行一个动作，系统就进行一个响应。
- 扩展事件流：在基本事件流中，如果出现某些意外情况（比如用户输错了密码），系统该做什么。（提醒用户？拒绝用户使用？重新进行此步骤？）

时间流决定了后面活动图的绘制；基本事件流过程可以想象着编一编（比如注册的事件流大概就包含取昵称、密码，进行手机验证；资格审查时间流大概包含列出请求，点一个请求，给出详细信息……）

**用例图转活动图**

每个用例的基本事件流可以被转化为一张活动图，其中每个事件步骤可以转化为一个活动。

活动图主要包含如下组成部分：

1. 泳道：区分当前活动属于哪个对象范围，在图中表示为一条竖直的分割线
2. 活动：在上面的用例事件流描述中，事件的每个步骤都可以转换为一个活动
3. 对象流：活动之间交换的信息。由于下方绘制的活动图中，每个活动图只包含一个流程，且多个活动间没有并发执行的内容，因此不涉及对象流
4. 发送信号和接收信号：并发执行的活动之间的沟通渠道。由于下方活动图中不涉及并发，同样不涉及这两部分。
5. 分叉：根据条件，控制活动执行的分支。一般涉及条件的用例图事件可以被转化为一个分叉。

活动图中的注意事项：

- 分支需要检查条件不能写在菱形里头，需要写在连接到菱形前的一个活动中；活动的两个分叉中写分支检查条件在哪种情况下才进入此分支。

### 设计理念

此部分 UML 图（用例图、活动图、时序图等）在设计时可能有多种方法。只要你的设计是清晰有效的，且没有事实性的错误（比如违反了面向对象五大设计原则），就是正确的。

## 面向对象设计模式



[![image-20211219211705654](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOAZ6RvQmc1nU8kSsumGAf0QjrE7CoAAuYUAAIHrilVwT1JI32fX2g2BA.png)](https://camo.githubusercontent.com/cfc9f66452a12b6e9972d82b8a7de7c457b51fbc5a4d4c6d94beb9542415b420/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393231313730353635342e706e67)

面向对象的核心是抽象；其三个特征是封装、继承和多态，具体定义可以去看原神的课（

消息是面向对象数据通讯的基本单元。消息具有「接受者」和「内容」两个属性，对应到代码实现中就是「对象被调用的方法」和「调用参数」。

通过封装，多个对象之间通过消息进行对话；调用其他对象的方法就是向那个对象传递一个消息。

面向对象软件开发的核心思想就是**高内聚（封装）和低耦合（消息驱动）**，使用简洁的接口拼合简单的部件

对象间依靠相互发送消息或响应消息实现通信；可以说， **消息是驱动面向对象程序运转的源泉。**

消息的三个性质:

> (1) 同一个对象可以接收不同形式的多个消息，作出不同的响应; 
>
> (2) 相同形式的消息可以传递给不同的对象，所作出的响应可以是不同的;
>
>  (3) 接收对象对消息的响应并不是必须的，对象可以响应消息，也可以不响应。

UML 图之间的关联：

类（类图）-> 对象 -> 用例（用例图）-> 用例执行流程（流程图）

### 类之间的主要关系

类之间主要存在的关系：依赖、关联、聚合、组合、实现 和泛化。

[![image-20211219214042093](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOBZ6RvTxzOvIF3Slq-LtSwlAZsNakAAugUAAIHrilVzzoIpPUabZY2BA.png)

泛化：又称为继承关系，

实现：Object 2 是虚的，没有实现和操作，无法具体化；Object 4 是实的，可以实现 Object 2。

依赖：「面向对象中最不愿意有的关系」（破坏封装）一个对象中的方法无法自己完成任务，需要调用其他类对象的方法才能完成。即 A 中需要存在一个 B 类的对象，才能完成操作。

关联：Object 5 主动向 Object 2 发送消息，从而产生了关联；（Object 2 也可以反过来给 5 发送消息，从而产生双向关联）

组合：Object 6 和 Object 2 强关联，缺少了 2，6 就活不下去

[![image-20211219214642390](https://camo.githubusercontent.com/00bcdd04601f7ffd4856c4c2730c68f21584882dcb3c87082ac685c044c45607/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393231343634323339302e706e67)](https://camo.githubusercontent.com/00bcdd04601f7ffd4856c4c2730c68f21584882dcb3c87082ac685c044c45607/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393231343634323339302e706e67)

[![image-20211219214924191](https://camo.githubusercontent.com/d00ec47b1c2a5a13525ba8a39929be3589e7982b72b8a6d83d6695594ed492a4/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393231343932343139312e706e67)](https://camo.githubusercontent.com/d00ec47b1c2a5a13525ba8a39929be3589e7982b72b8a6d83d6695594ed492a4/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393231343932343139312e706e67)

类之间的关联程度：泛化=实现>组合>聚合>关联

依赖是特殊的关联关系，大家都不愿意看到它。

### UML 的三个模型

> UML 推荐工具：StarUML, GitHub 上可以搜到破解+汉化补丁

UML 的三个模型：功能模型、静态模型、动态模型

[![image-20211219220348542](https://camo.githubusercontent.com/63839425508f7f3701f3ae4f79d892e0925c7ef212685bd581dde20a4900d385/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232303334383534322e706e67)](https://camo.githubusercontent.com/63839425508f7f3701f3ae4f79d892e0925c7ef212685bd581dde20a4900d385/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232303334383534322e706e67)

主动对象：主动向其他对象发起请求（消息）的对象（外部实体一般都是主动对象）

被动对象：接受其他对象消息的对象

数据库不属于数据流图边界内部内容，而是一个外部实体；内部内容和数据库这个外部实体有数据查询关联。

## 常见的 UML 图

### 用例图

用例图是一种特殊的 UML 图。

用例图包含三部分：**用例 use case 、参与者 actor 和关系 relationship**

用例图是被称为参与者的外部用户所能观察到的系统功能的模型图

用例图列出系统中的用例和系统外的参与者，并显示哪个参与者参与了哪个用例的执行

用例图多用于静态建模阶段(主要是业务建模和需求建模)。

**关系（Relationship）包含：泛化、扩展、包含、关联**

[![img](https://camo.githubusercontent.com/8e4cc4dfe969949b6cefa585c9ba6d7141196a5333d87861382d599c3155c9d7/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f2545352541442541362545372542312538442545372539342541382545342542452538422545352539422542452e706e67)](https://camo.githubusercontent.com/8e4cc4dfe969949b6cefa585c9ba6d7141196a5333d87861382d599c3155c9d7/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f2545352541442541362545372542312538442545372539342541382545342542452538422545352539422542452e706e67)

#### 关联

表示谁启动用例，是一个单向的关系

表示参与者与用例之间的通信，任何一方都可发送或接受消息。

#### 包含

一般只有两种情况下会出现包含关系：

包含关系表示两个用例之间不可或缺的依赖关系。一般这种依赖关系仅会在如下情况中出现：

- 一个方法被拿出来组成用例，以便重用。此时被包含的用例是个方法（这种方式称为组件化）

- 一个用例太复杂了，为了降低复杂性，拆分成了两部分，一部分包含另一部分

包含是两个用例之间的关系。

- 当多个用例需要用到同一段行为时,可以把这段共同的行为单独抽象成为一个用例,然后让其他的用例来包含这一用例,从而避免在多个用例中重复描述同一段行为,也可以防止该段行为在多个用例中的描述出现不一致性。当需要修改这段公共的需求时,也只需要修改一个用例,避免同时修改多个用例而产生的不一致性和重复性工作。
- 用例 A 包含 B,将 A 称为基用例,B 称为被包含用例（Inclusion Use Case）。包含关系表示基用例会用到被包含用例。
- 包含关系用虚线加上箭头来表示。基用例被连接在箭头的尾部,箭头指向被包含用例,在虚线处添加一个<< include >>标签以表示包含关系,如图 所示。

[![image-20211219223855295](https://camo.githubusercontent.com/5e7ce96eacd196ed8f1e53adb1281e22579e896f3ef35d6038237c0d3b3545a2/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232333835353239352e706e67)](https://camo.githubusercontent.com/5e7ce96eacd196ed8f1e53adb1281e22579e896f3ef35d6038237c0d3b3545a2/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232333835353239352e706e67)

在 PPS 项目中，选择产品状态（Choose Product Condition）会在许多场合下发生，在创建销售订单和创建询价单中选择产品状态都是必不可少的活动,所以把选择产品状态作为一个被包含的用例插入到 Create Order 和 Create Enquiry 用例中，如果需要改动选择产品状态用例,则不用对每一个用例都做相应修改,这样就提高了用例模型的可维护性。

#### 泛化

泛化关系是两个用例或两个参与者之间的关系。当多个用例共同拥有一种类似的结构和行为的时候,可以将它们的共性抽象为父用例,其他的用例作为子用例,用例间的这种关系被称为用例的泛化关系。A 是 B的泛化,意味着 A 描述的是一般的行为,而 B是这些行为的详细(Specific)版本,A被称为父用例(Parent Use Case)或基用例(Base Use Case),B被称为子用例(Child UseCase)。

在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承（Inherit）了父用例所有的结构、行为和关系。在用例图中,泛化关系用实线加上空心的箭头来表示。子用例被连接在箭头的尾部,箭头指向父用例。以PPS项目为例,用例Create Wholesale Order和Create Retail Order 都包括一系列公共的行为,如系统提供空白订货单表、业务员输入客户信息、业务员选择产品销售方式、业务员填写需求数量、系统显示产品价格并且合计总价等，因此，可以将这些公共的行为泛化为用例 Create Order,

[![image-20211219222920725](https://camo.githubusercontent.com/1c7159c5019b1de3347d6e5e33747c60e7c2de4f0ad950d88583930fe0f6e1b9/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232323932303732352e706e67)](https://camo.githubusercontent.com/1c7159c5019b1de3347d6e5e33747c60e7c2de4f0ad950d88583930fe0f6e1b9/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232323932303732352e706e67)

参与者之间也存在着这种泛化关系。例如，如果建模了一个数据库管理员和一个备份管理员，然后发现他们的工作中有一部分是重叠的,那么,就可以创建一个称为系统管理员的参与者，作为数据库管理员和备份管理员的泛化。

#### 扩展

扩展是两个用例之间的关系,它使得每个用例可以通过扩展用例向基用例中添加额外的行为来扩展基用例的功能。用例的扩展机制允许从一个基用例开始开发一个复杂的系统,并且能够在不改变基用例的前提下向基用例中扩展更多的行为。用例 A扩展了用例B,则A称为扩展用例(Extend Use Case)或子用例,B称为基用例,它表示扩展**用例A的事件流在一定的条件下按照相应的扩展点可插人基用例B**中，这就 需要在基用例中定义一至多个已命名的扩展点。选用扩展关系可以把一些可选的操作独立封装在另外的用例中,避免基用例过于复杂。 扩展关系用虚线加上开箭头来表示。扩展用例被连接在箭头的尾部,箭头指向基用例,在虚线处添加一个<< extend >>表示扩展关系。

例如,在基用例 Compare Inventory中,如果库存量足够多,则可以启动零配件出库的功能,如果库存量不足则需要创建采购合同。所以Stock Out 和Create Purchase Contract是在用例Compare Inventory基础上的扩展,可将其建模为扩展关系,如图2-11所示。

[![image-20211219223505490](https://camo.githubusercontent.com/ab47ce16cbd1fd9d50f5c0915134f8b3d6730b8d3b3049c0fdbb26d4878209af/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232333530353439302e706e67)](https://camo.githubusercontent.com/ab47ce16cbd1fd9d50f5c0915134f8b3d6730b8d3b3049c0fdbb26d4878209af/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232333530353439302e706e67)

#### 用例描述

> 实际考试中不用写的这么详细，主要写好概述、名称、参与者和基本事件流就行，不然写不完卷子了

[![image-20211219225014902](https://camo.githubusercontent.com/04992f5a1aa83554163ec127edaef05c3e5ac478c6eb0518bd170d888db8f469/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232353031343930322e706e67)](https://camo.githubusercontent.com/04992f5a1aa83554163ec127edaef05c3e5ac478c6eb0518bd170d888db8f469/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232353031343930322e706e67)

[![image-20211219225313759](https://camo.githubusercontent.com/15dbb21b650f1ad6c1e53d30696b64d61ed11cda6f225b7bcbc1bee61c87a970/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232353331333735392e706e67)](https://camo.githubusercontent.com/15dbb21b650f1ad6c1e53d30696b64d61ed11cda6f225b7bcbc1bee61c87a970/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393232353331333735392e706e67)

[![image-20211219231342705](https://camo.githubusercontent.com/18023d48c11cc93db256463512b788cf74028ec7e81582f26a93e88878f579c5/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393233313334323730352e706e67)](https://camo.githubusercontent.com/18023d48c11cc93db256463512b788cf74028ec7e81582f26a93e88878f579c5/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393233313334323730352e706e67)

### 状态机图

一个对象有多个状态，且可以在多个状态之间变化。

状态图由状态和迁移组成，表达方式为：`状态图=状态+迁移`

状态(state)是指在对象的生命期中的某个条件或状况，在此期间对象将满足某些条件、执行某些活动或等待某些事件。所有对象都具有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态发生变化。

状态图(statechart diagram): 用来描述一个特定的对象所有可能的状态,以及由于各种事件的发生而引起的状态之间的转移和变化。 并不是所有的类都需要画状态图，有明确意义的状态，在不同状态下行为有所不同的类才需要画状态图。如下是 一个机器的状态图：

[![image](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOCZ6RvXcGtmExWFLaE9GwWsxWV41EAAukUAAIHrilVqH9cIdD7Kxg2BA.png)](https://images0.cnblogs.com/blog/707050/201501/171116545427686.png)

再如，CD Player的状态图

[![image](https://camo.githubusercontent.com/a8bd6836edd59de30251e91da22a6323dc862ae03d3f3aef8a01edf8eb0acd63/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131363536313938363435392e706e67)](https://images0.cnblogs.com/blog/707050/201501/171116556514359.png)

**1.状态** 一个状态有以下几个部分：状态名(name)、进入／退出动作(entry／exit action)、内部转移(internal transttion)、子状态(substate)、延迟事件(dferred event)。 状态可以细分为不同的类型，例如初态、终态、中间状态、组合状态、历史状态等。一个状态图只能有一个初态，但终态可以有一个或多个，也可以没有终态。 中间状态包括两个区域：名字域和内部转移域，如图所示。其中内部转移域是可选的。

[![image](https://camo.githubusercontent.com/0bc098ebb0529e33cbf6dead703bc9380bacf6fce79ba0fbe32470f7a3458dcc/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131363537393333373438392e706e67)](https://images0.cnblogs.com/blog/707050/201501/171116568862602.png)

横线上面是名字域，下面是转换域（可选）。

> **entry/turnOn：**当转入该状态时，做开灯动作。 **do/blinkFivetimes：**当处于该状态时，灯闪烁5次。do活动是只在状态内出现的活动，不能附加到转换上。 **event poweroff/powerSupplySelf：**当电源关闭事件发生时，用自备电源。 **exit/turnOff：**当转出该状态时，做关灯动作。 **event selfTest/defer：**当selfTest事件发生时，对象将延迟响应，到别的状态中再处理，用defer这个特定动作表示延迟。

**2.状态图的要素**

> **椭圆或圆角矩形：**表示对象的一种状态，椭圆内部填写状态名
>
> **箭头：**表示从箭头出发的状态可以转换到箭头指向的状态
>
> **事件：**引起状态转换的原因。事件名可在箭头线上方标出
>
> 条件：**事件名后加方括号，括号内写状态转换条件 *实心圆：**初始状态 **内部实心的同心圆：**最终状态

**3.转移（Transition） **转移是两个状态间的一种关系，表示对象将在当前状态中执行动作，并在某个特定事件发生或某个特定的条件满足时进入后继状态。 每个转移只允许有一个事件触发，一个事件只允许有一个动作。

***①转移的五要素（注意格式）***

> **格式：事件（参数）[条件]/动作** ▪源状态 ▪目标状态 ▪触发事件 -如果箭头上不带任何事件名，表示是一个自动转换，当与源状态相关的活动完成时就会自动触发。 ▪监护条件 ▪动作

[![image](https://camo.githubusercontent.com/5649f94516c34a8926126e9fc7433b4a205c3461257506388049d97e937c9464/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131373034323631333632312e706e67)](https://images0.cnblogs.com/blog/707050/201501/171117032617449.png)

### 活动图

**1. 活动图的概念** 活动图(activity diagram)是UML的动态视图之一，用来描述事物或对象的活动变化流程。活动图可看作状态图的特殊形式。特殊性在于活动图中的一个活动结束后将立即进入下一个活动而不需要事件触发活动的转移。

活动图用于描述系统的工作流程和并发行为。活动图被设计用于简化描述一个过程或操作的工作步骤。例如，可以用活动图对一个软件的开发过程建模；还可以对诸如求Fibnacci数列第n个数的数值之类的操作进行建模。

活动图示例：

[![image](https://camo.githubusercontent.com/df2e43c1892a11b5acad7208ae47059100e1dff42f94ec7f6c302c740725019c/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131323532353733353236332e706e67)](https://images0.cnblogs.com/blog/707050/201501/171112520428934.png)

**2.活动图的组成元素:**

> ▪活动（Activity）
>
> ▪动作流（Action Flow） 
>
> ▪分支（Branch）与合并（Merge）
>
> ▪分叉（Fork）和汇合（Join）
>
> ▪泳道（Swimlane） 
>
> ▪对象流（Object Flow）

**3.活动**

活动（activity）表示的是某流程中的任务的执行，它可以表示某算法过程中语句的执行。活动在活动图中表现为一个由一系列动作组成的非原子的执行过程。

**4.动作流**

所有动作状态之间的转换流称之为动作流。 活动图的转换不需要特定事件的激发，一个动作状态执行完后自动转换到另外一个状态。 活动图的转换用带箭头的直线表示。 可用条件限制转换。

[![image](https://camo.githubusercontent.com/0c55e4533d6c82bcd496147c415ea0f796f86d1cf8265780e28a2014a93d517b/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131323536313531333132342e706e67)](https://images0.cnblogs.com/blog/707050/201501/171112556206794.png)

**5.分支与合并**

分支一般用于表示对象类所具有的条件行为。 条件行为用分支和合并表达。 一个分支有一个入转换和两个带条件的出转换，出转换的条件应当是互斥的。 一个合并有两个带条件的入转换和一个出转换，合并表示从对应的分支开始的条件行为的结束。

[![image](https://camo.githubusercontent.com/34c6080eb9bd259f8a279836ccec5669005b7ea7ee219c227674ecad64cf9334/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131323537323631343039352e706e67)](https://images0.cnblogs.com/blog/707050/201501/171112566838453.png)

**6.分叉与汇合**

分叉用于将动作流分为两个或者多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。 分叉可以用来描述并发线程。 汇合代表两个或多个并发控制流同步发生，当所有的控制流都达到汇合点后，控制才能继续往下进行。

> 比较复杂，一般用不到

[![image](https://camo.githubusercontent.com/d677700af80121c36c0633f61b22c88abc382b3f153c7374061f33bb34fd21d9/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131323538383233333834302e706e67)](https://images0.cnblogs.com/blog/707050/201501/171112579338168.png)

**7.泳道**

泳道将活动图中的活动化分为若干组，并把每一组指定给负责这组活动的业务组织，通常为对象。 泳道区分了负责活动的对象，明确地表示了哪些活动是由哪些对象进行的。 每个活动只能明确地属于一个泳道。 泳道用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道上方可以给出泳道的名字或对象（对象类）的名字，该对象（对象类）负责泳道内的全部活动。 泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。

[![image](https://camo.githubusercontent.com/f46c6dde2df9b2b0076a710db56410aaef07b72c50e69bb8031232e56a25402e/68747470733a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f672f3730373035302f3230313530312f3137313131333030343137363132362e706e67)](https://images0.cnblogs.com/blog/707050/201501/171112593705940.png)

### 活动图与状态图的比较



**1.活动图与状态图的相同点**： 都是对系统的动态行为建模。

**2.活动图与状态图的区别：**

**①描述对象不同**

状态图：描述对象状态及状态之间的转移；
活动图：描述从活动到活动的控制流。

***②使用场合不同***

状态图：描述对象在其生命期中的行为状态变化；
活动图：描述过程的流程变化。

### 顺序图（时序图）

[![image-20211219231940383](https://camo.githubusercontent.com/b1ef06b5ec28b9ccc2f1485de9b714aa7d2f274bb87faec4bdc2bc1ec9d63705/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393233313934303338332e706e67)](https://camo.githubusercontent.com/b1ef06b5ec28b9ccc2f1485de9b714aa7d2f274bb87faec4bdc2bc1ec9d63705/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393233313934303338332e706e67)

顺序图的概念: 顺序图是按时间顺序显示对象交互的图。它显示了参与交互的对象和所交换信息的先后顺序，用来表示用例中的行为，并将这些行为建模成信息交换。

[![image-20211219231940383](https://camo.githubusercontent.com/b1ef06b5ec28b9ccc2f1485de9b714aa7d2f274bb87faec4bdc2bc1ec9d63705/68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313231393233313934303338332e706e67)顺序图主要包括四个元素：对象、生命线、激活和消息。

在UML中，顺序图将交互关系表示为一张二维图。

其中纵向是代表时间维度，时间向下延伸，按时间依次列出各个对象所发出和接收的消息。水平方向是代表对象的维度，排列着参与交互的各个独立的对象。

[![img](https://camo.githubusercontent.com/f7957d8a072c16bb1d2294919db076ffd34f77db3ff79f4b1a07e3a41b8dd717/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353032323634332d3434323030303136382e706e67)](https://camo.githubusercontent.com/f7957d8a072c16bb1d2294919db076ffd34f77db3ff79f4b1a07e3a41b8dd717/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353032323634332d3434323030303136382e706e67)

![img](https://camo.githubusercontent.com/d3d7b4ed51757519cc84b009f867cb6fda24d2bae265bfb0fb1e4637720c6e7d/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353032383431312d3938303533363939322e706e67)

顺序图的组成元素：对象、生命线、激活、消息。

对象

　　顺序图中的对象与对象图中的概念一样，都是类的实例。顺序图中的对象可以是系统的参与者或者任何有效的系统对象。

　　对象的创建由头符号来表示，即在对象创建点的生命线顶部使用显示对象名和类名的矩形框来标记。

　　在位置上，一个被放置于顺序图顶端的对象，意味着在这个交互的开始之前，我们已经拥有这样一个对象了。如果一个对象出现在其它位置上（不在顶端），则说明这个对象是在交互执行到某些步骤的时候被创建出来的。被创建出来的对象可以在接下来的时间里被其它对象的消息所激活，也可以以同样的方式被销毁。

生命线

　　生命线代表了一次交互中的一个参与对象在一段时间内存在。具体地说，在生命线所代表的时间内，对象一直是可以被访问的——可以随时发送消息给它。

　　在顺序图中，生命线位于每个对象的底部中心位置，显示为一条垂直的虚线，与时间轴平行，带有一个显示对象的头符号。

　　对于在交互过程中被创建的对象，其生命线从接收到新建对象的消息时开始。对于在交互过程中被销毁的对象，其生命线在接收到销毁对象的消息时或在自身最后的返回消息之后结束，同时用一个“X”标记表明生命线的结束。

激活

　　激活，又称为控制焦点，表示一个对象执行一个动作所经历的时间段，既可以是直接执行，也可以是安排下级过程执行。同时，激活也可以表示对应对象在这段时间内不是空闲的，它正在完成某个任务，或正被占用。

　　激活在UML中用一个细长的矩形表示，显示在生命线上，如图8-5所示。矩形的顶部表示对象所执行动作的开始，底部表示动作的结束。

![img](https://camo.githubusercontent.com/ab57a4f53c7a743d94c612da66361968a7d3ebb14400974745685a74e58f9d48/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353131323430342d313233333433393736342e706e67)

例子：系统用户注册模块

[![img](https://camo.githubusercontent.com/bb8b5a503c17d99dfb14b3996bb07599a2b15e66629cdaf0d02da5ded975c728/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353234373332372d313238323737303739392e706e67)](https://camo.githubusercontent.com/bb8b5a503c17d99dfb14b3996bb07599a2b15e66629cdaf0d02da5ded975c728/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353234373332372d313238323737303739392e706e67)

案例（1）就餐

需求描述如下：

客人到餐厅就餐，服务员提供菜单，客人点菜后把菜单交给服务员。服务员向客人确定菜单后，将菜单提交给大堂经理。大堂经理把菜单提交给大厨，大厨完成菜品后传递给大堂经理，大堂经理安排服务员传菜。有的客人可能需要酒水，有的客人不需要酒水。客人结束用餐后，服务员提供账单，客人结账。

确认对象

[![img](https://camo.githubusercontent.com/739b0b8aa8effd85b1326c62f2f762deb3e1b265ed9ca45e334d6827aac84adf/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353330363039312d3337343930313931352e706e67)](https://camo.githubusercontent.com/739b0b8aa8effd85b1326c62f2f762deb3e1b265ed9ca45e334d6827aac84adf/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353330363039312d3337343930313931352e706e67)

确定出现顺序

[![img](https://camo.githubusercontent.com/1eb9b95aa3640c482c2d6c0be1d849de3653fc9452d014392e746717eefe7696/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353331333230332d313939393534393337382e706e67)](https://camo.githubusercontent.com/1eb9b95aa3640c482c2d6c0be1d849de3653fc9452d014392e746717eefe7696/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353331333230332d313939393534393337382e706e67)

确定消息

[![img](https://camo.githubusercontent.com/2429878e1aa00b6b799194205f166070e5ce2778fd8762984378ede038beb622/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353332313832382d313038373137343638372e706e67)](https://camo.githubusercontent.com/2429878e1aa00b6b799194205f166070e5ce2778fd8762984378ede038beb622/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353332313832382d313038373137343638372e706e67)

[![img](https://camo.githubusercontent.com/16a377a92efe1a71e34dd7a5999f1ab770844d021fab7f67e591dfd8e5ff67c5/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353332363837382d3332363435333033302e706e67)](https://camo.githubusercontent.com/16a377a92efe1a71e34dd7a5999f1ab770844d021fab7f67e591dfd8e5ff67c5/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353332363837382d3332363435333033302e706e67)

案例（2）ATM机取款

需求描述如下：

　　用户通过ATM机，插入银行卡。系统提示输入密码，用户输入密码。系统检查密码是否正确，密码正确用户选择取款。系统提示输入取款金额。用户输入金额，系统判断其合法性。在获取用户输入金额后，系统开始事物处理，减少账户金额，输出相应现金。

[![img](https://camo.githubusercontent.com/8ae7d455206cfc97036630d55c7e355eafcddd298452cc1be22cac69e9cbc002/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353334323031372d313332393038393534362e706e67)](https://camo.githubusercontent.com/8ae7d455206cfc97036630d55c7e355eafcddd298452cc1be22cac69e9cbc002/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353334323031372d313332393038393534362e706e67)

案例（3）成绩查询

需求描述如下：

　　老师通过学号在系统查询成绩，有存在、不存在两种情况。存在显示成绩，不存在显示查无此人。

[![img](https://camo.githubusercontent.com/968c776febd0b7ea2510c2755e1f121442b8f037027fff23e8b6d4b93a2ed63d/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353430313038352d3337393538383733362e706e67)](https://camo.githubusercontent.com/968c776febd0b7ea2510c2755e1f121442b8f037027fff23e8b6d4b93a2ed63d/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313133303431332f3230313930322f313133303431332d32303139303230383230353430313038352d3337393538383733362e706e67)

### 类图

类图是最常见的 UML 图。

**类的 UML 画法**

Java是一门面向对象语言，那最基础的就类了。**类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称**。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样子的功能，要承担什么样子的义务。一个类可以有多种职责，但是设计得好的类一般只有一种职责。

假如我现在定义了这么一个类：

```java
public class Person {
    private String name = "Jack";

    public String getName()     {
        return name;
    }

    public void setName(String name)     {
        this.name = name;
    }
    
    protected void playBasketball()     {
        pass();
    }
    
    private void pass()     {
    }
}
```

[![复制代码](https://camo.githubusercontent.com/dd58226f95400c531007e303b183b914b31c1e6cfdd043a782ad02f02d8bbacc/68747470733a2f2f636f6d6d6f6e2e636e626c6f67732e636f6d2f696d616765732f636f7079636f64652e676966)](https://camo.githubusercontent.com/dd58226f95400c531007e303b183b914b31c1e6cfdd043a782ad02f02d8bbacc/68747470733a2f2f636f6d6d6f6e2e636e626c6f67732e636f6d2f696d616765732f636f7079636f64652e676966)

那么此类对应的UML为：

![img](https://camo.githubusercontent.com/8d3ecc451ebcf1ef5e956acd039bcde5567e786f4b34a1f13842c71542407420/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363231333233373532322d313931353637373232382e706e67)

看到该图分为三层：最顶层的为类名，中间层的为属性，最底层的为方法。

属性的表示方式为：【可见性】【属性名称】：【类型】={缺省值，可选}

方法的表示方式为：【可见性】【方法名称】（【参数列表】）：【类型】

可见性都是一样的，**"-"表示private、"+"表示public、"#"表示protected**。

**继承关系**

继承也叫作泛化（Generalization），用于描述父子类之间的关系，父类又称为基类或者超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的**实线**来表示。

假如现在我又定义了一个Student和一个Teacher：

```java
public class Student extends Person {
    private String studentNo;
    
    public void study()     {
    }
}
```

```java
public class Teacher extends Person {
    private String teacherNo;
    
    public void teach()     {
    }
}
```

那么，用UML表示这种关系应当是：

[![img](https://camo.githubusercontent.com/5e0241dab4c02f8578ff0bc18fd7cffad7e8cb44607cada4288a60ffdbbd82d8/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363231353933313532322d313634363238363135302e706e67)](https://camo.githubusercontent.com/5e0241dab4c02f8578ff0bc18fd7cffad7e8cb44607cada4288a60ffdbbd82d8/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363231353933313532322d313634363238363135302e706e67)

**抽象继承关系**

上面的继承是普通的继承，在Java中，除了普通的继承之外，众所周知的还有一种抽象的继承关系，因此就再讲讲抽象继承关系，作为上面的继承的补充。

比方说我想实现一个链表（Link），插入（insert）与删除（remove）动作我想让子类去实现，链表本身只实现统计链表中元素个数的动作（count），然后有一个子类单向链表（OneWayLink）去实现父类没有实现的动作，Java代码为：

```java
public abstract class Link
{
    public abstract void insert();
    public abstract void remove();
    
    public int count()
    {
        return 0;
    }
}
```

```java
public class OneWayLink extends Link
{
    public void insert()
    {
        
    }

    public void remove()
    {
        
    }
}
```

其UML的画法为：

[![img](https://camo.githubusercontent.com/b9d8e5ba1cadce9bdf653b75459993eae3b744e8124fb2217f6453d84232d6d5/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373131343730323137382d3234393332373732362e706e67)](https://camo.githubusercontent.com/b9d8e5ba1cadce9bdf653b75459993eae3b744e8124fb2217f6453d84232d6d5/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373131343730323137382d3234393332373732362e706e67)

在UML中，抽象类无论类名还是抽象方法名，都以**斜体**的方式表示，因为这也是一种继承关系，所以子类与父类通过带空心三角形的实线来联系。

**实现关系**

很多面向对象的语言中都引入了接口的概念，如Java、C#等，在接口中通常没有属性，而且所有的操作都是抽象的，只有操作的声明没有操作的实现。UML中用与类类似的方法表示接口，假设我有一个Animal：

```java
public interface Animal {
    public void move();
    public void eat();
}
```

那么它的UML应当表示为：

[![img](https://camo.githubusercontent.com/5f1b99593c0b129dea312d2e11f9cf8fd5f41107bf409608106a54c7c1dd1b2b/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232313833323134372d313838303535303436302e706e67)](https://camo.githubusercontent.com/5f1b99593c0b129dea312d2e11f9cf8fd5f41107bf409608106a54c7c1dd1b2b/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232313833323134372d313838303535303436302e706e67)

很简单，注意在方法上应当有<>表示这是一个接口。接口一般没有属性，所以这里中间层没有，有属性要注意也都是常量。

接下来，有一个Dog和一个Cat实现了Animal：

```java
public class Dog implements Animal {
    public void move()     {
        
    }

    public void eat()     {
        
    }
}
```

```java
public class Cat implements Animal {
    public void move()     {
        
    }

    public void eat()     {
        
    }
}
```

此时应当使用带空心三角形的**虚线**来表示，UML应该是这样的：

[![img](https://camo.githubusercontent.com/c8c76c266888383b04b462efc8891c7d8a35f15d658b90e6f805eafb35570c75/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232323232373333342d313239353639333931332e706e67)](https://camo.githubusercontent.com/c8c76c266888383b04b462efc8891c7d8a35f15d658b90e6f805eafb35570c75/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232323232373333342d313239353639333931332e706e67)

两个抽象方法，Dog和Cat的实现将不一样，当然，在Dog和Cat之中，也可以增加Dog和Cat自己的变量和方法。

**关联关系**

关联（Assocition）关系是类与类之间最常见的一种关系，它是一种结构化的关系，表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对象所对应的类，**在Java中通常将一个类的对象作为另一个类的成员变量**。关联关系分单向关联、双向关联、自关联，逐一看一下。

**1、单向关联关系**

单向关联指的是关联只有一个方向，比如顾客（Customer）拥有地址（Address），其Java实现为：

```java
public class Address
{

}
public class Customer
{
    private Address address;
}
```

UML的画法为：

[![img](https://camo.githubusercontent.com/ce2e7017e8a64006b07eb789167b9e927d5453849e653372dfdddd4b508e92af/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232343230383838312d3231313138353530322e706e67)](https://camo.githubusercontent.com/ce2e7017e8a64006b07eb789167b9e927d5453849e653372dfdddd4b508e92af/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232343230383838312d3231313138353530322e706e67)

**2、双向关联关系**

默认情况下的关联都是双向的，比如顾客（Customer）购买商品（Product），反之，卖出去的商品总是与某个顾客与之相关联，这就是双向关联。Java类的写法为：

```java
public class Product
{
    private Customer customer;
}
public class Customer
{
    private Product[] product;
}
```

对应的UML类图应当是：

[![img](https://camo.githubusercontent.com/1cfd5ff0d53b79c7f1ee90a073eaac267039ac9f9accd2fc3a7f0a5c42e1d3a5/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232343935373331392d3733363131303437392e706e67)](https://camo.githubusercontent.com/1cfd5ff0d53b79c7f1ee90a073eaac267039ac9f9accd2fc3a7f0a5c42e1d3a5/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232343935373331392d3733363131303437392e706e67)

**3、自关联关系**

自关联，指的就是对象中的属性为对象本身，这在链表中非常常见，单向链表Node中会维护一个它的前驱Node，双向链表Node中会维护一个它的前驱Node和一个它的后继Node。就以单向链表为例，它的Java写法为：

```java
public class Node
{
    private Node nextNode;
}
```

对应的UML类图应当是：

[![img](https://camo.githubusercontent.com/59751bb43d180fa65409fb336f7788183f337bb13b1748df0d58766e5caeb18c/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232353635343035332d323036313531313938332e706e67)](https://camo.githubusercontent.com/59751bb43d180fa65409fb336f7788183f337bb13b1748df0d58766e5caeb18c/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532363232353635343035332d323036313531313938332e706e67)

**聚合关系**

聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，**成员对象是整体的一部分，但是成员对象可以脱离整体对象独立存在**。在UML中，聚合关系用带空心菱形的直线表示，如汽车（Car）与引擎（Engine）、轮胎（Wheel）、车灯（Light），Java表示为：

```java
public class Engine
{

}
public class Wheel
{

}
public class Light
{

}
```

```java
public class Car
{
    private Engine engine;
    private Light light;
    private Wheel wheel;
    
    public Car(Engine engine, Light light, Wheel wheel)
    {
        super();
        this.engine = engine;
        this.light = light;
        this.wheel = wheel;
    }
    
    public void drive()
    {
        
    }
}
```

对应的UML类图为：

[![img](https://camo.githubusercontent.com/de3d22e19fb671fb6563e1b50b096dff0bff808a6317eead10a00916605f428c/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373130313130363937352d313939303538373838322e706e67)](https://camo.githubusercontent.com/de3d22e19fb671fb6563e1b50b096dff0bff808a6317eead10a00916605f428c/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373130313130363937352d313939303538373838322e706e67)

代码实现聚合关系，**成员对象通常以构造方法、Setter方法的方式注入到整体对象之中**。

**组合关系**

组合（Composition）关系也表示的是一种整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也不存在，整体对象和成员对象之间具有同生共死的关系。在UML中组合关系用带实心菱形的直线表示。

比如人的头（Head）和嘴巴（Mouth）、鼻子（Nose），嘴巴和鼻子是头的组成部分之一，一旦头没了，嘴巴也没了，因此头和嘴巴、鼻子是组合关系，Java表示为：

```java
public class Mouth
{

}
public class Nose
{

}
```

```java
public class Head
{
    private Mouth mouth;
    private Nose nose;
    
    public Head()
    {
        mouth = new Mouth();
        nose = new Nose();
    }
    
    public void shake()
    {
        
    }
}
```

其UML的表示方法为：

[![img](https://camo.githubusercontent.com/6ab63b3e3eae7eff7017e98ca6e2f96c29b0d8a0045b8b8ae87f1ef73469e40e/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373130323334383738382d323037333231303536382e706e67)](https://camo.githubusercontent.com/6ab63b3e3eae7eff7017e98ca6e2f96c29b0d8a0045b8b8ae87f1ef73469e40e/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373130323334383738382d323037333231303536382e706e67)

代码实现组合关系，通常在**整体类的构造方法中直接实例化成员类**，这是因为组合关系的整体和部分是共生关系，如果通过外部注入，那么即使整体不存在，那么部分还是存在的，这就相当于变成了一种聚合关系了。

**依赖关系**

依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系，大多数情况下依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。

比如，驾驶员（Driver）开车，Driver类的drive()方法将车（Car）的对象作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此也可以说Driver依赖Car，Java代码为：

```java
public interface Car
{
    public void move();
}
```

```java
public class Driver
{
    public void drive(Car car)
    {
        car.move();
    }
}
```

其UML的画法为：

[![img](https://camo.githubusercontent.com/8d2eac27e9e7b522b7aa8e5736208d0df5b088101b19dd580f153c4b0dd6c13e/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373131313434323934342d313739373131363436312e706e67)](https://camo.githubusercontent.com/8d2eac27e9e7b522b7aa8e5736208d0df5b088101b19dd580f153c4b0dd6c13e/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3830313735332f3230313630352f3830313735332d32303136303532373131313434323934342d313739373131363436312e706e67)

依赖关系通常通过三种方式来实现：

> 1. 将一个类的对象作为另一个类中方法的参数
> 2. 在一个类的方法中将另一个类的对象作为其对象的局部变量
> 3. 在一个类的方法中调用另一个类的静态方法

**关联关系、聚合关系、组合关系之间的区别**

从上文可以看出，关联关系、聚合关系和组合关系三者之间比较相似，本文的最后就来总结一下这三者之间的区别。

关联和聚合的区别主要在于语义上：**关联的两个对象之间一般是平等的，聚合则一般是不平等的**。

聚合和组合的区别则在语义和实现上都有差别：**组合的两个对象之间生命周期有很大的关联，被组合的对象在组合对象创建的同时或者创建之后创建，在组合对象销毁之前销毁，一般来说被组合对象不能脱离组合对象独立存在，而且也只能属于一个组合对象；聚合则不一样，被聚合的对象可以属于多个聚合对象**。

再举例子来说：

- 你和你的朋友属于关联关系，因为你和你的朋友之间的关系是平等的，关联关系只是表示一下两个对象之间的一种简单的联系而已，就像我有一个朋友
- 你和你借的书属于聚合关系，第一是因为书可以独立存在，第二是因为书不仅仅属于你，也可以属于别人，只是暂时你拥有
- 你和你的心脏属于组合关系，因为你的心脏只是属于你的，不能脱离与你而存在

不过，实际应用中，我个人感觉三种关系其实没有区分得这么清楚，有些架构师甚至会说"组合和聚合没什么区别"，所以，有时候不需要把细节扣得这么细，合理利用对象之间的关系给出设计方案即可。

## 面向对象设计原则

**易用性原则**：易维护性、可扩展性、可重用性

设计原则如下：包含**五个最核心的原则**和**两个额外的原则**。

五个核心原则主要分为两类：

- 开闭原则及其衍生：如何解决依赖可能发生变化的问题，如何抽象、封装一个类；衍生为里氏替换原则：子类如何在父类基础上完成扩展；依赖倒置原则指出，所有类应当使用抽象的类/接口作为依赖，而非具体类
- 单一职责原则及其衍生：单一职责原则和接口单一原则都要求类/接口的功能单一

> 以下内容了解即可

可维护性设计：软件设计的核心目标是让软件在长期使用中进行变化，以便让软件适应新的需要。

缺乏可维护性的常见问题：软件腐烂：

- 过于僵硬（没有新功能）
- 过于脆弱（异常较多，对 bug 没有抵抗力）
- 复用率低（代码冗余，且在多处出现）
- 黏度高

设计的总体目标包含：

- 为用户而设计（RBAC，控制用户权限）
- 为分工而设计（接口粒度较小，方便多人设计）
- 为变化而设计（让软件的变化更加简单）
- 为易理解而设计
- 为重用而设计

> 以上内容了解即可

#### 单一职责原则

每个类必须只有一个职责。一个类，最好只做一件事，且只有一种引起它变化的原因

比如，一个矩形类（`Rectangle`）包含两个函数：在显示屏上绘制自身，计算自己的面积。事实上，这个类就包含了两个职责；如果显示屏接口发生变化，此类需要变化，即使计算面积函数没有任何改变。

我们可以将这个类拆分为两个：`Rectangle` 类存储矩阵的长宽；新的类 `AreaCalculator` 计算三角形的面积（通过 `Rectangle` 类的公开函数）

或者，我们可以把其他图形加入进来，添加一个 `Shape` 类作为 `Rectangle` 和 `Circle` 的父类，其包含一个抽象方法 `area`，每个子类各自实现自己的 `area` 函数

单一职责原则有什么好处：

> 1、类的复杂度降低，实现什么职责都有清晰明确的定义； 2、可读性提高；复杂度降低，那当然可读性提高了； 3、可维护性提高，可读性提高，那就更容易维护了； 4、变更引起的风险降低；也就是说提高了扩展性和可维护性。

坏处：

> 1. 由于类的个数增加，维护的复杂度增加了

单一职责原则就像第三范式，并不是所有时候都要满足的；如果满足这个原则会导致维护困难，也可以选择不满足。

例子中提到的把 Book 和 BookList 功能分离为两个类就是在做符合单一原则的重构。

实例应用：

- 单条语句：不要 `return` 一个表达式；表达式应当在前一条语句中计算，`return` 语句中仅返回一个值。

  不要：

  ```java
  return a+b+c;
  ```

  要：

  ```java
  int returned = a + b + c;
  return returned;
  ```

  我个人认为这个有点抽象……

- 单个变量：函数中定义的变量名不要重复；不要把变量计算的结果直接赋回这个变量

  不要：

  ```java
  name = name.substring(0, 6);
  ```

  我感觉这个也挺抽象……老师说是为了不混淆，但我感觉这也不会混淆啊

- 方法职责单一：不要在一个方法里干不相关的多个事

  这个原则还是比较正常的

- 类原则单一：不要在一个类中干不相关的多个事

  比如：把用户的所有信息封装在一个类下是不好的；应当把用户的基本信息、扩展信息分开存放

#### 开放封闭原则
![](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAODZ6RvdsywqTSWZALVzEi1laNvA1wAAuoUAAIHrilVK1mE37l4x4A2BA.png)

开：对变化开放，支持变化

闭：把变化封装在一定范围内，不要让变化影响其他部分的代码，

对需求的变化开放，但是要把需求的变化封装在特定的范围内。可以通过抽象类/抽象接口完成这种操作。尽量保证不会因为需求变化，导致其他部分的代码需要重新设计。

开-闭原则的核心是封装与抽象，让一个部分的改动尽可能少的影响其他部分。

做法：声明的变量的类型、函数的参数类型、函数的返回类型等要尽量依赖抽象类和接口，而不是具体的类。

比如：output 类可能使用 hp、epson、lenovo 三个类的 print 方法实现打印；这种方法导致了打印机类和 output 类间的强耦合。如果把三个打印机类统一为一个接口，output 类通过接口访问打印机，就可以将它们解耦合，保证打印机类扩展时，output 类的相对稳定，可以在不用变化的情况下支持打印机类的扩展。

常见：适配器模式；组合模式（组件之间可以相互嵌套）

#### 接口隔离原则

> 接口隔离原则可以看做单一职责原则在接口上的应用

设计时采用多个与特定客户类有关的接口比采用一个通用的接口好；

一个接口可能太胖（包含多种不相关的接口函数），可以将其分解成多个接口。

![68747470733a2f2f67697465652e636f6d2f79692d6a756e7175616e2f696d6167655f67697465652f7261772f6d61737465722f696d616765732f696d6167652d32303231313232303130343631363535322e706e67](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAOEZ6RvgicUKa6Nc9UMTQ5BIRoTpmMAAusUAAIHrilVG4qg7duPiH02BA.png)

#### 依赖倒置原则

所有模块都不应当依赖于具体实现，而应当依赖于抽象的实体。因为抽象类是稳定的，而具体类的接口可能发生变化。

> 依赖倒置也采用了类似开闭原则的思想：类应当依赖于抽象的类/接口，这样具体实现类变化时，类不会受到影响。

- 高层模块不应该依赖于低层模块,二者都应该依赖于抽象。

  这就是所谓「倒置」的由来。高层模块本应当依赖于底层模块，但实际上并没没有

- 抽象不应该依赖于细节，细节应该依赖于抽象。

构建抽象，实现具体。

抽象反映高层策略 • 仔细分析需求，先找出那些业务规则，然后把它们抽象出来形成你的 接口。 • 层次化你的设计，常见的方式就是划分出显示层，业务层，持久层， 再在每层做抽象。 • 在实现的时候始终遵循 前面提到的原则：只依 赖于接口。 • 谁也无法在开始就做到 最好，因此要不断迭代 精化设计。

#### 里氏替换原则

这个原则是利斯科夫（Liskov）提出的，所以叫里氏替换原则。

主要思想：**子类可以扩展父类的功能，但不能改变父类原有的功能**。

<font color=red>只有衍生类可以替换掉基类，且原本的功能不受影响时，衍生类实现才正确。</font>

在软件中将一个基类对象替换成它的子类 对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软 件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。当功能扩展时，子类尽量不要重写父类的方法，而是另写一个方法，所以 对上面的代码加以更改，使其符合里氏替换原则，

**里氏替换原则是实现开闭原则的重要方式之一**，由于使用 基类对象的地方都可以使用子类对象，因此在程序中尽量使 用基类类型来对对象进行定义，而在运行时再确定其子类类 型，用子类对象来替换父类对象。

**注意**

1 子类的所有方法必须在父类中声明，或子 类必须实现父类中声明的所有方法。根据里氏 替换原则，为了保证系统的扩展性，在程序中 通常使用父类来进行定义，如果一个方法只存 在子类中，在父类中不提供相应的声明，则无 法在以父类定义的对象中使用该方法。

> Java 的语法中也不允许在父类对象上调用子类对象方法

2、我们在运用里氏替换原则时，尽量把父类设计为抽象类 或者接口，让子类继承父类或实现父接口，并实现在父类中 声明的方法，运行时，子类实例替换父类实例，我们可以很 方便地扩展系统的功能，同时无须修改原有子类的代码，增 加新的功能可以通过增加一个新的子类来实现。里氏替换原 则是开闭原则的具体实现手段之一。

3、在系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法，可以有效降低代码出错的可能性。

#### 合成/聚合复用原则

该原则的简述：要尽量使用合成/聚合，尽量不要使用继承。 • 合成/聚合复用原则，也称合成复用原则：就是在一个新的对象里面使用一 些已有的老对象，使之成为新对象的一部分；新的对象通过向这些老对象 的委派，达到复用已有功能的目的。 • 合成： • 合成关系中，新对象在整体角度，对其组成部分拥有完全的支配权，包括 他们的创建和湮灭。即组合而成的新对象对组成部分的内存分配、内存释 放有绝对的责任。 • 一个合成的多重性不能超过1，即，一个合成关系中的成分对象不能与另外 一个合成关系共享。一个合成关系湮灭了，则所有的成分对象在同一时间 内都会被湮灭。

使用聚合而不是继承，因为继承会让子类看到父类内的所有内部实现，会破坏封装。

#### 迪米特原则

迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），一个对象应该对其他对象有最少的了解，即保证对象暴露的信息越少越好。迪米特原则强调尽量不使用泛化（泛化就是子类继承父类后修改部分内容）

面向对象应该保证黑箱调用：每个对象只知道其他对象需要暴露的方法

## 面向对象设计总结

面向对象设计最重要的特点就是**抽象**。

**封装**使得不同对象之间相互独立，可以在暴露较少信息的情况下进行协作。

**消息**解决了对象和对象间进行信息传输的问题。**事件**是一种常见的，实现消息的方法。

**多态**可以在父类的基础上修改一部分行为，保证代码重用。

**设计原则**是编写面向对象程序，运用上述方法的指导，主要包含单一职责原则（不要太胖）和开闭原则（封装、抽象与泛化原则）两大类

迪米特法则：信息暴露最小化原则，要求对象要保持封装，暴露的信息越少越好

