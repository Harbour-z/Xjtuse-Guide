# 第二章 计算机演变与性能

> 此部分和「性能问题」部分在书上都属于第二章，不过老师在授课时分为两部分讲解。
>
> 易俊泉学长的原始笔记链接如下：
>
> [chapter02 计算机演变与性能](docs/课内笔记/大三上/计算机组成与结构/笔记/易俊泉/chapter02计算机演变与性能.md)

## KEY POINTS

1. IAS 的结构和程序执行步骤
2. 摩尔定律
3. 嵌入式系统相关的概念



<mark>计组方面常见的存储单位要记住</mark>

![image-20211001221924587](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211001221924587.png)

冯诺依曼计算机的重要特点：

- 指令和数据存储在一起（同一块可读写内存中）
- 内存通过地址寻址
- 指令按照顺序不断执行

## 2.1 A Brief History of Computer

### 计算机发展历史

第一代计算机：1946——1957年 电子管（真空管）时代

ENIAC、UNIVAC、IBM 701（使用十进制）

> 将 ENIAC 和之前的各种计算器区分开来的事：ENIAC 可以执行条件跳转、可以编程

IAS：是冯诺依曼和图灵几乎同时提出的，在 1952 年才完成。它存在主存（Main Memory）同时存储程序和数据；ALU 处理**二进制**的数据，CU 负责从主存中读取指令并且执行，具有 CU 控制的 I/O 装备

> IAS 被称为现代计算机的原型；直到今天，常见的计算机仍然遵循 IAS 的基本结构。具体介绍见下一部分。

第二代计算机：1958——1964年 晶体管时代

得益于晶体管的体积减小（以及不容易烧），晶体管计算机大小小于电子管，成本更低，发热更少，而且拥有复杂的 ALU 和 CU。

晶体管计算机时代开始出现系统软件。这些软件还比较原始，只能帮助载入程序，移动数据。

晶体管计算机存在专用的 I/O 通道，I/O 设备可以自主读取数据。

> IBM 7000系列  DEC ：PDP-1

第三代计算机：1965——1971年 中小规模集成电路时代

> IBM System/360 and DEC PDP-8

集成电路时代出现的成果：

- 微电子蚀刻：可以在同一片硅片上蚀刻电容、电阻等元件，需要什么就可以刻什么。因此，电容/电阻占地大幅缩小，计算机大小也随之缩小。

第四代计算机：1972年至今 大规模与超大规模集成电路时代（VLSI)



第五代计算机：2009年至今（有争议，了解即可）

> 世界上第一台通用电子计算机——**ENIAC** 宾夕法尼亚大学——真空管计算机
>
> DEC公司研发的第一步计算机——**PDP-1**——晶体管
>
> 集成电路的出现，意味着**微电子时代**的到来
>
> 第一台小型机——|**DEC PDP-8 (1965)**——集成电路
>
> :star: 第一个在单个芯片上包含CPU所有组件的芯片——**1971 Intel developed 4004**——微处理器的诞生
>
> 第一个8位微处理器——1972 Intel developed 8008
>
> •First general purpose microprocessor——1974 Intel developed 8080

> Intel x86 架构：
>
> x86 架构是复杂指令集的设计典范；Intel 曾保持非嵌入式设备处理器制造商第一的位置几十年。
>
> Arm 架构：
>
> 经常用于嵌入式系统中

### IAS(重点)

<mark>第一台计算机</mark>：ENIAC 1946年在宾夕法尼亚大学完成

<mark>冯诺依曼机(图灵机/IAS)</mark>：包括控制器、存储器、运算器、输入输出设备

IAS 第一次提出了「存储程序」的概念。在 ENIAC 中，计算机无法存储它需要执行的程序；程序需要被编写在打孔卡片上，慢慢的输入计算机。而 IAS 中，程序和数据一样，都存储在主存中。

> 存储程序和数据的主存储器
>
> 运算二进制数据的ALU
>
> 控制单元从存储器中解释指令并执行它们
>
> 由控制单元操作的输入和输出设备

![image-20211224160249716](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211224160249716.png)

> 可以看出，IAS 还没有总线的概念：需要连线的模块就自己拉一根线，连线比较分散。

#### 1）IAS存储格式

The memory of the IAS consists of 1000 storage locations (called **words**字) of 40 bits each 

IAS 的主存包含 1000 个存储单元（字），每个字长度为 40 位。（不像现在基本都是 32 位/64 位）

数据与指令混合存储

![image-20211001213500950](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211001213500950.png)

当一个字用于存储数字时，它的结构被分为两部分：1 位的符号位和 39 位的数字位。

字也可以存储指令。一个字长度为 40，可以存储两条指令，分别被称为左指令和右指令（见 b 图）；左指令/右指令各长 40 位，都由 8 位的操作码（指定要执行的操作）和 12 位的地址码（操作数的地址）组成。

> 现代计算机已经不存在左指令和右指令之分：每次都只取一条指令并执行该指令。

#### 2）IAS寄存器

:one: Memory buffer register (MBR) **存储缓冲寄存器**

> 包含一个要存储在主存或发送到 CPU 的 I/O 单元的字（Word，上面提到的 40 字节一个单位的空间）或用于从主存或 CPU 的 I/O单元接收一个字
>
> 用于沟通 CPU 和主存；ALU 算出来一个数字之后，不能直接塞进主存，必须在 MBR 中暂存，攒成 一个字长后再送给主存。
>
> MBR 中可能存放指令或者数据。怎么确定读到的是指令还是数据呢？通过时序；比如，在一个时钟周期的前一半时，只取数据；后一半只取指令。这样就能区分存储的是指令还是数据了
>
> 简而言之：主存读取的内容必须先进 MBR 再进 AC\MQ 等 CPU 内部寄存器；CPU 计算出的内容必须先进 MBR 才能放回主存

:two: Memory address register (MAR) **存储地址寄存器**

> 指定要从 MBR 中写入或读入的字在内存中的位置
>
> 简而言之：CPU 要取哪里的指令/数据，这个指令/数据的地址必须先进 MAR 才能被取到

:three: Instruction register (IR) **指令寄存器**

> 包含正在执行的 8 位操作码指令

:four: Instruction buffer register (IBR) **指令缓冲区寄存器**

> 暂存右指令。现代计算机没有左右指令之分，不用该寄存器

:five:<mark> Program counter (PC) **程序计数器**</mark>

> 指令的执行永远从它开始，包含要从内存中提取的下一个指令的地址

:six: Accumulator (AC) and multiplier quotient (MQ) **累加器(AC)和乘数商(MQ)**

> 用于存储部分计算的中间结果，是 ALU 结果的存储位置

![image-20211001214537199](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/image-20211001214537199.png)

IAS让程序执行的过程：PC 把下一条要执行的指令的地址放在 MAR -> MAR 通知主存->主存把地址放入 MBR 暂存-> MBR 将右指令放入 IBR -> MBR 先把左指令分为操作码和地址码两部分->操作码放给 IR，地址码放给 MAR（覆盖掉了 MAR 之前的指令地址，不过反正已经取了，无所谓；此时 MAR 存储的是数据） -> IR 译码以后产生跟指令相关的控制信号，要计算的话给 ALU 进行计算（通过图中的 Control Signal 连接 ALU），同时操作数的地址驱动主存取数据 -> 然后将结果暂存在 MBR -> MBR 把操作数传递给 ALU，计算结果保存在 AC 或者 MQ 中，左指令完成

然后是右指令（操作和左指令一样 ）-> MBR 把右指令分为操作码和地址码两部分 -> 操作码放给 IR，地址码放给 MAR -> IR 译码以后产生跟指令相关的控制信号，要计算的话给 ALU 进行计算，同时操作数的地址驱动主存取数据 -> 然后将结果暂存在 MBR -> MBR 把操作数传递给 ALU -> ALU 计算，结果放在 AC 或者 MQ 中->主存从 MBR 取结果储存->程序执行结束，PC+1

注意：

- 任何从主存取过来的东西都必须在 MBR 暂存。MBR 中可以存放数据或者指令
- 如果一次执行中，取到的指令只有右指令，没有左指令，则跳过执行左指令一步，直接执行右指令；执行完成右指令后，整条指令视为执行完成，PC +1
- 注意：IAS 和现代计算机不同，执行完指令后 PC+1，而不是在取指周期完成就 +1。

#### IAS 指令集

21个指令：数据传输、无条件转、条件分支、计算、地址修改

### Moore‘s Law（摩尔定律）

摩尔定律是一个观察得出的定律，没有证明之类的。

**集成电路上可以容纳的晶体管数目在大约每经过18个月便会增加一倍。**

> 由于芯片尺寸大小不变，只是门电路数量增加了，芯片的成本几乎保持不变
>
> 更高的堆积密度意味着更短的电路径，从而提供更高的性能
>
> 更小的尺寸增加了灵活性
>
> 晶体管更小，耗能更少，减少电力和冷却需求
>
> 互连更少，可靠性更高

## 嵌入式系统

定义：计算机硬件和软件的组合，可能还包括其他机械或零部件，旨在执行**特定**的功能

> 嵌入式系统和一般计算机的区别就是：嵌入式系统只执行特定的任务，并不要求全面性

### IoT（Internet of Things，物联网）

物联网中的所有项目都通过信息感知设备连接到互联网，以实现信息交换、智能识别和管理。

在物联网中，物品可以在无人介入的情况下相互通信，主要是通过射频识别（RFID）技术实现的。

物联网主要由深度嵌入式设备组成。深度嵌入式设备是一种嵌入式设备，其表现形式对用户和程序员来说都很难察觉。

深度嵌入式设备通常：

- 使用微控制器而非微处理器，其程序被烧录在只读存储器（ROM）中。
- 功能通常很简单，只有一个特定的目标。

- 通常具有无线连接能力，可以通过网络配置。
- 具有资源限制，例如只能使用很少的内存和电源功率。

应用处理器 vs 专用处理器

应用处理器用于通常的目的，一般适用于运行复杂而通用的操作系统

专用处理器旨在处理相当少种类的情况，可以减少其成本和大小。

### 微处理器 vs 微控制器

早期的微处理器芯片包括寄存器、算术逻辑单元和某种控制单元或指令处理逻辑

当代的微处理器芯片包括多个核心和大量的缓存内存，适用于运行通用的任务。



微控制器是一种单片芯片，包含处理器、非易失性存储器（ROM）用于存储程序、易失性存储器（RAM）用于输入和输出、时钟和输入/输出控制单元，也被称为「单片机」。

> 微控制器可以看作一个完整的计算机

微控制器的物理尺寸和处理能力各不相同，处理能力一般和价格正相关（

微控制器通常比微处理器慢得多。

微控制器通常用于特定的任务，嵌入到设备中，不提供人机交互。

### Arm 架构

Arm：Acorn RISC Machine（阿克恩 RISC 计算机架构）

> Acorn: 一个英国公司
>
> RISC：精简指令集

基于 RISC 的微处理器和微控制器家族，广泛应用于个人数字助理和其他手持设备

任何种类中最广泛使用的处理器架构

Arm 指令集：

高度规则化，旨在高效地实现处理器和高效地执行。其指令长度为32位，遵循一个标准化的格式。

> 不像 x86 的指令集中，一些指令可能会要求取其他指令进行扩充并执行

Cortex-A: 用于手机芯片

Cortex-R：用于实时系统

Cortex-M：用于嵌入式系统

#### 微控制器 vs 多核计算机

微控制器计算机系统的顶层是一个单片机（单个芯片）

多核计算机的顶层是一个主板，包含多个芯片

微控制器中没有任何缓存设计

### 冯诺依曼结构 vs 哈佛结构

二者的主要区别在存储器可存储的内容上：

- 冯诺依曼结构的存储器是可以存储程序或者数据的，可以随时切换存储的内容
- 哈佛结构将程序和数据分开存储在单独的存储器中。好处是在取指令的同时可以取数据。

一般情况下，最靠近 CPU 的存储器采用哈佛结构，外层采用冯诺依曼结构（L3 Cache 和更外）

## 云计算

云计算就是购买云厂商的相关服务，属于「需要什么买什么」的范围。

云网络：能够支持云计算的网络和网络管理功能。比如，能确保网络安全的防火墙、网络安全设备属于云网络的部分。

云存储：云计算的一部分，在厂商的云服务器上存储数据库等数据。