# 线程

> 易俊泉学长的原始笔记如下：
>
> [第五章-线程](docs/课内笔记/大三上/操作系统/笔记/易俊泉/第五章-线程.md)

## 5.1 线程的引入

进程具有二个**基本属性**：

:one: 是**一个拥有资源的独立单位**:它可独立分配虚地址空间、主存
:two: 又是一个可独立调度和分派的基本单位。

这二个基本属性使进程成为**并发执行的基本单位**

**由于进程是一个资源的拥有者，因而在进程创建、撤销、调度切换时，系统需要付出较大的时空开销。进程的数目不宜过多，进程切换频率不宜过高，限制了并发程度。**

> 引入进程是为了并发，结果现在又说进程并发太多时开销太大，难道并发多和开销小不能兼得吗？

并发和开销问题的一种解决方案：

将进程的两个基本属性分开，对于拥有资源的基本单位（进程），不对其进行频繁切换；对于调度的基本单位（线程），不作为拥有资源的单位，“轻装上阵”

线程是 CPU 调度的基本单位，但是**不拥有大量独立资源**，大部分资源都和其所属进程共享。

引入线程的目的：

- 简化线程间的通信

  同一进程的不同线程完全共享资源（共享数据），因此可以便捷的传递信息

- 以小的开销来提高进程内的并发程度。

**实例：**

在有些情况下,一个应用程序可能需要执行多个不同的任务，从而完成一个整体的任务。

> 例如：一个字处理程序（如 word）可能同时有一个线程接收用户输入，另外一个线程显示图形，还有一个线程执行拼写检查。

在某些情况下，一个应用程序可能需要执行多个相似任务。

>  如网页服务器，可能有多个客户端并发访问，如果网页服务器作为传统进程来执行，那么一次只能对一个客户服务，客户的等待时间会很长

**解决方案1**

创建多个进程
网页服务器作为单个进程运行只接收请求
当接收到请求后，该进程创建另一个进程以处理请求

> 这种方案解决了并发问题，但是进程切换开销太大

**解决方案2**

引入线程，多线程的进程
进程中的一个线程监听客户请求
当有请求时，该进程创建一个线程以处理请求

> 这种方案即保证了并发，又保证了线程切换的效率

此种解决方案的表示：

![image-20211101210440108](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211101210440108.png)

## 5.2 线程的概念

**进程**：资源分配单位（存储器、文件）和CPU 调度（分派）单位。又称为"任务（task）"

**线程**：作为 CPU 调度单位，而进程只作为其他资源分配单位。也称为轻型进程

> 只拥有必不可少的资源，如：<font color="red">**线程状态、程序计数器、寄存器上下文和栈**</font>。不单独申请 I/O 设备等资源，不持有自己的数据和代码。
> 同样具有**就绪、阻塞和执行**三种基本状态
> 与同属一个进程的其它线程共享进程拥有的全部资源
> 可并发执行

线程的优点：**减小并发执行的时间和空间开销（线程的创建、退出和调度），因此容许在系统中建立更多的线程来提高并发程度。**

> 线程的创建时间比进程短；
> 线程的终止时间比进程短；
> 同进程内的线程切换时间比进程短；
>
> 由于同进程内线程间共享内存和文件资源，可直接进行不通过内核的通信；
>
> 注：同进程内的线程切换不会导致进程切换，但是从一个进程内的线程切换至另一个进程内的线程依然会引发进程切换。

![image-20211101210651656](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211101210651656.png)

这张图片描述了单线程程序和多线程程序的样式。多线程程序中，每个线程都有独立的寄存器和栈，但是共享程序代码、数据和文件等数据资源。

线程的明确定义：

线程（轻型进程）是 CPU 运用的基本单元，包括：程序计数器、寄存器集和栈空间

一个线程和他的同一进程内的线程**共享代码段、数据段和操作系统资源**，线程切换时**只需要切换寄存器和栈**，所以会比进程切换快。

> 后面会提到，线程自己拥有一个控制块（TCB），在切换线程时同样需要切换线程控制块

## 5.3 进程与线程的比较

**并发性：**引入线程后，操作系统并发度更高：不仅进程之间可以并发执行，而且一个进程中的多个线程间亦可并发执行，从而能更**有效地使用系统资源和提高系统吞吐量。**

**拥有资源**：进程是拥有资源的独立单位，线程独自占用的资源很少（只有寄存器、栈）

**系统开销**：在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，OS 所付出的开销将明显地大于在创建或撤消线程时的开销。 

**地址空间和其他资源（如打开文件）**：进程间相互独立，同一进程的各线程间共享——某进程内的线程在其他进程不可见

**通信**：进程间通信 IPC，不管是共享内存空间还是信箱，都需要内核支持。而线程可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性

**调度**：线程上下文切换比进程上下文切换要快得多；

![image-20211009145138720](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211009145138720.png)

这是线程切换和进程切换的对比。线程间切换时，不需要切换 PCB 块内容和线程所属进程的地址空间（数据与程序），不过需要切换线程控制块（Thread Control Block, TCB）、栈和寄存器。进程切换时，需要切换 PCB 块，地址空间，栈。

## 5.4 线程的好处

**响应度高**：一个多线程的应用在执行中，即使其中的某个线程阻塞，其他的线程还可继续执行，从而提高响应速度

> 线程提高了并发程度，并发程度高了，线程的响应度就高了。

**资源共享**：同一进程的多个线程共享该进程的内存等资源（因此可以通过全局变量直接通信）

**经济性**：创建和切换线程的开销要低于进程。比如，Solaris中进程创建时间是线程创建的30倍，进程切换时间是线程切换的5倍。

**MP 体系结构的运用**：多线程更适用于多处理机结构。

> 多线程-单进程相对单线程-单进程，在多核处理器上表现更好，因为多线程程序可以在多核上一同执行。



## 5.5 线程的状态与线程控制块

> 此部分为扩展内容，可以选择性阅读；仅仅知道线程具有就绪、阻塞、运行三种状态应该也可以。

线程具有三种状态：运行、阻塞和就绪。其每种状态的意义如下：

1. 执行态：线程获得了 CPU，正在运行
2. 就绪态：线程获得了除了 CPU 外所需的一切执行条件
3. 阻塞态：线程因为某事件受阻，即使获得 CPU 也暂时无法执行。

线程控制块：TCB，存储了进程内每个线程特有的一些信息，包含：

1. 线程标识符
2. 通用寄存器
3. 运行状态
4. 优先级
5. 栈指针

相比于 PCB，TCB 不包含：

1. 分配资源列表（因为线程不是拥有资源的基本单位，无法独自持有资源）
2. 通信信息：进程和其他进程通信需要共享存储区/消息传递，而同一进程的线程间通信可以通过共享变量完成



## 5.6 内核线程与用户线程

**线程的两大类**：内核级的线程与用户级线程（操作系统无法感知，在用户空间）

### 内核线程

**内核级线程才真正是 CPU 调度的基本单位**，类似于进程

内核级线程完全由内核管理，由内核实现创建、撤销、调度。Windows NT 和 OS/2 支持内核线程；

- 内核维护进程和线程的上下文信息；（内核维护一个线程控制块 TCB）

- 线程切换由内核完成；

- 一个线程发起系统调用而阻塞，不会影响其他线程的运行。

- <font color="red">时间片分配给线程</font>，所以多线程的进程获得更多CPU时间。

缺点：

- 线程切换由内核进行，需要从用户态转到管态，资源消耗比较大。

### 用户线程

由用户级线程库进行管理的线程，线程库提供对线程创建和管理的支持，无需内核支持，**此时进程才是CPU调度的基本单位**，**线程不是 CPU 调度的基本单位**。

- 用户线程的维护由应用进程完成；

- 内核不了解用户线程的存在；

- 用户线程切换不需要内核特权；
- 用户线程调度算法可针对应用优化；

**缺点**:

如果进行多对一绑定，一个用户线程发起系统调用而阻塞，则整个进程阻塞。

<font color="red">时间片分配给进程</font>，多线程则每个线程就慢。

### 内核线程与用户线程的比较

**调度方式**：内核线程的调度和切换与进程的调度和切换十分相似，用户线程的调度不需OS的支持。

**调度单位**：用户线程的调度以进程为单位进行，在采用时间片轮转调度算法时，每个进程分配相同的时间片。对内核级线程，每个线程分配时间片。

> 比如，如果每个时间片长 100 ms，对于有 4 个内核级线程的进程，其每个线程都被分配一个时间片（100 ms），整个进程一共被分配 400 ms。对于有 4 个用户级线程的进程，其整个进程被分配一个时间片，因此每个线程只分到 25 ms，整个进程一共被分配 100 ms。

## 5.7 多线程模型

用户级线程无法被系统感觉，内核自然无法调度它。但是，有时我们需要用户级线程完成一些系统调用，此时它就需要「绑定」到一个可以系统调用的线程上。主要的对应关系包含：多对一、一对一、多对多

**多对一**

多个用户级线程映射到单个内核线程，用于不支持内核线程的系统中。

优点：线程切换速度快（不需要进入管态）

缺点：任意时刻只能有一个线程可以访问内核(并发度低)。

一个用户线程发起系统调用而阻塞，则整个进程阻塞

> 因为系统调用阻塞则内核线程阻塞，那么所有用户级线程都没有时间片了
>
> 通常情况下，映射到同一个内核线程的用户线程都来自同一进程。

![image-20211101211537420](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211101211537420.png)

**一对一**

每个用户级线程对应一个内核线程；提供了更好的并发性，一个用户线程发起系统调用而阻塞时允许另一个线程运行

每创建一个用户级线程需创建一个相应的内核线程,带来了额外开销,所以许多系统限制应用中的线程数目。

> 据说 Linux 内核添加线程的方式（NPTL）使用的就是这种方法：pthread 库每创建一个用户级线程，就创建一个对应的系统级线程。

![image-20211101211525876](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211101211525876.png)

**多对多**

多对一模型的缺点：不能实现真正的并发
一对一模型的缺点：需限制应用中的线程数目
多对多模型：不限制应用的线程数、多个线程可以并发

多对多模型：n 个用户级线程绑定到不超过 n 个内核级线程上。

![image-20211101211623311](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211101211623311.png)

**两级模型：**

允许多对多和一对一模型同时存在：部分用户级线程是多对多，其他用户级线程是一对一。

## 5.8 线程的部分系统调用

在创建线程时，POSIX 中的 `fork` 和 `exec` 系统调用相对进程中调用时的语义会发生变化。

**当调用 fork 后没有调用 exec 时**：复制进程中的所有线程

**当调用 fork 后立刻调用 exec 时**：只复制调用 fork 的线程

## 5.9 线程的取消

**异步取消**：一个线程立即终止目标线程

这种情况下的问题是：线程可能和其他线程共享资源；如果回收一个线程的所有资源，其他和它共享资源的线程就会发现，「我的数据怎么没了？」

**延迟取消**：目标线程检查他是否应该终止，检查取消点

即目标线程定期检查是否有信号要撤销自己，如果有的话，在运行到安全的位置时撤销自身。

## 5.10 信号的发送

当特定事件发生时，一般会给进程发送信号来通知

信号可以被同步或异步的接收

同步信号会发送到产生信号的同一个进程。比如，非法内存访问，或者除零错。

当信号是由运行进程之外的事件所产生 ，那么进程就异步的接收信号。比如，定时器中断或者ctrl+C。

- 单线程进程中，信号发送给进程

- 多线程进程中，信号发送给谁？这和信号内容有关

  有些信号，比如 SIGINT（由 Ctrl+C 引起）会被发送给所有线程

  线程可以描述它会接收的信号和拒绝的信号。此时，信号只发给那些不拒绝它的线程。由于信号只能被处理一次，一般将信号发给进程中不拒绝它的第一个线程

- 允许信号发送给一个特定线程，该线程专门处理信号

## 5.11 线程池

创建线程池的目的：避免创建和撤销开销；限制线程的数量

线程池的内容：

- 进程创建时就创建一定数量的线程，放入线程池中等待；（提前创建）

- 进程收到请求时，唤醒线程池中的一个线程进行处理；（直接使用）

- 线程完成工作，返回线程池中继续等待，而不撤销（不撤销）

- 如果没有可用的线程，进程就等待直到有空线程为止

线程池可以降低创建和撤销线程的开销。

线程池中线程的数量一般由 CPU 数量，物理内存大小和需要的并发数量决定

## 5.12 线程特定数据

线程和其所在进程共享所有数据。不过，线程有时也包含一些线程特定数据，这些数据只存在于一个线程中，不和同一进程下的其他线程共享。


## 5.13 线程举例

### **SUN Soloris 2** 

Solaris支持内核线程（Kernel threads）、轻权进程（Lightweight Processes，LWP）和用户线程（User Level Threads）。一个进程可有大量用户线程；大量用户线程复用少量的轻权进程，不同的轻权进程分别对应不同的内核线程。

![image-20240927114029117](https://telegraph-image-5ms.pages.dev/file/BQACAgUAAyEGAASIfjD1AAMPZ2ARs_BYafikg6cLNCd7OQ9tm8UAAnkTAAKnjAABV0dGvQ_xhAMENgQ.png)

用户级线程和 LWP 是多对多绑定的；LWP 和内核级线程是一对一绑定的。用户级线程在使用系统调用时（如文件读写），需要“捆绑(bound)”在一个 LWP 上。可以临时捆绑或者永久捆绑：

- 永久捆绑：一个 LWP 固定被一个用户级线程占用，该LWP移到LWP池之外
- 临时捆绑：从LWP池中临时分配一个未被占用的LWP（系统调用完成后，此 LWP 和用户线程解除绑定）
- 对于没有绑定的 LWP，则由线程库动态地进行调整：
  一个进程对应的 LWP 组成 LWP 池，线程库动态调整池中LWP的数目，以保证应用的最佳性能：

当池中的 LWP 全部阻塞，而进程中还可以运行新的 LWP，则线程库会为之创建另一个 LWP；如果没有多余 LWP 数量，则请求调用的用户线程会阻塞。

当 LWP 执行系统调用而阻塞时，所有与其绑定的用户级线程全部阻塞。

 当一个 LWP 长时间没用（老化，一般为5分钟)，则线程库会删除它。

### **Windows NT**

![image-20211012161534845](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211012161534845.png)

**就绪状态(Ready)**：进程已获得除处理机外的所需资源，等待执行。

**备用状态(Standby**)：特定处理器的执行对象，系统中每个处理器上只能有一个处于备用状态的线程。

> 备用就是就绪和运行之间的状态，类似于 OS 选择一个线程，将为其分配时间片时，这个线程从就绪态变为备用态。

**运行状态(Running)**：完成描述表切换，线程进入运行状态，直到内核抢先、时间片用完、线程终止或进行等待状态。

**等待状态(Waiting)**：线程等待对象句柄，以同步它的执行。等待结束时，根据优先级进入运行、就绪状态。

**转换状态(Transition)**：线程在准备执行而其内核堆栈处于外存时，线程进入转换状态；当其内核堆栈调回内存，线程进入就绪状态。

**终止状态(Terminated)**：线程执行完就进入终止状态；如执行体有一指向线程对象的指针，可将线程对象重新初始化，并再次使用。

**初始化状态(Initialized)：**线程创建过程中的线程状态；

**有关API**

CreateThread()函数在调用进程的地址空间上创建一个线程，以执行指定的函数；返回值为所创建线程的句柄

ExitThread()函数用于结束本线程。

SuspendThread()函数用于挂起指定的线程。

ResumeThread()函数递减指定线程的挂起计数，挂起计数为0时，线程恢复执行

### 线程库

线程库为程序员提供了创建和管理线程的API

有用户级线程库和内核级线程库

**举例**

> POSIX Pthreads  用户级/内核级线程库（都有，取决于具体实现）
> Win32 threads  支持内核线程
> Java thread

### Java Thread

Java 线程可以如下创建：

- 继承并重写 Thread 类的 run 方法
- 实现 Runnable 接口

第一种方法创建的线程，可以通过实例化并调用 start 方法开始运行。

第二种方法创建的线程，可以通过创建一个 Runner 变量，将其指向实现 Runnable 接口的对象，并将这个对象传递给 Thread 类的构造函数执行。

